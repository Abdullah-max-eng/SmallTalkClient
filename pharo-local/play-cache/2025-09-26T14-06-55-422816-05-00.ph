"Part 1 â€” SELECT-only validator (build + send JSON payload)"| sql body valid endsWithSemi rest lc fromPos afterFrom jsonEscaped payload   serverUrl client resp status respBody |"1) Ask user for SQL"sql := UIManager default request: 'Type SQL (blank = quit)'.(sql isNil or: [ (sql withSeparatorsCompacted) isEmpty ]) ifTrue: [ ^ self ]."2) Normalize"sql := sql withSeparatorsCompacted trimBoth.endsWithSemi := (sql notEmpty and: [ sql last = $; ]).body := (endsWithSemi ifTrue: [ sql allButLast ] ifFalse: [ sql ]) trimBoth.lc := body asLowercase."3) Manual SELECT-only validation (simplified)"valid := (lc beginsWith: 'select').valid ifTrue: [	rest := (body copyFrom: 7 to: body size) trimBoth.	fromPos := lc findString: ' from '.	fromPos > 0		ifTrue: [			afterFrom := (body copyFrom: (fromPos + 6) to: body size) trimBoth.			valid := afterFrom size > 0 ]		ifFalse: [			"Allow any non-empty SELECT without FROM (like SELECT 1, SELECT 'hello')"			valid := rest notEmpty ] ].valid ifFalse: [ ^ UIManager default inform: 'Invalid SQL (manual check).' ]."4) Build JSON payload (proper escaping)"jsonEscaped := body.jsonEscaped := jsonEscaped copyReplaceAll: '\' with: '\\'.jsonEscaped := jsonEscaped copyReplaceAll: '"' with: '\"'.jsonEscaped := jsonEscaped copyReplaceAll: String cr with: '\n'.jsonEscaped := jsonEscaped copyReplaceAll: String tab with: '\t'.payload := String streamContents: [ :s |	s		nextPutAll: '{"sql":"';		nextPutAll: jsonEscaped;		nextPutAll: '"}' ]."5) Print payload locally (debug)"Transcript	cr; show: '--- JSON payload ---'; cr;	show: payload; cr;	show: '----------------------'; cr."6) Send payload via RESTful HTTP POST (Zinc)"serverUrl := 'http://httpbin.org/post'.[    [        client := ZnClient new.        client            url: serverUrl;            timeout: 15;				contents: payload;            contentType: ZnMimeType applicationJson;            accept: ZnMimeType applicationJson;            post.                resp := client response.        status := resp code.        respBody := resp hasEntity             ifTrue: [ resp contents ]             ifFalse: [ '' ].                Transcript            cr; show: '--- HTTP Response ---'; cr;            show: 'Status: ', status asString; cr;            show: 'Body:   ', respBody; cr;            show: '-----------------------'; cr.                UIManager default inform:            'Sent to: ', serverUrl, String cr,            'Status: ', status asString, String cr,            'Response body (first 500 chars): ', (respBody first: (respBody size min: 500))                ] on: ZnHttpUnsuccessful     do: [ :ex | UIManager default alert: 'HTTP error: ', ex response code asString ]] on: NetworkErrordo: [ :ex | UIManager default alert: 'Network error: ', ex messageText ].
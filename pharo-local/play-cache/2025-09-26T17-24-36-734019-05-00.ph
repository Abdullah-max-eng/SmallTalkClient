"Continuous SQL prompt â†’ POST to http://localhost:8081/query (Zinc)"| keepGoing serverUrl |keepGoing := true.serverUrl := 'http://localhost:8081/query'.[ keepGoing ] whileTrue: [	| sql body valid endsWithSemi rest lc fromPos afterFrom jsonEscaped payload	  client resp status respBody |	"1) Ask user for SQL (blank/Cancel = quit)"	sql := UIManager default request: 'Type SQL (blank = quit)'.	(sql isNil or: [ (sql withSeparatorsCompacted) isEmpty ])		ifTrue: [			keepGoing := false.			Transcript cr; show: 'ðŸ‘‹ Exiting.'; cr.		]		ifFalse: [			"2) Normalize"			sql := sql withSeparatorsCompacted trimBoth.			endsWithSemi := (sql notEmpty and: [ sql last = $; ]).			body := (endsWithSemi ifTrue: [ sql allButLast ] ifFalse: [ sql ]) trimBoth.			lc := body asLowercase.			"3) Manual SELECT-only validation (simplified)"			valid := (lc beginsWith: 'select').			valid ifTrue: [				rest := (body copyFrom: 7 to: body size) trimBoth.				fromPos := lc findString: ' from '.				fromPos > 0					ifTrue: [						afterFrom := (body copyFrom: (fromPos + 6) to: body size) trimBoth.						valid := afterFrom size > 0					]					ifFalse: [						"Allow SELECT without FROM if rest is non-empty (e.g., SELECT 1)"						valid := rest notEmpty					]			].			valid ifFalse: [				UIManager default inform: 'Invalid SQL (manual check).'			] ifTrue: [				"4) Build JSON payload (escape)"				jsonEscaped := body.				jsonEscaped := jsonEscaped copyReplaceAll: '\' with: '\\'.				jsonEscaped := jsonEscaped copyReplaceAll: '"' with: '\"'.				jsonEscaped := jsonEscaped copyReplaceAll: String cr with: '\n'.				jsonEscaped := jsonEscaped copyReplaceAll: String tab with: '\t'.				payload := String streamContents: [ :s |					s nextPutAll: '{"sql":"'; nextPutAll: jsonEscaped; nextPutAll: '"}' ].				"5) Debug print"				Transcript					cr; show: '--- JSON payload ---'; cr;					show: payload; cr;					show: '----------------------'; cr.				"6) POST via Zinc"				[					[						client := ZnClient new.						client							url: serverUrl;							timeout: 15;							contents: payload;							contentType: ZnMimeType applicationJson;							accept: ZnMimeType applicationJson;							post.						resp := client response.						status := resp code.						respBody := resp hasEntity							ifTrue: [ resp contents ]							ifFalse: [ '' ].						"Log to Transcript"						Transcript							cr; show: '--- HTTP Response ---'; cr;							show: 'Status: '; show: status asString; cr;							show: 'Body:   '; show: respBody; cr;							show: '-----------------------'; cr.						"Single inform: build one string (no cascades)"						UIManager default inform:							(String streamContents: [:s |								s									nextPutAll: 'Sent to: '; nextPutAll: serverUrl; cr;									nextPutAll: 'Status: '; nextPutAll: status asString; cr;									nextPutAll: 'Response body (first 500 chars): ';									nextPutAll: (respBody first: (respBody size min: 500)) ])					]						on: ZnHttpUnsuccessful						do: [ :ex | UIManager default alert: 'HTTP error: ', ex response code asString ].				]					on: NetworkError					do: [ :ex | UIManager default alert: 'Network error: ', ex messageText ].			].		].].
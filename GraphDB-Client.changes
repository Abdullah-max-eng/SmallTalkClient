----QUIT----2025-09-25T17:26:14.528173+02:00 Pharo13.0-SNAPSHOT-64bit-be5cc741ba.image priorSource: 0!----QUIT----2025-09-25T17:26:14.529084+02:00 Pharo13.0-SNAPSHOT-64bit-be5cc741ba.image priorSource: 0!----QUIT----2025-09-25T17:26:36.327172+02:00 Pharo13.0-SNAPSHOT-64bit-be5cc741ba.image priorSource: 104!----QUIT----2025-09-25T17:26:36.329503+02:00 Pharo13.0-SNAPSHOT-64bit-be5cc741ba.image priorSource: 208!----QUIT----2025-09-25T17:26:36.841297+02:00 Pharo13.0-SNAPSHOT-64bit-be5cc741ba.image priorSource: 314!----QUIT----2025-09-25T17:26:36.841938+02:00 Pharo13.0-SNAPSHOT-64bit-be5cc741ba.image priorSource: 420!----SNAPSHOT----2025-09-26T14:04:21.333535-05:00 GraphDB-Client.image priorSource: 526!----SNAPSHOT----2025-09-26T14:04:21.336177-05:00 GraphDB-Client.image priorSource: 632!!BaselineOfSQLite3 commentStamp: '' prior: 0!A baseline for SQlite3 support in Pharo!!BaselineOfSQLite3 methodsFor: 'baselines' stamp: '2025-09-26T14:41:25.334496-05:00'!baseline: spec	<baseline>	spec		for: #pharo		do: [ 			self setUpDependencies: spec.			spec				package: 'SQLite3-Core';				group: 'Core' with: 'SQLite3-Core';				package: 'SQLite3-Core-Benchmarks' with: [ spec requires: 'SQLite3-Core' ];				group: 'Benchmarks' with: 'SQLite3-Core-Benchmarks';								package: 'SQLite3-Core-Tests' with: [ spec requires: 'Core' ];				group: 'Tests' with: 'SQLite3-Core-Tests';								package: 'SQLite3-Glorp' with: [ spec requires: #('Core' 'Glorp-Core') ];				group: 'glorp' with: 'SQLite3-Glorp';								package: 'SQLite3-Glorp-Tests' with: [ spec requires: #('SQLite3-Glorp' 'Glorp-Tests')  ];				group: 'Tools' with: #().			spec				group: 'CI' with: #('SQLite3-Glorp-Tests' 'Tests');				group: 'all' with: #('Core' 'Tests' 'Benchmarks' 'Tools');				group: 'default' with: #('all')			].	self versionSpecificBaseline: spec.! !!BaselineOfSQLite3 methodsFor: 'baselines' stamp: '2025-09-26T14:41:25.33496-05:00'!projectClass	^ MetacelloCypressBaselineProject! !!BaselineOfSQLite3 methodsFor: 'baselines' stamp: '2025-09-26T14:41:25.335554-05:00'!setUpDependencies: spec	spec		baseline: 'Glorp' with: [ spec repository: 'github://pharo-rdbms/glorp/' ];		project: 'Glorp-Core' copyFrom: 'Glorp' with: [ spec loads: 'Core' ];		project: 'Glorp-Tests' copyFrom: 'Glorp' with: [ spec loads: 'Glorp-Integration-Tests' ]! !!BaselineOfSQLite3 methodsFor: 'baselines' stamp: '2025-09-26T14:41:25.336343-05:00'!versionSpecificBaseline: spec  "Add version specific packages to the spec"  spec for: #( #'pharo7.x' #'pharo8.x' ) do: [      spec        package: 'SQLite3-Pharo8';        group: 'Core' with: 'SQLite3-Pharo8'    ].	spec for: #( #'pharo9.x' #'pharo10.x' #'pharo11.x' #'pharo12.x' #'pharo13.x' ) do: [ 		spec			package: 'SQLite3-Pharo9';			group: 'Core' with: 'SQLite3-Pharo9'		].	spec for: #( #'pharo10.x' #'pharo11.x' #'pharo12.x' #'pharo13.x' ) do: [ 		spec			package: 'SQLite3-Pharo10';			group: 'Core' with: 'SQLite3-Pharo10'.		spec			package: 'SQLite3-Inspector-Extensions' with: [ spec requires: #( 'Core' ) ];			group: 'Tools' with: 'SQLite3-Inspector-Extensions'		]! !"BaselineOfSQLite3"!!SQLite3BackupExternalReference commentStamp: '' prior: 0!I represent the SQLite API 'sqlite3_backup' C-level type.!!SQLite3DatabaseExternalObject commentStamp: '' prior: 0!I represent the SQLite API 'sqlite3' C-level type.!!SQLite3StatementExternalObject commentStamp: '' prior: 0!I represent the SQLite API 'sqlite3_stmt' C-level type.!!SQLite3AbstractError commentStamp: '' prior: 0!I represent an SQLite non-ok condition.!!SQLite3NotOpen commentStamp: '' prior: 0!I am signalled when operations are invoked on a database that is not open.!!SQLite3Backup commentStamp: '' prior: 0!I represent a SQLite backup operation.This is detailed at https://sqlite.org/c3ref/backup_finish.html#sqlite3backupinit!!SQLite3BaseConnection commentStamp: '' prior: 0!I represent a connection to an SQLite database. I provide a thin wrapper over the SQLite C API.Do not use this class directly, please check and use my subclass SQLite3Connection!!SQLite3Connection commentStamp: '' prior: 0!I represent a connection to an SQLite database.!!SQLite3Column commentStamp: '' prior: 0!I represent a column in a table!!SQLite3Database commentStamp: '' prior: 0!An SQLite3 database!!SQLite3Row commentStamp: '' prior: 0!I represent a row of results returned by the database.!!SQLite3Table commentStamp: '' prior: 0!A table within a SQLite3 database!!SQLite3Constants commentStamp: '' prior: 0!I provide SQLIte's constants.!!SQLite3Cursor commentStamp: '' prior: 0!I represent a set of results returned by the database. I produce UDBCSQLite3Row instances lazily.!!SQLite3Library commentStamp: '' prior: 0!I am the (unified) FFI interface to SQLite.!!SQLite3NativeError commentStamp: '' prior: 0!Common subclass for errors corresponding to a native SQLite3 C library error code.Typically one uses this class to create and access instances of subclasses:  	(SQLite3NativeError forNativeErrorCode: SQLITE_INTERRUPT  messageText: 'Interrupted') signal!!SQLite3Abort commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_ABORT result code indicates that an operation was aborted prior to completion, usually be application request. See also: SQLITE_INTERRUPT.If the callback function to sqlite3_exec() returns non-zero, then sqlite3_exec() will return SQLITE_ABORT.If a ROLLBACK operation occurs on the same database connection as a pending read or write, then the pending read or write may fail with an SQLITE_ABORT or SQLITE_ABORT_ROLLBACK error.In addition to being a result code, the SQLITE_ABORT value is also used as a conflict resolution mode returned from the sqlite3_vtab_on_conflict() interface.!!SQLite3AbortRollback commentStamp: '' prior: 0!The SQLITE_ABORT_ROLLBACK error code is an extended error code for SQLITE_ABORT indicating that an SQL statement aborted because the transaction that was active when the SQL statement first started was rolled back. Pending write operations always fail with this error when a rollback occurs. A ROLLBACK will cause a pending read operation to fail only if the schema was changed within the transaction being rolled back.!!SQLite3AuthorizationDenied commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_AUTH error is returned when the authorizer callback indicates that an SQL statement being prepared is not authorized.!!SQLite3Busy commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_BUSY result code indicates that the database file could not be written (or in some cases read) because of concurrent activity by some other database connection, usually a database connection in a separate process.For example, if process A is in the middle of a large write transaction and at the same time process B attempts to start a new write transaction, process B will get back an SQLITE_BUSY result because SQLite only supports one writer at a time. Process B will need to wait for process A to finish its transaction before starting a new transaction. The sqlite3_busy_timeout() and sqlite3_busy_handler() interfaces and the busy_timeout pragma are available to process B to help it deal with SQLITE_BUSY errors.An SQLITE_BUSY error can occur at any point in a transaction: when the transaction is first started, during any write or update operations, or when the transaction commits. To avoid encountering SQLITE_BUSY errors in the middle of a transaction, the application can use BEGIN IMMEDIATE instead of just BEGIN to start a transaction. The BEGIN IMMEDIATE command might itself return SQLITE_BUSY, but if it succeeds, then SQLite guarantees that no subsequent operations on the same database through the next COMMIT will return SQLITE_BUSY.See also: SQLITE_BUSY_RECOVERY and SQLITE_BUSY_SNAPSHOT.The SQLITE_BUSY result code differs from SQLITE_LOCKED in that SQLITE_BUSY indicates a conflict with a separate database connection, probably in a separate process, whereas SQLITE_LOCKED indicates a conflict within the same database connection (or sometimes a database connection with a shared cache).!!SQLite3BusyRecovery commentStamp: '' prior: 0!The SQLITE_BUSY_RECOVERY error code is an extended error code for SQLITE_BUSY that indicates that an operation could not continue because another process is busy recovering a WAL mode database file following a crash. The SQLITE_BUSY_RECOVERY error code only occurs on WAL mode databases.!!SQLite3BusySnapshot commentStamp: '' prior: 0!The SQLITE_BUSY_SNAPSHOT error code is an extended error code for SQLITE_BUSY that occurs on WAL mode databases when a database connection tries to promote a read transaction into a write transaction but finds that another database connection has already written to the database and thus invalidated prior reads.The following scenario illustrates how an SQLITE_BUSY_SNAPSHOT error might arise:1. Process A starts a read transaction on the database and does one or more SELECT statement. Process A keeps the transaction open.2. Process B updates the database, changing values previous read by process A.3. Process A now tries to write to the database. But process A's view of the database content is now obsolete because process B has modified the database file after process A read from it. Hence process A gets an SQLITE_BUSY_SNAPSHOT error.!!SQLite3CantOpen commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_CANTOPEN result code indicates that SQLite was unable to open a file. The file in question might be a primary database file or one of several temporary disk files.!!SQLite3CantOpenConvertPath commentStamp: '' prior: 0!The SQLITE_CANTOPEN_CONVPATH error code is an extended error code for SQLITE_CANTOPEN used only by Cygwin VFS and indicating that the cygwin_conv_path() system call failed while trying to open a file. See also: SQLITE_IOERR_CONVPATH!!SQLite3CantOpenFullPath commentStamp: '' prior: 0!The SQLITE_CANTOPEN_FULLPATH error code is an extended error code for SQLITE_CANTOPEN indicating that a file open operation failed because the operating system was unable to convert the filename into a full pathname.!!SQLite3CantOpenIsDir commentStamp: '' prior: 0!The SQLITE_CANTOPEN_ISDIR error code is an extended error code for SQLITE_CANTOPEN indicating that a file open operation failed because the file is really a directory.!!SQLite3CantOpenNoTempDir commentStamp: '' prior: 0!The SQLITE_CANTOPEN_NOTEMPDIR error code is no longer used.!!SQLite3ConstraintViolation commentStamp: '' prior: 0!The SQLITE_CONSTRAINT error code means that an SQL constraint violation occurred while trying to process an SQL statement. Additional information about the failed constraint can be found by consulting the accompanying error message (returned via sqlite3_errmsg() or sqlite3_errmsg16()) or by looking at the extended error code.The SQLITE_CONSTRAINT code can also be used as the return value from the xBestIndex() method of a virtual table implementation. When xBestIndex() returns SQLITE_CONSTRAINT, that indicates that the particular combination of inputs submitted to xBestIndex() cannot result in a usable query plan and should not be given further consideration.!!SQLite3ConstraintViolationCheck commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_CHECK error code is an extended error code for SQLITE_CONSTRAINT indicating that a CHECK constraint failed.!!SQLite3ConstraintViolationCommitHook commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_COMMITHOOK error code is an extended error code for SQLITE_CONSTRAINT indicating that a commit hook callback returned non-zero that thus caused the SQL statement to be rolled back.!!SQLite3ConstraintViolationForeignKey commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_FOREIGNKEY error code is an extended error code for SQLITE_CONSTRAINT indicating that a foreign key constraint failed.!!SQLite3ConstraintViolationFunction commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_FUNCTION error code is not currently used by the SQLite core. However, this error code is available for use by extension functions.!!SQLite3ConstraintViolationNotNull commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_NOTNULL error code is an extended error code for SQLITE_CONSTRAINT indicating that a NOT NULL constraint failed.!!SQLite3ConstraintViolationPrimaryKey commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_PRIMARYKEY error code is an extended error code for SQLITE_CONSTRAINT indicating that a PRIMARY KEY constraint failed.!!SQLite3ConstraintViolationRowID commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_ROWID error code is an extended error code for SQLITE_CONSTRAINT indicating that a rowid is not unique.!!SQLite3ConstraintViolationTrigger commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_TRIGGER error code is an extended error code for SQLITE_CONSTRAINT indicating that a RAISE function within a trigger fired, causing the SQL statement to abort.!!SQLite3ConstraintViolationUnique commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_UNIQUE error code is an extended error code for SQLITE_CONSTRAINT indicating that a UNIQUE constraint failed.!!SQLite3ConstraintViolationVirtualTable commentStamp: '' prior: 0!The SQLITE_CONSTRAINT_VTAB error code is not currently used by the SQLite core. However, this error code is available for use by application-defined virtual tables.!!SQLite3Corrupt commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_CORRUPT result code indicates that the database file has been corrupted. See the How To Corrupt Your Database Files for further discussion on how corruption can occur.!!SQLite3CorruptVirtualTable commentStamp: '' prior: 0!The SQLITE_CORRUPT_VTAB error code is an extended error code for SQLITE_CORRUPT used by virtual tables. A virtual table might return SQLITE_CORRUPT_VTAB to indicate that content in the virtual table is corrupt.!!SQLite3Empty commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_EMPTY result code is not currently used.!!SQLite3Error commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_ERROR result code is a generic error code that is used when no other more specific error code is available.!!SQLite3Format commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_FORMAT result code is not currently used.!!SQLite3Full commentStamp: '' prior: 0!This class comment was automatically generated from https://www.sqlite.org/rescode.htmlThe SQLITE_FULL result code indicates that a write could not complete because the disk is full. Note that this error can occur when trying to write information into the main database file, or it can also occur when writing into temporary disk files.Sometimes applications encounter this error even though there is an abundance of primary disk space because the error occurs when writing into temporary disk files on a system where temporary files are stored on a separate partition with much less space that the primary disk.!!SQLite3IOError commentStamp: '' prior: 0!The SQLITE_IOERR result code says that the operation could not finish because the operating system reported an I/O error.A full disk drive will normally give an SQLITE_FULL error rather than an SQLITE_IOERR error.There are many different extended result codes for I/O errors that identify the specific I/O operation that failed.!!SQLite3IOErrorAccess commentStamp: '' prior: 0!The SQLITE_IOERR_ACCESS error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xAccess method on the sqlite3_vfs object.!!SQLite3IOErrorBlocked commentStamp: '' prior: 0!The SQLITE_IOERR_BLOCKED error code is no longer used.!!SQLite3IOErrorCheckReservedLock commentStamp: '' prior: 0!The SQLITE_IOERR_CHECKRESERVEDLOCK error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xCheckReservedLock method on the sqlite3_io_methods object.!!SQLite3IOErrorClose commentStamp: '' prior: 0!The SQLITE_IOERR_CLOSE error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xClose method on the sqlite3_io_methods object.!!SQLite3IOErrorConvertPath commentStamp: '' prior: 0!The SQLITE_IOERR_CONVPATH error code is an extended error code for SQLITE_IOERR used only by Cygwin VFS and indicating that the cygwin_conv_path() system call failed. See also: SQLITE_CANTOPEN_CONVPATH!!SQLite3IOErrorDelete commentStamp: '' prior: 0!The SQLITE_IOERR_DELETE error code is an extended error code for SQLITE_IOERR indicating an I/O error within xDelete method on the sqlite3_vfs object.!!SQLite3IOErrorDeleteNoEntry commentStamp: '' prior: 0!The SQLITE_IOERR_DELETE_NOENT error code is an extended error code for SQLITE_IOERR indicating that the xDelete method on the sqlite3_vfs object failed because the file being deleted does not exist.!!SQLite3IOErrorDirClose commentStamp: '' prior: 0!The SQLITE_IOERR_DIR_CLOSE error code is no longer used.!!SQLite3IOErrorDirFSync commentStamp: '' prior: 0!The SQLITE_IOERR_DIR_FSYNC error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to invoke fsync() on a directory. The unix VFS attempts to fsync() directories after creating or deleting certain files to ensure that those files will still appear in the filesystem following a power loss or system crash. This error code indicates a problem attempting to perform that fsync().!!SQLite3IOErrorFStat commentStamp: '' prior: 0!The SQLITE_IOERR_FSTAT error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to invoke fstat() (or the equivalent) on a file in order to determine information such as the file size or access permissions.!!SQLite3IOErrorFSync commentStamp: '' prior: 0!The SQLITE_IOERR_FSYNC error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to flush previously written content out of OS and/or disk-control buffers and into persistent storage. In other words, this code indicates a problem with the fsync() system call in unix or the FlushFileBuffers() system call in windows.!!SQLite3IOErrorGetTempPath commentStamp: '' prior: 0!The SQLITE_IOERR_GETTEMPPATH error code is an extended error code for SQLITE_IOERR indicating that the VFS is unable to determine a suitable directory in which to place temporary files.!!SQLite3IOErrorLock commentStamp: '' prior: 0!The SQLITE_IOERR_LOCK error code is an extended error code for SQLITE_IOERR indicating an I/O error in the advisory file locking logic. Usually an SQLITE_IOERR_LOCK error indicates a problem obtaining a PENDING lock. However it can also indicate miscellaneous locking errors on some of the specialized VFSes used on Macs.!!SQLite3IOErrorMemoryMap commentStamp: '' prior: 0!The SQLITE_IOERR_MMAP error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xFetch or xUnfetch methods on the sqlite3_io_methods object while trying to map or unmap part of the database file into the process address space.!!SQLite3IOErrorNoMemory commentStamp: '' prior: 0!The SQLITE_IOERR_NOMEM error code is sometimes returned by the VFS layer to indicate that an operation could not be completed due to the inability to allocate sufficient memory. This error code is normally converted into SQLITE_NOMEM by the higher layers of SQLite before being returned to the application.!!SQLite3IOErrorRead commentStamp: '' prior: 0!The SQLITE_IOERR_READ error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to read from a file on disk. This error might result from a hardware malfunction or because a filesystem came unmounted while the file was open.!!SQLite3IOErrorReadLock commentStamp: '' prior: 0!The SQLITE_IOERR_RDLOCK error code is an extended error code for SQLITE_IOERR indicating an I/O error within xLock method on the sqlite3_io_methods object while trying to obtain a read lock.!!SQLite3IOErrorSeek commentStamp: '' prior: 0!The SQLITE_IOERR_SEEK error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xRead or xWrite methods on the sqlite3_io_methods object while trying to seek a file descriptor to the beginning point of the file where the read or write is to occur.!!SQLite3IOErrorSharedMemoryError commentStamp: '' prior: 0!Abstract superclass for extended errors on shared memory access in SQlite3!!SQLite3IOErrorSharedMemoryLock commentStamp: '' prior: 0!The SQLITE_IOERR_SHMLOCK error code is no longer used.!!SQLite3IOErrorSharedMemoryMap commentStamp: '' prior: 0!The SQLITE_IOERR_SHMMAP error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xShmMap method on the sqlite3_io_methods object while trying to map a shared memory segment into the process address space.!!SQLite3IOErrorSharedMemoryOpen commentStamp: '' prior: 0!The SQLITE_IOERR_SHMOPEN error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xShmMap method on the sqlite3_io_methods object while trying to open a new shared memory segment.!!SQLite3IOErrorSharedMemorySize commentStamp: '' prior: 0!The SQLITE_IOERR_SHMSIZE error code is an extended error code for SQLITE_IOERR indicating an I/O error within the xShmMap method on the sqlite3_io_methods object while trying to enlarge a "shm" file as part of WAL mode transaction processing. This error may indicate that the underlying filesystem volume is out of space.!!SQLite3IOErrorShortRead commentStamp: '' prior: 0!The SQLITE_IOERR_SHORT_READ error code is an extended error code for SQLITE_IOERR indicating that a read attempt in the VFS layer was unable to obtain as many bytes as was requested. This might be due to a truncated file.!!SQLite3IOErrorTruncate commentStamp: '' prior: 0!The SQLITE_IOERR_TRUNCATE error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to truncate a file to a smaller size.!!SQLite3IOErrorUnlock commentStamp: '' prior: 0!The SQLITE_IOERR_UNLOCK error code is an extended error code for SQLITE_IOERR indicating an I/O error within xUnlock method on the sqlite3_io_methods object.!!SQLite3IOErrorWrite commentStamp: '' prior: 0!The SQLITE_IOERR_WRITE error code is an extended error code for SQLITE_IOERR indicating an I/O error in the VFS layer while trying to write into a file on disk. This error might result from a hardware malfunction or because a filesystem came unmounted while the file was open. This error should not occur if the filesystem is full as there is a separate error code (SQLITE_FULL) for that purpose.!!SQLite3Internal commentStamp: '' prior: 0!The SQLITE_INTERNAL result code indicates an internal malfunction. In a working version of SQLite, an application should never see this result code. If application does encounter this result code, it shows that there is a bug in the database engine.SQLite does not currently generate this result code. However, application-defined SQL functions or virtual tables, or VFSes, or other extensions might cause this result code to be returned.!!SQLite3Interrupt commentStamp: '' prior: 0!The SQLITE_INTERRUPT result code indicates that an operation was interrupted by the sqlite3_interrupt() interface. See also: SQLITE_ABORT!!SQLite3Locked commentStamp: '' prior: 0!The SQLITE_LOCKED result code indicates that a write operation could not continue because of a conflict within the same database connection or a conflict with a different database connection that uses a shared cache.For example, a DROP TABLE statement cannot be run while another thread is reading from that table on the same database connection because dropping the table would delete the table out from under the concurrent reader.The SQLITE_LOCKED result code differs from SQLITE_BUSY in that SQLITE_LOCKED indicates a conflict on the same database connection (or on a connection with a shared cache) whereas SQLITE_BUSY indicates a conflict with a different database connection, probably in a different process.!!SQLite3LockedSharedCache commentStamp: '' prior: 0!The SQLITE_LOCKED_SHAREDCACHE error code is an extended error code for SQLITE_LOCKED indicating that the locking conflict has occurred due to contention with a different database connection that happens to hold a shared cache with the database connection to which the error was returned. For example, if the other database connection is holding an exclusive lock on the database, then the database connection that receives this error will be unable to read or write any part of the database file unless it has the read_uncommitted pragma enabled.The SQLITE_LOCKED_SHARECACHE error code works very much like the SQLITE_BUSY error code except that SQLITE_LOCKED_SHARECACHE is for separate database connections that share a cache whereas SQLITE_BUSY is for the much more common case of separate database connections that do not share the same cache. Also, the sqlite3_busy_handler() and sqlite3_busy_timeout() interfaces do not help in resolving SQLITE_LOCKED_SHAREDCACHE conflicts.!!SQLite3LogNotice commentStamp: '' prior: 0!The SQLITE_NOTICE result code is not returned by any C/C++ interface. However, SQLITE_NOTICE (or rather one of its extended error codes) is sometimes used as the first argument in an sqlite3_log() callback to indicate that an unusual operation is taking place.!!SQLite3LogNoticeRecoverRollback commentStamp: '' prior: 0!The SQLITE_NOTICE_RECOVER_ROLLBACK result code is passed to the callback of sqlite3_log() when a hot journal is rolled back.!!SQLite3LogNoticeRecoverWriteAheadLogging commentStamp: '' prior: 0!The SQLITE_NOTICE_RECOVER_WAL result code is passed to the callback of sqlite3_log() when a WAL mode database file is recovered.!!SQLite3LogWarning commentStamp: '' prior: 0!The SQLITE_WARNING result code is not returned by any C/C++ interface. However, SQLITE_WARNING (or rather one of its extended error codes) is sometimes used as the first argument in an sqlite3_log() callback to indicate that an unusual and possibly ill-advised operation is taking place.!!SQLite3LogWarningAutoIndex commentStamp: '' prior: 0!The SQLITE_WARNING_AUTOINDEX result code is passed to the callback of sqlite3_log() whenever automatic indexing is used. This can serve as a warning to application designers that the database might benefit from additional indexes.!!SQLite3Mismatch commentStamp: '' prior: 0!The SQLITE_MISMATCH error code indicates a datatype mismatch.SQLite is normally very forgiving about mismatches between the type of a value and the declared type of the container in which that value is to be stored. For example, SQLite allows the application to store a large BLOB in a column with a declared type of BOOLEAN. But in a few cases, SQLite is strict about types. The SQLITE_MISMATCH error is returned in those few cases when the types do not match.The rowid of a table must be an integer. Attempt to set the rowid to anything other than an integer (or a NULL which will be automatically converted into the next available integer rowid) results in an SQLITE_MISMATCH error.!!SQLite3Misuse commentStamp: '' prior: 0!The SQLITE_MISUSE return code might be returned if the application uses any SQLite interface in a way that is undefined or unsupported. For example, using a prepared statement after that prepared statement has been finalized might result in an SQLITE_MISUSE error.SQLite tries to detect misuse and report the misuse using this result code. However, there is no guarantee that the detection of misuse will be successful. Misuse detection is probabilistic. Applications should never depend on an SQLITE_MISUSE return value.If SQLite ever returns SQLITE_MISUSE from any interface, that means that the application is incorrectly coded and needs to be fixed. Do not ship an application that sometimes returns SQLITE_MISUSE from a standard SQLite interface because that application contains potentially serious bugs.!!SQLite3NoLargeFileSupport commentStamp: '' prior: 0!The SQLITE_NOLFS error can be returned on systems that do not support large files when the database grows to be larger than what the filesystem can handle. "NOLFS" stands for "NO Large File Support".!!SQLite3NoMemory commentStamp: '' prior: 0!The SQLITE_NOMEM result code indicates that SQLite was unable to allocate all the memory it needed to complete the operation. In other words, an internal call to sqlite3_malloc() or sqlite3_realloc() has failed in a case where the memory being allocated was required in order to continue the operation.!!SQLite3NotADatabase commentStamp: '' prior: 0!When attempting to open a file, the SQLITE_NOTADB error indicates that the file being opened does not appear to be an SQLite database file.!!SQLite3NotFound commentStamp: '' prior: 0!The SQLITE_NOTFOUND result code is used in two contexts. SQLITE_NOTFOUND can be returned by the sqlite3_file_control() interface to indicate that the file control opcode passed as the third argument was not recognized by the underlying VFS. SQLITE_NOTFOUND can also be returned by the xSetSystemCall() method of an sqlite3_vfs object.The SQLITE_NOTFOUND result code is also used internally by the SQLite implementation, but those internal uses are not exposed to the application.!!SQLite3OutOfRange commentStamp: '' prior: 0!The SQLITE_RANGE error indices that the parameter number argument to one of the sqlite3_bind routines or the column number in one of the sqlite3_column routines is out of range.!!SQLite3Permission commentStamp: '' prior: 0!The SQLITE_PERM result code indicates that the requested access mode for a newly created database could not be provided.!!SQLite3Protocol commentStamp: '' prior: 0!The SQLITE_PROTOCOL result code indicates a problem with the file locking protocol used by SQLite. The SQLITE_PROTOCOL error is currently only returned when using WAL mode and attempting to start a new transaction. There is a race condition that can occur when two separate database connections both try to start a transaction at the same time in WAL mode. The loser of the race backs off and tries again, after a brief delay. If the same connection loses the locking race dozens of times over a span of multiple seconds, it will eventually give up and return SQLITE_PROTOCOL. The SQLITE_PROTOCOL error should appear in practice very, very rarely, and only when there are many separate processes all competing intensely to write to the same database.!!SQLite3ReadOnly commentStamp: '' prior: 0!The SQLITE_READONLY result code is returned when an attempt is made to alter some data for which the current database connection does not have write permission.!!SQLite3ReadOnlyCantLock commentStamp: '' prior: 0!The SQLITE_READONLY_CANTLOCK error code is an extended error code for SQLITE_READONLY. The SQLITE_READONLY_CANTLOCK error code indicates that SQLite is unable to obtain a read lock on a WAL mode database because the shared-memory file associated with that database is read-only.!!SQLite3ReadOnlyDBMoved commentStamp: '' prior: 0!The SQLITE_READONLY_DBMOVED error code is an extended error code for SQLITE_READONLY. The SQLITE_READONLY_DBMOVED error code indicates that a database cannot be modified because the database file has been moved since it was opened, and so any attempt to modify the database might result in database corruption if the processes crashes because the rollback journal would not be correctly named.!!SQLite3ReadOnlyRecovery commentStamp: '' prior: 0!The SQLITE_READONLY_RECOVERY error code is an extended error code for SQLITE_READONLY. The SQLITE_READONLY_RECOVERY error code indicates that a WAL mode database cannot be opened because the database file needs to be recovered and recovery requires write access but only read access is available.!!SQLite3ReadOnlyRollback commentStamp: '' prior: 0!The SQLITE_READONLY_ROLLBACK error code is an extended error code for SQLITE_READONLY. The SQLITE_READONLY_ROLLBACK error code indicates that a database cannot be opened because it has a hot journal that needs to be rolled back but cannot because the database is readonly.!!SQLite3SchemaChanged commentStamp: '' prior: 0!The SQLITE_SCHEMA result code indicates that the database schema has changed. This result code can be returned from sqlite3_step() for a prepared statement that was generated using sqlite3_prepare() or sqlite3_prepare16(). If the database schema was changed by some other process in between the time that the statement was prepared and the time the statement was run, this error can result.If a prepared statement is generated from sqlite3_prepare_v2() then the statement is automatically re-prepared if the schema changes, up to SQLITE_MAX_SCHEMA_RETRY times (default: 50). The sqlite3_step() interface will only return SQLITE_SCHEMA back to the application if the failure persists after these many retries.!!SQLite3TooBig commentStamp: '' prior: 0!The SQLITE_TOOBIG error code indicates that a string or BLOB was too large. The default maximum length of a string or BLOB in SQLite is 1,000,000,000 bytes. This maximum length can be changed at compile-time using the SQLITE_MAX_LENGTH compile-time option, or at run-time using the sqlite3_limit(db,SQLITE_LIMIT_LENGTH,...) interface. The SQLITE_TOOBIG error results when SQLite encounters a string or BLOB that exceeds the compile-time or run-time limit.The SQLITE_TOOBIG error code can also result when an oversized SQL statement is passed into one of the sqlite3_prepare_v2() interfaces. The maximum length of an SQL statement defaults to a much smaller value of 1,000,000 bytes. The maximum SQL statement length can be set at compile-time using SQLITE_MAX_SQL_LENGTH or at run-time using sqlite3_limit(db,SQLITE_LIMIT_SQL_LENGTH,...).!!SQLite3PreparedStatement commentStamp: '' prior: 0!I represent an SQLite prepared statement.!!SQLite3Result commentStamp: '' prior: 0!I am an abstract superclass for corresponding classes to result codes created by SQLite3 C library.Subclasses should not be instantiated directly. Instead use #forNativeResultCode: with a valid result constant.   SQLite3Result forNativeResultCode: SQLITE_OK!!SQLite3DoneResult commentStamp: '' prior: 0!The SQLITE_DONE result code indicates that an operation has completed. The SQLITE_DONE result code is most commonly seen as a return value from sqlite3_step() indicating that the SQL statement has run to completion. But SQLITE_DONE can also be returned by other multi-step interfaces such as sqlite3_backup_step().!!SQLite3OKResult commentStamp: '' prior: 0!The SQLITE_OK result code means that the operation was successful and that there were no errors. Most other result codes indicate an error.!!SQLite3RowResult commentStamp: '' prior: 0!The SQLITE_ROW result code returned by sqlite3_step() indicates that another row of output is available.!!FFIExternalReference methodsFor: '*SQLite3-Core' stamp: '2025-09-26T14:41:25.635234-05:00'!manualRelease	FFIExternalResourceManager uniqueInstance removeResource: self! !!SQLite3BackupExternalReference methodsFor: 'initialization' stamp: '2025-09-26T14:41:25.63565-05:00'!beNull	^ handle beNull! !!SQLite3DatabaseExternalObject class methodsFor: 'instance finalization' stamp: '2025-09-26T14:41:25.636946-05:00'!doFinalizeResourceData: resourceData	SQLite3Library current ffiCall:		#( int sqlite3_close_v2 #( void * resourceData ) )! !!SQLite3DatabaseExternalObject class methodsFor: 'finalization' stamp: '2025-09-26T14:41:25.637462-05:00'!finalizeResourceData: aHandle	self doFinalizeResourceData: aHandle.	aHandle beNull! !!SQLite3DatabaseExternalObject methodsFor: 'initialization' stamp: '2025-09-26T14:41:25.637656-05:00'!beNull	^ handle beNull! !!SQLite3StatementExternalObject class methodsFor: 'instance finalization' stamp: '2025-09-26T14:41:25.637912-05:00'!doFinalizeResourceData: aHandle	SQLite3Library current ffiCall:		#( int sqlite3_finalize #( void * aHandle ) )! !!SQLite3StatementExternalObject class methodsFor: 'finalization' stamp: '2025-09-26T14:41:25.638084-05:00'!finalizeResourceData: aHandle	self doFinalizeResourceData: aHandle.	aHandle beNull! !!SQLite3StatementExternalObject methodsFor: 'initialization' stamp: '2025-09-26T14:41:25.638235-05:00'!beNull	^ handle beNull! !!SQLite3AbstractError class methodsFor: 'testing' stamp: '2025-09-26T14:41:25.638409-05:00'!isAbstract	^self name = #SQLite3AbstractError! !!SQLite3AbstractError methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.638511-05:00'!resultCode	^ resultCode! !!SQLite3AbstractError methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.638629-05:00'!resultCode: anObject	resultCode := anObject! !!FFIExternalResourceManager methodsFor: '*SQLite3-Core' stamp: '2025-09-26T14:41:25.638895-05:00'!removeResource: anObject	registry remove: anObject ifAbsent: [  ]! !!SQLite3Backup class methodsFor: 'creating' stamp: '2025-09-26T14:41:25.639172-05:00'!to: dConnection named: dName from: sConnection named: sName	^(self new)		dstConnection: dConnection;		dstName: dName;		srcConnection: sConnection;		srcName: sName! !!SQLite3Backup methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.639257-05:00'!dstConnection	^ dstConnection! !!SQLite3Backup methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.639356-05:00'!dstConnection: anObject	dstConnection := anObject! !!SQLite3Backup methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.639426-05:00'!dstName	^ dstName! !!SQLite3Backup methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.639526-05:00'!dstName: anObject	dstName := anObject! !!SQLite3Backup methodsFor: 'finalization' stamp: '2025-09-26T14:41:25.639594-05:00'!finalize	self finish! !!SQLite3Backup methodsFor: 'initialization' stamp: '2025-09-26T14:41:25.639905-05:00'!finish	handle		ifNotNil: [			library apiBackupFinish: handle.			handle beNull.			handle := nil]! !!SQLite3Backup methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.63997-05:00'!handle	^ handle! !!SQLite3Backup methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.640038-05:00'!handle: anObject	handle := anObject! !!SQLite3Backup methodsFor: 'initialization' stamp: '2025-09-26T14:41:25.640216-05:00'!initialize	super initialize.	isOpen := false.	library := SQLite3Library current.	handle := SQLite3DatabaseExternalObject new.	handle autoRelease! !!SQLite3Backup methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.640459-05:00'!isOpen	^ isOpen! !!SQLite3Backup methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.640569-05:00'!open	handle := (library backupTo: dstConnection named: dstName from: srcConnection named: srcName).	isOpen := true! !!SQLite3Backup methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.640633-05:00'!srcConnection	^ srcConnection! !!SQLite3Backup methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.640699-05:00'!srcConnection: anObject	srcConnection := anObject! !!SQLite3Backup methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.640754-05:00'!srcName	^ srcName! !!SQLite3Backup methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.640816-05:00'!srcName: anObject	srcName := anObject! !!SQLite3Backup methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.640944-05:00'!step	"Passing negative number means run to completion"	self step: -1! !!SQLite3Backup methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.64118-05:00'!step: nPages	library backup: handle step: nPages! !!SQLite3BaseConnection class methodsFor: 'testing' stamp: '2025-09-26T14:41:25.641262-05:00'!isAbstract	^ self == SQLite3BaseConnection! !!SQLite3BaseConnection class methodsFor: 'testing' stamp: '2025-09-26T14:41:25.641449-05:00'!isThreadsafe	"Native Library Version http://sqlite.org/c3ref/libversion.html sqlite3_libversion"	^ SQLite3Library current isThreadsafe ~= 0! !!SQLite3BaseConnection class methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.64154-05:00'!libraryVersion	"Native Library Version http://sqlite.org/c3ref/libversion.html sqlite3_libversion"	^ SQLite3Library current libraryVersion! !!SQLite3BaseConnection class methodsFor: 'examples' stamp: '2025-09-26T14:41:25.64163-05:00'!memory	^ self on: ':memory:'! !!SQLite3BaseConnection class methodsFor: 'instance creation' stamp: '2025-09-26T14:41:25.641739-05:00'!on: aFilename	^(self new)		on: aFilename;		yourself! !!SQLite3BaseConnection class methodsFor: 'instance creation' stamp: '2025-09-26T14:41:25.642002-05:00'!openOn: aFilename	^(self new)		on: aFilename;		open;		yourself! !!SQLite3BaseConnection class methodsFor: 'testing' stamp: '2025-09-26T14:41:25.642142-05:00'!threadsafe	"This method is deprecated so consider to migrate."	self deprecated:  'Please use #isThreadsafe instead' transformWith:  '`@receiver threadsafe'						-> '`@receiver isThreadsafe'.	^ self isThreadsafe! !!SQLite3BaseConnection methodsFor: 'public API - backups' stamp: '2025-09-26T14:41:25.642282-05:00'!backupDatabaseNamed: sName to: aConnection named: dName	"database name is either 'main' or 'temp' or the name given to ATTACH DATABASE	See article at https://www.oreilly.com/library/view/using-sqlite/9781449394592/re225.html"	^SQLite3Backup to: aConnection handle named: dName from: dbHandle named: sName! !!SQLite3BaseConnection methodsFor: 'public API - backups' stamp: '2025-09-26T14:41:25.642387-05:00'!backupTo: aConnection	^self backupTo: aConnection named: 'main'! !!SQLite3BaseConnection methodsFor: 'public API - backups' stamp: '2025-09-26T14:41:25.642493-05:00'!backupTo: aConnection named: aName	^SQLite3Backup to: aConnection handle named: aName from: dbHandle named: 'main'! !!SQLite3BaseConnection methodsFor: 'public API - operating' stamp: '2025-09-26T14:41:25.642611-05:00'!basicExecute: anSQLText	^ (self prepare: anSQLText) step; finalize"20190302, pierce: This used to invoke sqlite3_exec() which is an SQLite-internal convenience wrapper around prepare/step/finalize. It is now rewritten as seen to handle UTF8-encoded input properly. Rewriting this method breaks the Bobby Tables test which relies on naive SQL string construction to work."! !!SQLite3BaseConnection methodsFor: 'public API - transactional' stamp: '2025-09-26T14:41:25.642691-05:00'!beginTransaction	^ self basicExecute: 'begin'! !!SQLite3BaseConnection methodsFor: 'public API - introspection' stamp: '2025-09-26T14:41:25.642758-05:00'!changes	^ library changes: dbHandle! !!SQLite3BaseConnection methodsFor: 'public API - operating' stamp: '2025-09-26T14:41:25.642855-05:00'!clearBindings: aStatement	library clearBindings: aStatement handle on: dbHandle! !!SQLite3BaseConnection methodsFor: 'public API - open/close' stamp: '2025-09-26T14:41:25.643071-05:00'!close	"Do the minimal work to close the connection. 	Let FFIExternalResourceManager take care of calling sqlite_close_v2()."	dbHandle ifNil: [ ^ self ].	"Set dbHandle to nil to allow its garbage collection.	The underlying handle should not be switched to NULL here, SQLite3DatabaseExternalObject class>>doFinalizeResourceData: will take care of that"	dbHandle := nil.	isOpen := false! !!SQLite3BaseConnection methodsFor: 'public API - introspection' stamp: '2025-09-26T14:41:25.64394-05:00'!columnNamesFor: aTableName	self isOpen		ifFalse: [ SQLite3NotOpen signal ]		ifTrue: [			^ (self existTableNamed: aTableName)				  ifTrue: [					  | columns s |					  columns := OrderedCollection new.					  s := self prepare: 'pragma table_info([' , aTableName , '])'.					  s basicExecute: [ :row | columns add: (row stringAt: 1) ].					  s finalize.					  columns ]				  ifFalse: [ nil ] ]! !!SQLite3BaseConnection methodsFor: 'public API - transactional' stamp: '2025-09-26T14:41:25.644039-05:00'!commitTransaction	^ self basicExecute: 'commit'! !!SQLite3BaseConnection methodsFor: 'public API - introspection' stamp: '2025-09-26T14:41:25.645765-05:00'!declaredColumnTypesFor: aTableName	self isOpen		ifFalse: [ SQLite3NotOpen signal ]		ifTrue: [			^ (self existTableNamed: aTableName)				  ifTrue: [					  | columns s |					  columns := OrderedCollection new.					  s := self prepare: 'pragma table_info([' , aTableName , '])'.					  s basicExecute: [ :row | columns add: (row stringAt: 2) ].					  s finalize.					  columns ]				  ifFalse: [ nil ] ]! !!SQLite3BaseConnection methodsFor: 'public API - extensions' stamp: '2025-09-26T14:41:25.646047-05:00'!disableExtensions	^ library disableLoadExtension: dbHandle! !!SQLite3BaseConnection methodsFor: 'public API - extensions' stamp: '2025-09-26T14:41:25.646199-05:00'!enableExtensions	^ library enableLoadExtension: dbHandle! !!SQLite3BaseConnection methodsFor: 'private' stamp: '2025-09-26T14:41:25.646688-05:00'!existTableNamed: aTableName	| tableExists s |	tableExists := false.	s := self prepare: 'select count(*) from sqlite_master where type = "table" and tbl_name = ?'.	s at: 1 putString: aTableName.	s basicExecute: [ :row | tableExists := (row integerAt: 0) = 1 ].	s finalize.	^ tableExists! !!SQLite3BaseConnection methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.646775-05:00'!filename	^ dbFilename! !!SQLite3BaseConnection methodsFor: 'public API - operating' stamp: '2025-09-26T14:41:25.646871-05:00'!finalize: aStatementHandle	library finalize: aStatementHandle on: dbHandle! !!SQLite3BaseConnection methodsFor: 'public API - open/close' stamp: '2025-09-26T14:41:25.647031-05:00'!forceClose	"Forces the release of dbHandle, enabling to delete the database file without closing Pharo"	dbHandle ifNotNil: [ library close: dbHandle ].	self close! !!SQLite3BaseConnection methodsFor: 'public API - introspection' stamp: '2025-09-26T14:41:25.647113-05:00'!getAutoCommit	^library getAutoCommit: dbHandle! !!SQLite3BaseConnection methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.647174-05:00'!handle	^dbHandle! !!SQLite3BaseConnection methodsFor: 'initialization' stamp: '2025-09-26T14:41:25.647336-05:00'!initialize	super initialize.	isOpen := false.	library := SQLite3Library current.	dbHandle := SQLite3DatabaseExternalObject new.	dbHandle autoRelease.	statementClass := SQLite3PreparedStatement! !!SQLite3BaseConnection methodsFor: 'testing' stamp: '2025-09-26T14:41:25.647552-05:00'!isOpen	^ isOpen! !!SQLite3BaseConnection methodsFor: 'public API - extensions' stamp: '2025-09-26T14:41:25.647639-05:00'!loadExtension: aFilename	^ library loadExtension: dbHandle with: aFilename! !!SQLite3BaseConnection methodsFor: 'private' stamp: '2025-09-26T14:41:25.647718-05:00'!on: aFilename	dbFilename := aFilename.	^ self! !!SQLite3BaseConnection methodsFor: 'public API - open/close' stamp: '2025-09-26T14:41:25.64793-05:00'!open	library open: dbFilename via: dbHandle.	isOpen := true! !!SQLite3BaseConnection methodsFor: 'public API - operating' stamp: '2025-09-26T14:41:25.648093-05:00'!prepare: anSQLText	| s |	s := self statementClass new.	s connection: self.	s prepare: anSQLText.	^ s! !!SQLite3BaseConnection methodsFor: 'public API - cleaning' stamp: '2025-09-26T14:41:25.648835-05:00'!reset: aStatement	^library reset: aStatement handle! !!SQLite3BaseConnection methodsFor: 'public API - transactional' stamp: '2025-09-26T14:41:25.648912-05:00'!rollbackTransaction	^ self basicExecute: 'rollback'! !!SQLite3BaseConnection methodsFor: 'private' stamp: '2025-09-26T14:41:25.649007-05:00'!signal: exceptionClass with: value	library signal: exceptionClass with: value on: dbHandle! !!SQLite3BaseConnection methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.649068-05:00'!statementClass	^ statementClass! !!SQLite3BaseConnection methodsFor: 'public API - introspection' stamp: '2025-09-26T14:41:25.649543-05:00'!tableNames	| tables s |	self isOpen		ifFalse: [ SQLite3NotOpen signal ]		ifTrue: [			tables := OrderedCollection new.			s := self prepare: 'select tbl_name from sqlite_master where type = "table"'.	  		s basicExecute: [ :row |				(row dataValuesAvailable > 0) ifTrue: [ tables add: (row stringAt: 0) ]].	  		s finalize.			^ tables ]! !!SQLite3BaseConnection methodsFor: 'public API - introspection' stamp: '2025-09-26T14:41:25.649631-05:00'!totalChanges	^ library totalChanges: dbHandle! !!SQLite3BaseConnection methodsFor: 'public API - tracing' stamp: '2025-09-26T14:41:25.649729-05:00'!traceUsing: callback with: appdata	library trace: dbHandle with: callback with: appdata! !!SQLite3Connection methodsFor: 'public API - operating' stamp: '2025-09-26T14:41:25.649833-05:00'!execute: anSQLText	^ self execute: anSQLText with: #()! !!SQLite3Connection methodsFor: 'public API - operating' stamp: '2025-09-26T14:41:25.649972-05:00'!execute: anSQLText value: anObject	^ (self prepare: anSQLText)	execute: (Array with: anObject)! !!SQLite3Connection methodsFor: 'public API - operating' stamp: '2025-09-26T14:41:25.65009-05:00'!execute: anSQLText value: object1 value: object2	^ self execute: anSQLText with: (Array with: object1 with: object2)! !!SQLite3Connection methodsFor: 'public API - operating' stamp: '2025-09-26T14:41:25.650215-05:00'!execute: anSQLText value: object1 value: object2 value: object3	^ self execute: anSQLText		with: (Array with: object1 with: object2 with: object3)! !!SQLite3Connection methodsFor: 'public API - operating' stamp: '2025-09-26T14:41:25.650352-05:00'!execute: anSQLText value: object1 value: object2 value: object3 value: object4	^ self execute: anSQLText		with: (Array with: object1 with: object2 with: object3 with: object4)! !!SQLite3Connection methodsFor: 'public API - operating' stamp: '2025-09-26T14:41:25.65045-05:00'!execute: anSQLText with: aCollection	^(self prepare: anSQLText) execute: aCollection! !!SQLite3Connection methodsFor: 'public API - operating' stamp: '2025-09-26T14:41:25.650738-05:00'!execute: anSQLText with: aCollection doing: aBlock	| cursor |	cursor := self execute: anSQLText with: aCollection.	^ [aBlock value: cursor]			ensure: [ cursor finalizeStatement ]! !!SQLite3Connection methodsFor: 'public API - operating' stamp: '2025-09-26T14:41:25.650954-05:00'!execute: anSQLText withAll: parameterCollection	"execute a sql statement with many parameters"	| stmt |	stmt := self prepare: anSQLText.	parameterCollection do: [ :parameters | stmt execute: parameters ].	stmt finalize! !!SQLite3Column methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.651037-05:00'!cid: anObject	"The cid column should not be taken to mean more than 'rank within the current result set'."	index := anObject! !!SQLite3Column methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.651113-05:00'!hasNotNullConstraint	^ hasNotNullConstraint! !!SQLite3Column methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.652728-05:00'!index	^ index! !!SQLite3Column methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.652897-05:00'!index: anObject	index := anObject! !!SQLite3Column methodsFor: 'initialization' stamp: '2025-09-26T14:41:25.653094-05:00'!initialize	super initialize.	hasNotNullConstraint := false! !!SQLite3Column methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.653257-05:00'!name	^ name! !!SQLite3Column methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.653428-05:00'!name: anObject	name := anObject! !!SQLite3Column methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.653613-05:00'!notnull: anInteger	"whether or not the column can be NULL"	hasNotNullConstraint := anInteger = 1! !!SQLite3Column methodsFor: 'printing' stamp: '2025-09-26T14:41:25.653766-05:00'!printOn: aStream	super printOn: aStream.	aStream		<< '("';		<< self name;		<< '")'! !!SQLite3Column methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.653924-05:00'!type	^ type! !!SQLite3Column methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.653988-05:00'!type: anObject	type := anObject! !!SQLite3Database class methodsFor: 'instance creation' stamp: '2025-09-26T14:41:25.654095-05:00'!forConnection: aConnection	^ self new		initConnection: aConnection;		yourself! !!SQLite3Database class methodsFor: 'instance creation' stamp: '2025-09-26T14:41:25.65419-05:00'!memory	^ self forConnection: SQLite3Connection memory! !!SQLite3Database class methodsFor: 'instance creation' stamp: '2025-09-26T14:41:25.654286-05:00'!on: aFilename	^ self forConnection: (SQLite3Connection on: aFilename)! !!SQLite3Database class methodsFor: 'instance creation' stamp: '2025-09-26T14:41:25.654486-05:00'!openOn: aFilename	^ (self on: aFilename)			open;			yourself! !!SQLite3Database class methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.654615-05:00'!tableInfoFor: aFileName	| db |	db := self on: aFileName.	db connection open.	^ db tables! !!SQLite3Database methodsFor: 'open/close' stamp: '2025-09-26T14:41:25.654692-05:00'!close	^ self connection close! !!SQLite3Database methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.65475-05:00'!connection	^ connection! !!SQLite3Database methodsFor: 'executing' stamp: '2025-09-26T14:41:25.654847-05:00'!execute: anSQLStatement	^ self connection execute: anSQLStatement! !!SQLite3Database methodsFor: 'executing' stamp: '2025-09-26T14:41:25.654947-05:00'!execute: anSQLStatement doing: aBlock	^ self connection execute: anSQLStatement with: #(  ) doing: aBlock! !!SQLite3Database methodsFor: 'private - initialization' stamp: '2025-09-26T14:41:25.655017-05:00'!initConnection: aConnection	connection := aConnection! !!SQLite3Database methodsFor: 'open/close' stamp: '2025-09-26T14:41:25.655089-05:00'!open	^ self connection open! !!SQLite3Database methodsFor: 'printing' stamp: '2025-09-26T14:41:25.655231-05:00'!printOn: aStream	super printOn: aStream.	aStream		<< '("';		<< self connection filename;		<< '")'! !!SQLite3Database methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.655589-05:00'!tables	self connection isOpen ifFalse: [ ^ SQLite3NotOpen signal ].	^ (connection execute: '			SELECT *			FROM sqlite_master			WHERE			    type =''table'' AND    			name NOT LIKE ''sqlite_%'';') rows collect: [ :eachRow |		  SQLite3Table properties: eachRow asDictionary in: self ]! !!SQLite3Row class methodsFor: 'instance creation' stamp: '2025-09-26T14:41:25.655753-05:00'!new: anInteger	^(self new)		columnNames:(Array new:anInteger);		values: (Array new: anInteger);		yourself! !!SQLite3Row methodsFor: 'converting' stamp: '2025-09-26T14:41:25.65595-05:00'!asArray	^ self values asArray! !!SQLite3Row methodsFor: 'converting' stamp: '2025-09-26T14:41:25.65625-05:00'!asCombinedDictionary	^self asDictionary addAll: ((self values collectWithIndex:[:v :i | i -> v]) asDictionary); yourself! !!SQLite3Row methodsFor: 'converting' stamp: '2025-09-26T14:41:25.656475-05:00'!asDictionary	"Borrowed from the future - Pharo 8"	| dict |	dict := Dictionary new.	self columnNames with: self values do: [ :k :v | dict at: k put: v ].	^ dict! !!SQLite3Row methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.656603-05:00'!at: aKey	^ self at: aKey ifAbsent: [  ]! !!SQLite3Row methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.656958-05:00'!at: aKey ifAbsent: aBlock	^ aKey isInteger		ifTrue: [ self values at: aKey ifAbsent: aBlock ]		ifFalse: [ self values at:(self columnNames indexOf: aKey) ifAbsent: aBlock ]! !!SQLite3Row methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.657249-05:00'!at: aKey put: anObject	^ aKey isInteger		ifTrue: [self atIndex: aKey put: anObject]		ifFalse: [ self atName: aKey put: anObject ]! !!SQLite3Row methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.657488-05:00'!atIndex: anIndex	^ values at: anIndex ifAbsent: [  ]! !!SQLite3Row methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.657586-05:00'!atIndex: anIndex put: anObject	^ self values at: anIndex put: anObject! !!SQLite3Row methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.65783-05:00'!atName: aKey	| idx |	idx := self columnNames indexOf: aKey.	^idx = 0		ifTrue: [ SQLite3Misuse				signal: 'Attept to set invalid column name ', aKey, ' in result set'   ]		ifFalse: [ values at: idx ]! !!SQLite3Row methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.658103-05:00'!atName: aKey put: anObject	| idx |	^ (idx := self columnNames indexOf: aKey) isZero		ifTrue: [			columnNames := self columnNames copyWith: aKey.			values := self values copyWith: anObject ]		ifFalse: [ values at: idx put: anObject ]! !!SQLite3Row methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.658213-05:00'!columnNames	^ columnNames ifNil: [ #() ]! !!SQLite3Row methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.658318-05:00'!columnNames: anArray	columnNames := anArray.	values := Array new: anArray size! !!SQLite3Row methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.65839-05:00'!data	"compatibility"	 ^self asCombinedDictionary! !!SQLite3Row methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.658463-05:00'!dataCount	^ self columnNames size! !!SQLite3Row methodsFor: 'reflective operations' stamp: '2025-09-26T14:41:25.658714-05:00'!doesNotUnderstand: aMessage	^ self at: aMessage selector asString			ifAbsent: [				"20160514: This bit, for Glorp integration, feels a bit iffy."				self at: aMessage selector asString asUppercase					ifAbsent: [ super doesNotUnderstand: aMessage ]]! !!SQLite3Row methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.658891-05:00'!first	^ self values ifEmpty: [] ifNotEmpty: [:v | v first ]! !!SQLite3Row methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.659159-05:00'!last	^ self values ifEmpty: [ nil ] ifNotEmpty: [:v | v last ]! !!SQLite3Row methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.659338-05:00'!size	^ self columnNames size! !!SQLite3Row methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.659577-05:00'!values	 ^values ifNil: [ #() ]! !!SQLite3Row methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.659763-05:00'!values: anArray	 values := anArray! !!SQLite3Table class methodsFor: 'instance creation' stamp: '2025-09-26T14:41:25.659891-05:00'!properties: aDictionary in: aDatabase	^ self new		database: aDatabase;		properties: aDictionary;		yourself! !!SQLite3Table methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.66003-05:00'!columnNames	^ self columns collect: [:each | each name ]! !!SQLite3Table methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.66018-05:00'!columns	^ (self database execute: 'pragma table_info([' , self name , ']);')		  rowClass: SQLite3Column;		  rows! !!SQLite3Table methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.660242-05:00'!database	^ database! !!SQLite3Table methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.660307-05:00'!database: anObject	database := anObject! !!SQLite3Table methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.66042-05:00'!name	^ self properties at: #name ifAbsent: [ '' ]! !!SQLite3Table methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.660646-05:00'!numberOfRows	^ (self database execute: 'SELECT COUNT(*) FROM [' , self name , '];')		  onlyValue! !!SQLite3Table methodsFor: 'printing' stamp: '2025-09-26T14:41:25.66078-05:00'!printOn: aStream	super printOn: aStream.	aStream		<< '("';		<< self name;		<< '")'! !!SQLite3Table methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.660994-05:00'!properties	^ properties ifNil: [ properties := Dictionary new ]! !!SQLite3Table methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.661155-05:00'!properties: anObject	properties := anObject! !!SQLite3Table methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.661367-05:00'!rows	^ (self database execute: 'SELECT *			FROM [' , self name , ']			LIMIT 1000;') rows! !!SQLite3Table methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.66145-05:00'!schema	^ self properties at: #sql ifAbsent: ''! !!SQLite3Constants class methodsFor: 'private - initialization' stamp: '2025-09-26T14:41:25.661613-05:00'!initCheckpointModes    SQLITE_CHECKPOINT_PASSIVE := 0.    SQLITE_CHECKPOINT_FULL := 1.    SQLITE_CHECKPOINT_RESTART := 2.    SQLITE_CHECKPOINT_TRUNCATE := 3! !!SQLite3Constants class methodsFor: 'private - initialization' stamp: '2025-09-26T14:41:25.661728-05:00'!initConstants	self		initResultCodes;		initErrorCodes;		initExtendedErrorCodes;		initFileOpenFlags! !!SQLite3Constants class methodsFor: 'private - initialization' stamp: '2025-09-26T14:41:25.661859-05:00'!initDataTypes	"Fundamental Datatypes"	SQLITE_INTEGER := 1.	SQLITE_FLOAT := 2.	SQLITE_TEXT := 3.	SQLITE3_TEXT := 3.	SQLITE_BLOB := 4.	SQLITE_NULL := 5! !!SQLite3Constants class methodsFor: 'private - initialization constants' stamp: '2025-09-26T14:41:25.662334-05:00'!initErrorCodes	"In its default configuration, SQLite API routines return one of 26 integer	[SQLITE_OK | result codes]."	SQLITE_ERROR := 1. 			"SQL error or missing database"	SQLITE_INTERNAL := 2.			"Internal logic error in SQLite"	SQLITE_PERM := 3.				"Access permission denied"	SQLITE_ABORT := 4.				"Callback routine requested an abort"	SQLITE_BUSY := 5.  			"The database file is locked"	SQLITE_LOCKED := 6. 			"A table in the database is locked"	SQLITE_NOMEM := 7.				"A malloc() failed"	SQLITE_READONLY := 8.			"Attempt to write a readonly database"	SQLITE_INTERRUPT := 9.		"Operation terminated by sqlite3_interrupt()"	SQLITE_IOERR := 10.			"Some kind of disk I/O error occurred"	SQLITE_CORRUPT := 11.			"The database disk image is malformed"	SQLITE_NOTFOUND := 12.		"Unknown opcode in sqlite3_file_control()"	SQLITE_FULL := 13.				"Insertion failed because database is full"	SQLITE_CANTOPEN := 14.   	"Unable to open the database file"	SQLITE_PROTOCOL := 15.		"Database lock protocol error"	SQLITE_EMPTY := 16.			"Database is empty"	SQLITE_SCHEMA := 17.			"The database schema changed"	SQLITE_TOOBIG := 18.			"String or BLOB exceeds size limit"	SQLITE_CONSTRAINT := 19.		"Abort due to constraint violation"	SQLITE_MISMATCH := 20.		"Data type mismatch"	SQLITE_MISUSE := 21. 			"Library used incorrectly"	SQLITE_NOLFS := 22.			"Uses OS features not supported on host"	SQLITE_AUTH := 23.				"Authorization denied"	SQLITE_FORMAT := 24.			"Auxiliary database format error"	SQLITE_RANGE := 25.			"2nd parameter to sqlite3_bind out of range"	SQLITE_NOTADB := 26.			"File opened that is not a database file"	SQLITE_NOTICE := 27.			"Notifications from sqlite3_log()"	SQLITE_WARNING := 28.			"Warnings from sqlite3_log()"! !!SQLite3Constants class methodsFor: 'private - initialization constants' stamp: '2025-09-26T14:41:25.665388-05:00'!initExtendedErrorCodes	"Newer versions of SQLite (version 3.3.8 and later) include support for additional result codes that provide more detailed information about errors. The extended result codes are enabled or disabled on a per database connection basis using the [sqlite3_extended_result_codes()] API."    SQLITE_ERROR_MISSING_COLLSEQ    := (SQLITE_ERROR | (1<<8)).    SQLITE_ERROR_RETRY              := (SQLITE_ERROR | (2<<8)).    SQLITE_ERROR_SNAPSHOT           := (SQLITE_ERROR | (3<<8)).    SQLITE_IOERR_READ               := (SQLITE_IOERR | (1<<8)).    SQLITE_IOERR_SHORT_READ         := (SQLITE_IOERR | (2<<8)).    SQLITE_IOERR_WRITE              := (SQLITE_IOERR | (3<<8)).    SQLITE_IOERR_FSYNC              := (SQLITE_IOERR | (4<<8)).    SQLITE_IOERR_DIR_FSYNC          := (SQLITE_IOERR | (5<<8)).    SQLITE_IOERR_TRUNCATE           := (SQLITE_IOERR | (6<<8)).    SQLITE_IOERR_FSTAT              := (SQLITE_IOERR | (7<<8)).    SQLITE_IOERR_UNLOCK             := (SQLITE_IOERR | (8<<8)).    SQLITE_IOERR_RDLOCK             := (SQLITE_IOERR | (9<<8)).    SQLITE_IOERR_DELETE             := (SQLITE_IOERR | (10<<8)).    SQLITE_IOERR_BLOCKED            := (SQLITE_IOERR | (11<<8)).    SQLITE_IOERR_NOMEM              := (SQLITE_IOERR | (12<<8)).    SQLITE_IOERR_ACCESS             := (SQLITE_IOERR | (13<<8)).    SQLITE_IOERR_CHECKRESERVEDLOCK  := (SQLITE_IOERR | (14<<8)).    SQLITE_IOERR_LOCK               := (SQLITE_IOERR | (15<<8)).    SQLITE_IOERR_CLOSE              := (SQLITE_IOERR | (16<<8)).    SQLITE_IOERR_DIR_CLOSE          := (SQLITE_IOERR | (17<<8)).    SQLITE_IOERR_SHMOPEN            := (SQLITE_IOERR | (18<<8)).    SQLITE_IOERR_SHMSIZE            := (SQLITE_IOERR | (19<<8)).    SQLITE_IOERR_SHMLOCK            := (SQLITE_IOERR | (20<<8)).    SQLITE_IOERR_SHMMAP             := (SQLITE_IOERR | (21<<8)).    SQLITE_IOERR_SEEK               := (SQLITE_IOERR | (22<<8)).    SQLITE_IOERR_DELETE_NOENT       := (SQLITE_IOERR | (23<<8)).    SQLITE_IOERR_MMAP               := (SQLITE_IOERR | (24<<8)).    SQLITE_IOERR_GETTEMPPATH        := (SQLITE_IOERR | (25<<8)).    SQLITE_IOERR_CONVPATH           := (SQLITE_IOERR | (26<<8)).    SQLITE_IOERR_VNODE              := (SQLITE_IOERR | (27<<8)).    SQLITE_IOERR_AUTH               := (SQLITE_IOERR | (28<<8)).    SQLITE_IOERR_BEGIN_ATOMIC       := (SQLITE_IOERR | (29<<8)).    SQLITE_IOERR_COMMIT_ATOMIC      := (SQLITE_IOERR | (30<<8)).    SQLITE_IOERR_ROLLBACK_ATOMIC    := (SQLITE_IOERR | (31<<8)).    SQLITE_LOCKED_SHAREDCACHE       := (SQLITE_LOCKED |  (1<<8)).    SQLITE_LOCKED_VTAB              := (SQLITE_LOCKED |  (2<<8)).    SQLITE_BUSY_RECOVERY            := (SQLITE_BUSY   |  (1<<8)).    SQLITE_BUSY_SNAPSHOT            := (SQLITE_BUSY   |  (2<<8)).    SQLITE_CANTOPEN_NOTEMPDIR       := (SQLITE_CANTOPEN | (1<<8)).    SQLITE_CANTOPEN_ISDIR           := (SQLITE_CANTOPEN | (2<<8)).    SQLITE_CANTOPEN_FULLPATH        := (SQLITE_CANTOPEN | (3<<8)).    SQLITE_CANTOPEN_CONVPATH        := (SQLITE_CANTOPEN | (4<<8)).    SQLITE_CANTOPEN_DIRTYWAL        := (SQLITE_CANTOPEN | (5<<8)). "Not Used"    SQLITE_CORRUPT_VTAB             := (SQLITE_CORRUPT | (1<<8)).    SQLITE_CORRUPT_SEQUENCE         := (SQLITE_CORRUPT | (2<<8)).    SQLITE_READONLY_RECOVERY        := (SQLITE_READONLY | (1<<8)).    SQLITE_READONLY_CANTLOCK        := (SQLITE_READONLY | (2<<8)).    SQLITE_READONLY_ROLLBACK        := (SQLITE_READONLY | (3<<8)).    SQLITE_READONLY_DBMOVED         := (SQLITE_READONLY | (4<<8)).    SQLITE_READONLY_CANTINIT        := (SQLITE_READONLY | (5<<8)).    SQLITE_READONLY_DIRECTORY       := (SQLITE_READONLY | (6<<8)).    SQLITE_ABORT_ROLLBACK           := (SQLITE_ABORT | (2<<8)).    SQLITE_CONSTRAINT_CHECK         := (SQLITE_CONSTRAINT | (1<<8)).    SQLITE_CONSTRAINT_COMMITHOOK    := (SQLITE_CONSTRAINT | (2<<8)).    SQLITE_CONSTRAINT_FOREIGNKEY    := (SQLITE_CONSTRAINT | (3<<8)).    SQLITE_CONSTRAINT_FUNCTION      := (SQLITE_CONSTRAINT | (4<<8)).    SQLITE_CONSTRAINT_NOTNULL       := (SQLITE_CONSTRAINT | (5<<8)).    SQLITE_CONSTRAINT_PRIMARYKEY    := (SQLITE_CONSTRAINT | (6<<8)).    SQLITE_CONSTRAINT_TRIGGER       := (SQLITE_CONSTRAINT | (7<<8)).    SQLITE_CONSTRAINT_UNIQUE        := (SQLITE_CONSTRAINT | (8<<8)).    SQLITE_CONSTRAINT_VTAB          := (SQLITE_CONSTRAINT | (9<<8)).    SQLITE_CONSTRAINT_ROWID         := (SQLITE_CONSTRAINT |(10<<8)).    SQLITE_NOTICE_RECOVER_WAL       := (SQLITE_NOTICE | (1<<8)).    SQLITE_NOTICE_RECOVER_ROLLBACK  := (SQLITE_NOTICE | (2<<8)).    SQLITE_WARNING_AUTOINDEX        := (SQLITE_WARNING | (1<<8)).    SQLITE_AUTH_USER                := (SQLITE_AUTH | (1<<8)).    SQLITE_OK_LOAD_PERMANENTLY      := (SQLITE_OK | (1<<8))! !!SQLite3Constants class methodsFor: 'private - initialization constants' stamp: '2025-09-26T14:41:25.666265-05:00'!initFileOpenFlags	SQLITE_OPEN_READONLY      	  := Integer readFrom: '00000001' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_READWRITE         := Integer readFrom: '00000002' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_CREATE            := Integer readFrom: '00000004' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_DELETEONCLOSE     := Integer readFrom: '00000008' base: 16.  " VFS only "	SQLITE_OPEN_EXCLUSIVE         := Integer readFrom: '00000010' base: 16.  " VFS only "	SQLITE_OPEN_AUTOPROXY         := Integer readFrom: '00000020' base: 16.  " VFS only "	SQLITE_OPEN_URI               := Integer readFrom: '00000040' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_MEMORY            := Integer readFrom: '00000080' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_MAIN_DB           := Integer readFrom: '00000100' base: 16.  " VFS only "	SQLITE_OPEN_TEMP_DB           := Integer readFrom: '00000200' base: 16.  " VFS only "	SQLITE_OPEN_TRANSIENT_DB      := Integer readFrom: '00000400' base: 16.  " VFS only "	SQLITE_OPEN_MAIN_JOURNAL      := Integer readFrom: '00000800' base: 16.  " VFS only "	SQLITE_OPEN_TEMP_JOURNAL      := Integer readFrom: '00001000' base: 16.  " VFS only "	SQLITE_OPEN_SUBJOURNAL        := Integer readFrom: '00002000' base: 16.  " VFS only "	SQLITE_OPEN_MASTER_JOURNAL    := Integer readFrom: '00004000' base: 16.  " VFS only "	SQLITE_OPEN_NOMUTEX           := Integer readFrom: '00008000' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_FULLMUTEX         := Integer readFrom: '00010000' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_SHAREDCACHE       := Integer readFrom: '00020000' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_PRIVATECACHE      := Integer readFrom: '00040000' base: 16.  " Ok for sqlite3_open_v2() "	SQLITE_OPEN_WAL               := Integer readFrom: '00080000' base: 16.  " VFS only "! !!SQLite3Constants class methodsFor: 'private - initialization constants' stamp: '2025-09-26T14:41:25.666436-05:00'!initResultCodes	SQLITE_OK := 0.		 			"Successful result"	SQLITE_ROW := 100.				"sqlite3_step() has another row ready"	SQLITE_DONE := 101 			"sqlite3_step() has finished executing"! !!SQLite3Constants class methodsFor: 'initialization' stamp: '2025-09-26T14:41:25.666535-05:00'!initialize	self		initConstants;		initDataTypes;		initCheckpointModes! !!SQLite3Cursor class methodsFor: 'instance creation' stamp: '2025-09-26T14:41:25.666777-05:00'!on: aStatement	^(self new) statement: aStatement; yourself! !!SQLite3Cursor methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.666949-05:00'!changes	^statement changes! !!SQLite3Cursor methodsFor: 'API' stamp: '2025-09-26T14:41:25.667088-05:00'!close	" closing a cursor is not the same as closing the statement - we may reuse a prepared statement"	statement ifNotNil: [ statement reset ].	statement := nil.	mutators := nil! !!SQLite3Cursor methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.667228-05:00'!columnNames	^ statement ifNotNil: [ statement columnNames ] ifNil: [ #() ]! !!SQLite3Cursor methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.667293-05:00'!connection	^statement connection! !!SQLite3Cursor methodsFor: 'enumerating' stamp: '2025-09-26T14:41:25.667506-05:00'!do: aBlock	"Evaluate aBlock with each of the receiver's rows as the argument."	| eachRow |	[ (eachRow := self next) isNotNil ] whileTrue: [		aBlock value: eachRow ]! !!SQLite3Cursor methodsFor: 'API' stamp: '2025-09-26T14:41:25.667704-05:00'!finalizeStatement	statement finalize! !!SQLite3Cursor methodsFor: 'initialization' stamp: '2025-09-26T14:41:25.667809-05:00'!initialize	"Initializes the receiver"	super initialize.	moreRows := true.	rowClass := SQLite3Row! !!SQLite3Cursor methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.668248-05:00'!mutators	^ mutators		ifNil: [ mutators := self columnNames				collect: [ :c |					(((c substrings: ' _-()') collect: [ :ea | ea capitalized ])						joinUsing: '') uncapitalized asSymbol asMutator ] ]! !!SQLite3Cursor methodsFor: 'API' stamp: '2025-09-26T14:41:25.668335-05:00'!next	^ self nextOfClass: self rowClass! !!SQLite3Cursor methodsFor: 'API' stamp: '2025-09-26T14:41:25.669419-05:00'!nextOfClass: aRowClass	| rr |	moreRows ifFalse: [ ^nil ].	statement		ifNil: [ SQLite3Misuse				signal: 'This result set does not contain a prepared statement.' ].	moreRows		ifTrue: [			rr := aRowClass new.			(rr respondsTo: #columnNames:)				ifTrue: [ "generic row class"					rr columnNames: self columnNames.					1 to: statement dataValuesAvailable do: [ :c | rr at: c put: (statement valueOfColumn: c - 1) ].					 ]				ifFalse: [ | msgs |					"custom object"					msgs := self mutators.					1 to: msgs size do: [ :c |						(rr respondsTo: (msgs at: c))							ifTrue: [ rr perform: (msgs at: c) with: (statement valueOfColumn: c - 1) ] ]						].			moreRows := statement step = SQLITE_ROW.			moreRows ifFalse: [ self close ].			^ rr ].	^ nil! !!SQLite3Cursor methodsFor: 'API' stamp: '2025-09-26T14:41:25.669559-05:00'!onlyRow	^ self onlyRow: [ ]"For the common case where there is exactly one row expected. Returns nil if there is no row."! !!SQLite3Cursor methodsFor: 'API' stamp: '2025-09-26T14:41:25.669755-05:00'!onlyRow: ifNoneBlock	^self rows		ifEmpty: [ ifNoneBlock value ]		ifNotEmpty: [ rows first ]."For the common case where there is exactly one row expected. Returns the evaluation of ifNoneBlock if there is no row."! !!SQLite3Cursor methodsFor: 'API' stamp: '2025-09-26T14:41:25.669919-05:00'!onlyValue	^(self onlyRow: []) ifNotNil: [ :r | r first ]! !!SQLite3Cursor methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.669978-05:00'!rowClass	^ rowClass! !!SQLite3Cursor methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.670045-05:00'!rowClass: anObject	rowClass := anObject! !!SQLite3Cursor methodsFor: 'API' stamp: '2025-09-26T14:41:25.670123-05:00'!rows	^ self rowsOfClass: self rowClass! !!SQLite3Cursor methodsFor: 'API' stamp: '2025-09-26T14:41:25.671538-05:00'!rowsOfClass: aRowClass	rows ifNil: [ rows := OrderedCollection new ].	[ moreRows ] whileTrue: [			rows add: (self nextOfClass: aRowClass) ].	^ rows! !!SQLite3Cursor methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.6716-05:00'!statement	^ statement! !!SQLite3Cursor methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.671767-05:00'!statement: anObject	statement := anObject.	moreRows := (statement ifNil:[false ] ifNotNil: [ statement dataValuesAvailable > 0 ])! !!SQLite3Library class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.671843-05:00'!booleanSQLFalseWords	^ #('false' 'f')! !!SQLite3Library class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.671909-05:00'!booleanSQLTrueWords	^ #('true' 't')! !!SQLite3Library class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.671968-05:00'!booleanTypes	^ #('boolean' 'bool')! !!SQLite3Library class methodsFor: 'factory' stamp: '2025-09-26T14:41:25.672035-05:00'!current	^self uniqueInstance! !!SQLite3Library class methodsFor: 'unified FFI - binding' stamp: '2025-09-26T14:41:25.672289-05:00'!ffiBindingOf: aTypeName	^ TypeMap at: aTypeName ifAbsent: [ super ffiBindingOf: aTypeName ]! !!SQLite3Library class methodsFor: 'class initialization' stamp: '2025-09-26T14:41:25.672384-05:00'!initialize	self		initializeTypeMap;		initializeDataTypeMap;		initializeDateTimeTypeMap! !!SQLite3Library class methodsFor: 'private - initialization' stamp: '2025-09-26T14:41:25.672607-05:00'!initializeDataTypeMap	DataTypeMap := Dictionary newFromPairs: #(		1			#integerAt:		2			#floatAt:		3			#stringAt:		4			#byteArrayAt:		5			#nilAt:	)! !!SQLite3Library class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.672782-05:00'!initializeDateTimeTypeMap	DateTimeTypeMap := {		'datetime' -> #dateTimeAt:.		'date' -> #dateAt:.		'timestamp' -> #timestampAt:.		'time' -> #timeAt: } asDictionary! !!SQLite3Library class methodsFor: 'private - initialization' stamp: '2025-09-26T14:41:25.672901-05:00'!initializeTypeMap	TypeMap := Dictionary newFromPairs: #(		sqlite3		      #SQLite3DatabaseExternalObject		sqlite3_stmt			#SQLite3StatementExternalObject		sqlite3_backup		#NBSQLite3BackupExternalObject		"sqlite3_blob			NBSQLite3BlobExternalObject "		sqlite3_int64		FFIInt64	)! !!SQLite3Library class methodsFor: 'factory' stamp: '2025-09-26T14:41:25.672971-05:00'!reset	uniqueInstance := nil! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.673196-05:00'!apiBackupFinish: backupHandle	"int sqlite3_backup_finish(sqlite3_backup *p)"	^ self ffiCall: #(int sqlite3_backup_finish(SQLite3BackupExternalReference *backupHandle))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.673311-05:00'!apiBackupPageCount: backupHandle	"int sqlite3_backup_pagecount(sqlite3_backup *p)"	^ self ffiCall: #(int sqlite3_backup_pagecount(sqlite3_backup *backupHandle))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.673415-05:00'!apiBackupRemaining: backupHandle	"int sqlite3_backup_remaining(sqlite3_backup *p)"	^ self ffiCall: #(int sqlite3_backup_remaining(sqlite3_backup *backupHandle))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.673525-05:00'!apiBackupStep:nPage via: backupHandle	"int sqlite3_backup_step(sqlite3_backup *p, int nPage)"	^ self ffiCall: #(int sqlite3_backup_step(SQLite3BackupExternalReference *backupHandle, int nPage))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.673685-05:00'!apiBackupTo: pDest named: zDestName from: pSource named: zSourceName	"sqlite3_backup *sqlite3_backup_init(  sqlite3 *pDest,                        /* Destination database handle */  const char *zDestName,                 /* Destination database name */  sqlite3 *pSource,                      /* Source database handle */  const char *zSourceName                /* Source database name */)"	^ self ffiCall: #(SQLite3BackupExternalReference *sqlite3_backup_init(  sqlite3 *pDest, String zDestName, sqlite3 *pSource, String zSourceName))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.673858-05:00'!apiBindBlob: aStatement atColumn: aColumn with: aByteArray with: anInteger with: aPointer	"int sqlite3_bind_blob(sqlite3_stmt*, int, const void *, int, void(*)(void*))"	^ self ffiCall: #(int sqlite3_bind_blob (sqlite3_stmt* aStatement, int aColumn, void* aByteArray, int anInteger, int aPointer)) "SQLITE_TRANSIENT"! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.67399-05:00'!apiBindDouble: aStatement atColumn: aColumn with: aFloat	"int sqlite3_bind_double(sqlite3_stmt*, int, double)"	^ self ffiCall: #(int sqlite3_bind_double (sqlite3_stmt* aStatement, int aColumn, double aFloat))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.674119-05:00'!apiBindInteger: aStatement atColumn: aColumn with: anInteger	"int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite_int64)"	^ self		ffiCall: #(int sqlite3_bind_int64 (sqlite3_stmt* aStatement,int aColumn,sqlite3_int64 anInteger))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.674235-05:00'!apiBindNull: aStatement atColumn: aColumn	"int sqlite3_bind_null(sqlite3_stmt*, int)"	^ self ffiCall: #(int sqlite3_bind_null (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.674335-05:00'!apiBindParameterCount: aStatement	"int sqlite3_bind_parameter_count(sqlite3_stmt*)"	^ self ffiCall: #(int sqlite3_bind_parameter_count (sqlite3_stmt* aStatement))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.674449-05:00'!apiBindParameterIndex: aStatement for: aName	"int sqlite3_bind_parameter_index(sqlite3_stmt*, const char* zName)"	^ self ffiCall: #(int sqlite3_bind_parameter_index (sqlite3_stmt* aStatement, String aName))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.674604-05:00'!apiBindText: aStatement atColumn: aColumn with: aString with: anInteger with: anotherInteger	"int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int, void(*)(void*))"	^ self ffiCall: #(int sqlite3_bind_text (sqlite3_stmt* aStatement, int aColumn, String aString, int anInteger, int anotherInteger))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.674704-05:00'!apiChanges: handle	"int sqlite3_changes(sqlite3*)"	^ self ffiCall: #(int sqlite3_changes (sqlite3 *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.674802-05:00'!apiClearBindings: aStatement	"int sqlite3_clear_bindings(sqlite3_stmt*)"	^ self ffiCall: #(int sqlite3_clear_bindings (sqlite3_stmt* aStatement))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.674896-05:00'!apiClose: handle	"int sqlite3_close_v2(sqlite3*)"	^self ffiCall: #(int sqlite3_close_v2(sqlite3 *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.67501-05:00'!apiColumnBlob: aStatement atColumn: aColumn	"const void *sqlite3_column_blob(sqlite3_stmt*, int)"	^ self ffiCall: #(const void *sqlite3_column_blob (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.675123-05:00'!apiColumnBytes: aStatement atColumn: aColumn	"int sqlite3_column_bytes(sqlite3_stmt*, int)"	^ self ffiCall: #(int sqlite3_column_bytes (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.675222-05:00'!apiColumnCount: aStatement	"int sqlite3_column_count(sqlite3_stmt *pStmt)"	^ self ffiCall: #(int sqlite3_column_count(sqlite3_stmt *aStatement))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.675338-05:00'!apiColumnDeclaredType: aStatement atColumn: aColumn	"const char *sqlite3_column_decltype(sqlite3_stmt*, int)"	^ self		ffiCall: #(String sqlite3_column_decltype #(sqlite3_stmt *aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.675452-05:00'!apiColumnDouble: aStatement atColumn: aColumn	"double sqlite3_column_double(sqlite3_stmt*, int)"	^ self ffiCall: #(double sqlite3_column_double (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.675566-05:00'!apiColumnInt: aStatement atColumn: aColumn	"int sqlite3_column_int(sqlite3_stmt*, int)"	^ self ffiCall: #(sqlite3_int64 sqlite3_column_int64 (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.675678-05:00'!apiColumnName: aStatement atColumn: aColumn	"const char *sqlite3_column_name(sqlite3_stmt*, int)"	^ self		ffiCall: #(String sqlite3_column_name(sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.675792-05:00'!apiColumnText: aStatement atColumn: aColumn	"const unsigned char *sqlite3_column_text(sqlite3_stmt*, int)"	^ self ffiCall: #(String sqlite3_column_text (sqlite3_stmt* aStatement, int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.675907-05:00'!apiColumnType: aStatement atColumn: aColumn	"int sqlite3_column_type(sqlite3_stmt*, int)"	^ self		ffiCall: #(int sqlite3_column_type(sqlite3_stmt* aStatement,int aColumn))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.676084-05:00'!apiConfigLoadExtension: dbHandle with: op with: onoff with: retpointer	"This is a specific invocation of sqlite3_db_config(sqlite3*, int, ...)."	^self ffiCall: #(int sqlite3_db_config (sqlite3 *dbHandle, int op, int onoff, int *retpointer))"Notes from https://www.sqlite.org/c3ref/c_dbconfig_enable_fkey.html:op == SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSIONThis option is used to enable or disable the sqlite3_load_extension() interface independently of the load_extension() SQL function. The sqlite3_enable_load_extension() API enables or disables both the C-API sqlite3_load_extension() and the SQL function load_extension(). There should be two additional arguments. When the first argument to this interface is 1, then only the C-API is enabled and the SQL function remains disabled. If the first argument to this interface is 0, then both the C-API and the SQL function are disabled. If the first argument is -1, then no changes are made to state of either the C-API or the SQL function. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether sqlite3_load_extension() interface is disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the new setting is not reported back."! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.676628-05:00'!apiDBHandle: statementHandle	"sqlite3 *sqlite3_db_handle(sqlite3_stmt*);"	^self ffiCall: #(SQLite3DatabaseExternalObject *sqlite3_db_handle(SQLite3StatementExternalObject *statementHandle))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.676723-05:00'!apiDataCount: handle	"int sqlite3_data_count(sqlite3_stmt*)"	^ self ffiCall: #(int sqlite3_data_count (sqlite3_stmt *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.676817-05:00'!apiErrorMessage: handle	"const char *sqlite3_errmsg(sqlite3*)"	^self ffiCall: #(String sqlite3_errmsg(sqlite3 *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.676973-05:00'!apiExec: dbHandle withSQLText: anSQLText with: callback with: callbackData with: errorMessageBuffer	"int sqlite3_exec(sqlite3*, const char*, int (*callback), void*, char **)"	^self ffiCall: #(int sqlite3_exec (sqlite3 *dbHandle, String anSQLText, void *callback, void *callbackData, char **errorMessageBuffer))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.677072-05:00'!apiFinalize: handle	"int sqlite3_finalize(sqlite3_stmt*)"	^self ffiCall: #(int sqlite3_finalize(sqlite3_stmt *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.677165-05:00'!apiGetAutocommit: handle	"int sqlite3_get_autocommit(sqlite3*);"	^ self ffiCall: #(int sqlite3_get_autocommit (sqlite3 *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.677259-05:00'!apiLastInsertRowid: handle	"sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*)"	^ self ffiCall: #(long sqlite3_last_insert_rowid(SQLite3DatabaseExternalObject *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.677346-05:00'!apiLibVersion	"const char *sqlite3_libversion(void)"	^self ffiCall: #(String sqlite3_libversion(void))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.677502-05:00'!apiLoadExtension: dbHandle with: zFile with: zProc with: pzErrMsg	"int sqlite3_load_extension(sqlite3*, const char*, const char*, char **)."	^self ffiCall: #(int sqlite3_load_extension (sqlite3 *dbHandle, String zFile, const char *zProc, char **pzErrMsg))		module: self library! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.677614-05:00'!apiOpen: filename via: handle	"int sqlite3_open(const char*, sqlite3**)"	^self ffiCall: #(int sqlite3_open(String filename, sqlite3 **handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.677753-05:00'!apiOpen: filename withFlags: flags vfs: vfs via: handle	"int sqlite3_open_v2(  const char *filename,   /* Database filename (UTF-8) */  sqlite3 **ppDb,         /* OUT: SQLite db handle */  int flags,              /* Flags */  const char *zVfs        /* Name of VFS module to use */)"	^self ffiCall: #(int sqlite3_open_v2(String filename, sqlite3 **handle, int flags, String vfs))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.677929-05:00'!apiPrepare: dbHandle withSQLText: anSQLText with: textSize with: sHandle with: tail	"int sqlite3_prepare_v2(sqlite3*, const char*, int, sqlite3_stmt**, const char **)"	^ self ffiCall: #(int sqlite3_prepare_v2 (sqlite3* dbHandle, String anSQLText, int textSize, sqlite3_stmt** sHandle, const char** tail))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.678029-05:00'!apiReset: handle	"int sqlite3_reset(sqlite3_stmt*)"	^ self ffiCall: #(int sqlite3_reset (sqlite3_stmt *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.678111-05:00'!apiSleep	"int sqlite3_sleep(int)"	^ self ffiCall: #(int sqlite3_sleep(int))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.678203-05:00'!apiSql: handle	"const char *sqlite3_sql(sqlite3_stmt*)"	^ self ffiCall: #(String sqlite3_sql (sqlite3_stmt* handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.678296-05:00'!apiStatementReadOnly: handle	"int sqlite3_stmt_readonly(sqlite3_stmt *pStmt)"	^ self ffiCall: #(int sqlite3_stmt_readonly (SQLite3StatementExternalObject * handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.678391-05:00'!apiStep: handle	"int sqlite3_step(sqlite3_stmt*)"	^ self ffiCall: #(int sqlite3_step (sqlite3_stmt* handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.678472-05:00'!apiThreadsafe	"int sqlite3_threadsafe(void)"	^self ffiCall: #(int sqlite3_threadsafe(void))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.678567-05:00'!apiTotalChanges: handle	"int sqlite3_total_changes(sqlite3*)"	^ self ffiCall: #(int sqlite3_total_changes (sqlite3 *handle))! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.678689-05:00'!apiTrace: handle with: callback with: appdata	^ self ffiCall: #(void* sqlite3_trace (sqlite3* handle, FFICallback callback, ExternalAddress appdata))! !!SQLite3Library methodsFor: 'operating' stamp: '2025-09-26T14:41:25.678786-05:00'!backup: backupHandle step: nPages	^self apiBackupStep: nPages via: backupHandle! !!SQLite3Library methodsFor: 'operating' stamp: '2025-09-26T14:41:25.678903-05:00'!backupTo: dstConnection named: dstName from: srcConnection named: srcName	^self apiBackupTo: dstConnection named: dstName from: srcConnection named: srcName! !!SQLite3Library methodsFor: 'operating' stamp: '2025-09-26T14:41:25.678984-05:00'!bindParameterCount: aStatementHandle	^ self apiBindParameterCount: aStatementHandle! !!SQLite3Library methodsFor: 'operating' stamp: '2025-09-26T14:41:25.679073-05:00'!bindParameterIndex: aStatementHandle for: aName	^ self apiBindParameterIndex: aStatementHandle for: aName! !!SQLite3Library methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.679931-05:00'!blobFrom: aStatement at: aColumn	| address size array |	address := self apiColumnBlob: aStatement atColumn: aColumn.	size := self apiColumnBytes: aStatement atColumn: aColumn.	array := address copyFrom: 1 to: size.	^array! !!SQLite3Library methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.680858-05:00'!booleanFrom: aStatement at: aColumn	| declared selector value |	declared := self apiColumnDeclaredType: aStatement atColumn: aColumn.	(self class booleanTypes includes: declared asLowercase) ifFalse: [		SQLite3AbstractError signal: 'Column is not declared as a boolean.' ].	selector := DataTypeMap at: (self apiColumnType: aStatement atColumn: aColumn).	(selector = #nilAt:) ifTrue: [ ^ nil ].	(selector = #stringAt:)		ifTrue: [			value := self apiColumnText: aStatement atColumn: aColumn.			(self class booleanSQLTrueWords includes: value asLowercase)				ifTrue: [ ^ true ]				ifFalse: [					(self class booleanSQLFalseWords includes: value asLowercase)						ifTrue: [ ^ false ]						ifFalse: [ SQLite3AbstractError signal: 'Column value cannot be read as a boolean.' ]]].	(selector = #integerAt:)		ifTrue: [			value := self apiColumnInt: aStatement atColumn: aColumn.			(value = 1)				ifTrue: [ ^ true ]				ifFalse: [					(value = 0)						ifTrue: [ ^ false ]						ifFalse: [ SQLite3AbstractError signal: 'Column value cannot be read as a boolean.' ]]]! !!SQLite3Library methodsFor: 'introspection' stamp: '2025-09-26T14:41:25.680975-05:00'!changes: aHandle	^ self apiChanges: aHandle! !!SQLite3Library methodsFor: 'private - utilities' stamp: '2025-09-26T14:41:25.681163-05:00'!checkForOk: anInteger on: aHandle	^ self sqlite3ResultFor: anInteger ifNoneMatch: [		 (SQLite3NativeError forNativeErrorCode: anInteger messageText: (self apiErrorMessage: aHandle)) signal ]! !!SQLite3Library methodsFor: 'cleaning' stamp: '2025-09-26T14:41:25.681277-05:00'!clearBindings: sHandle on: dbHandle	^ self checkForOk: (self apiClearBindings: sHandle) on: dbHandle! !!SQLite3Library methodsFor: 'connection handling' stamp: '2025-09-26T14:41:25.681355-05:00'!close: aHandle	^ self apiClose: aHandle! !!SQLite3Library methodsFor: 'connection handling' stamp: '2025-09-26T14:41:25.681435-05:00'!columnCount: aStatementHandle	^ self apiColumnCount: aStatementHandle! !!SQLite3Library methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.681512-05:00'!dataValuesAvailable: aStatementHandle	^ self apiDataCount: aStatementHandle! !!SQLite3Library methodsFor: 'connection handling' stamp: '2025-09-26T14:41:25.681589-05:00'!dbHandle: statementHandle	^self apiDBHandle: statementHandle! !!SQLite3Library methodsFor: 'configuring' stamp: '2025-09-26T14:41:25.681734-05:00'!disableLoadExtension: aHandle	^ self checkForOk: (self apiConfigLoadExtension: aHandle with: 1005 with: 0 with: ExternalAddress new)		on: aHandle"Magic number 1005 = SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION.See comment in #apiConfigLoadExtension:with:with:with:."! !!SQLite3Library methodsFor: 'configuring' stamp: '2025-09-26T14:41:25.681867-05:00'!enableLoadExtension: aHandle	^ self checkForOk: (self apiConfigLoadExtension: aHandle with: 1005 with: 1 with: ExternalAddress new)		on: aHandle"Magic number 1005 = SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION.See comment in #apiConfigLoadExtension:with:with:with:."! !!SQLite3Library methodsFor: 'operating' stamp: '2025-09-26T14:41:25.682038-05:00'!execute: anSQLText on: aDBHandle	| null |	null := ExternalAddress new.	^ self checkForOk: (self apiExec: aDBHandle							withSQLText: anSQLText							with: null							with: null							with: null)		 on: aDBHandle! !!SQLite3Library methodsFor: 'operating' stamp: '2025-09-26T14:41:25.682187-05:00'!finalize: aStatementHandle on: aDBHandle	| result |	result := self checkForOk: (self apiFinalize: aStatementHandle) on: aDBHandle.	aStatementHandle beNull.	^ result! !!SQLite3Library methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.682286-05:00'!floatFrom: aStatement at: aColumn	^ self apiColumnDouble: aStatement atColumn: aColumn! !!SQLite3Library methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.682379-05:00'!getAutoCommit: aHandle	^ (self apiGetAutocommit: aHandle) ~= 0! !!SQLite3Library methodsFor: 'operating' stamp: '2025-09-26T14:41:25.682473-05:00'!integerFrom: aStatement at: aColumn	^ self apiColumnInt: aStatement atColumn: aColumn! !!SQLite3Library methodsFor: 'testing' stamp: '2025-09-26T14:41:25.682545-05:00'!isThreadsafe	"http://sqlite.org/c3ref/threadsafe.html"	^ self apiThreadsafe! !!SQLite3Library methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.682624-05:00'!lastInsertRowId: dbHandle	^ self apiLastInsertRowid: dbHandle! !!SQLite3Library methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.682689-05:00'!library	^self libraryName! !!SQLite3Library methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.682759-05:00'!libraryVersion	"See http://sqlite.org/c3ref/libversion.html"	^self apiLibVersion! !!SQLite3Library methodsFor: 'private - api' stamp: '2025-09-26T14:41:25.682903-05:00'!loadExtension: dbHandle with: aFilename	^ self checkForOk: (self apiLoadExtension: dbHandle										with: aFilename										with: ExternalAddress new										with: ExternalAddress new)		on: dbHandle! !!SQLite3Library methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.683219-05:00'!macLibraryName	| pluginDir |	pluginDir := FileSystem /'usr'/'lib'.	#('libsqlite3.dylib' 'libsqlite3.0.dylib' 'sqlite3/libtclsqlite3.dylib')		detect: [ :each | (pluginDir / each) exists ]		ifFound: [ :libName | ^ (pluginDir / libName) fullName  ].	self error: 'Module not found.'! !!SQLite3Library methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.683328-05:00'!nameFor: aStatement at: aColumn	^ self apiColumnName: aStatement atColumn: aColumn! !!SQLite3Library methodsFor: 'connection handling' stamp: '2025-09-26T14:41:25.683441-05:00'!open: aFilename via: aHandle	^ self checkForOk: (self apiOpen: aFilename via: aHandle) on: aHandle! !!SQLite3Library methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.683578-05:00'!open: aFilename withFlags: flags vfs: vfs via: aHandle	^ self checkForOk: (self apiOpen: aFilename withFlags: flags vfs: vfs via: aHandle) on: aHandle! !!SQLite3Library methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.683707-05:00'!open: aFilename withFlags: flags via: aHandle	^ self checkForOk: (self apiOpen: aFilename withFlags: flags vfs: nil via: aHandle) on: aHandle! !!SQLite3Library methodsFor: 'private - conversion' stamp: '2025-09-26T14:41:25.683808-05:00'!pharoStringToUTF8: aPharoString	"Converts from Pharo Multibyte Characters to SQLite3 UTF-8 storage format"	^ZnUTF8Encoder new encodeString: aPharoString! !!SQLite3Library methodsFor: 'operating' stamp: '2025-09-26T14:41:25.684008-05:00'!prepare: aStatementHandle on: aDBHandle with: anSQLText	| utf8SQL |	utf8SQL := self pharoStringToUTF8: anSQLText.	^ self checkForOk: (self apiPrepare: aDBHandle							withSQLText: utf8SQL							with: utf8SQL size							with: aStatementHandle							with: (ExternalAddress new))		 on: aDBHandle! !!SQLite3Library methodsFor: 'cleaning' stamp: '2025-09-26T14:41:25.684169-05:00'!reset: aStatementHandle	^ aStatementHandle		ifNil: [ 0 ]		ifNotNil: [ self apiReset: aStatementHandle ]! !!SQLite3Library methodsFor: 'private - utilities' stamp: '2025-09-26T14:41:25.684308-05:00'!signal: exceptionClass with: value on: handle	(exceptionClass new)		resultCode: value;		signal: (self apiErrorMessage: handle)! !!SQLite3Library methodsFor: 'stepping' stamp: '2025-09-26T14:41:25.684392-05:00'!sqlText: aStatementHandle	^ self apiSql: aStatementHandle! !!SQLite3Library methodsFor: 'private - utilities' stamp: '2025-09-26T14:41:25.684541-05:00'!sqlite3ResultFor: anInteger ifNoneMatch: aBlock	^[		SQLite3Result forNativeResultCode: anInteger	] on: NotFound do: aBlock! !!SQLite3Library methodsFor: 'stepping' stamp: '2025-09-26T14:41:25.684644-05:00'!statementReadOnly: handle	"int sqlite3_stmt_readonly(sqlite3_stmt *pStmt)"	^ (self apiStatementReadOnly: handle) ~= 0! !!SQLite3Library methodsFor: 'stepping' stamp: '2025-09-26T14:41:25.684724-05:00'!step: aStatementHandle	^ self apiStep: aStatementHandle! !!SQLite3Library methodsFor: 'testing' stamp: '2025-09-26T14:41:25.684834-05:00'!threadsafe	"This method is deprecated so consider to migrate."	self deprecated:  'Please use #isThreadsafe instead' transformWith:  '`@receiver threadsafe'						-> '`@receiver isThreadsafe'.	^ self isThreadsafe! !!SQLite3Library methodsFor: 'introspection' stamp: '2025-09-26T14:41:25.684917-05:00'!totalChanges: aHandle	^ self apiTotalChanges: aHandle! !!SQLite3Library methodsFor: 'tracing' stamp: '2025-09-26T14:41:25.685019-05:00'!trace: handle with: callback with: appdata	^ self apiTrace: handle with: callback with: appdata! !!SQLite3Library methodsFor: 'private - utilities' stamp: '2025-09-26T14:41:25.685503-05:00'!typeFor: aStatement at: aColumn	| selector declared |	declared := self apiColumnDeclaredType: aStatement atColumn: aColumn.	declared ifNotNil: [ "Handle column type of boolean as a special case."		(self class booleanTypes includes: declared) ifTrue: [ ^ #booleanAt: ] ].	selector := DataTypeMap at: (self apiColumnType: aStatement atColumn: aColumn).	selector = #stringAt: ifTrue: [		declared ifNotNil: [ "Handle column type of date/time as a special case."			^ DateTimeTypeMap at: declared asLowercase ifAbsent: [ selector ] ] ].	^ selector! !!SQLite3Library methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.685945-05:00'!unix32LibraryName	(#('/usr/lib/i386-linux-gnu' '/usr/lib32' '/usr/lib'),			((OSEnvironment current at: 'LD_LIBRARY_PATH' ifAbsent: [ '' ]) substrings: ':'))		do: [ :path |			#('libsqlite3.so.0' 'libsqlite3.so') do: [ :libraryName |			| libraryPath |			libraryPath := path asFileReference / libraryName.			libraryPath exists				ifTrue: [ ^ libraryPath fullName ] ] ].	self error: 'Module not found.'! !!SQLite3Library methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.687485-05:00'!unix64LibraryName	(#('/usr/lib/x86_64-linux-gnu' '/lib/x86_64-linux-gnu' '/usr/lib64' '/usr/lib'),			((OSEnvironment current at: 'LD_LIBRARY_PATH' ifAbsent: [ '' ]) substrings: ':'))		do: [ :path |			#('libsqlite3.so.0' 'libsqlite3.so') do: [ :libraryName |				| libraryPath |				libraryPath := path asFileReference /  libraryName.				libraryPath exists					ifTrue: [ ^ libraryPath fullName ]]].	self error: 'Module not found.'! !!SQLite3Library methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.687581-05:00'!win32LibraryName	^ FFIWindowsLibraryFinder findLibrary: 'sqlite3.dll'! !!SQLite3Library methodsFor: 'operating' stamp: '2025-09-26T14:41:25.687712-05:00'!with: aStatement at: aColumn putBlob: aByteArray	^ self		  apiBindBlob: aStatement		  atColumn: aColumn		  with: aByteArray		  with: aByteArray size		  with: 0! !!SQLite3Library methodsFor: 'operating' stamp: '2025-09-26T14:41:25.687823-05:00'!with: aStatement at: aColumn putFloat: aFloat	^ self apiBindDouble: aStatement atColumn: aColumn with: aFloat! !!SQLite3Library methodsFor: 'operating' stamp: '2025-09-26T14:41:25.687933-05:00'!with: aStatement at: aColumn putInteger: anInteger	^ self apiBindInteger: aStatement atColumn: aColumn with: anInteger! !!SQLite3Library methodsFor: 'operating' stamp: '2025-09-26T14:41:25.688093-05:00'!with: aStatement at: aColumn putText: aString	| bytes |	bytes := self pharoStringToUTF8: aString.	^ self		  apiBindText: aStatement		  atColumn: aColumn		  with: bytes		  with: bytes size		  with: 0! !!SQLite3Library methodsFor: 'operating' stamp: '2025-09-26T14:41:25.688195-05:00'!with: aStatement putNullAt: aColumn	^ self apiBindNull: aStatement atColumn: aColumn! !!SQLite3Abort class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.688264-05:00'!nativeErrorCode	^ SQLITE_ABORT! !!SQLite3AbortRollback class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.688327-05:00'!nativeErrorCode	^ SQLITE_ABORT_ROLLBACK! !!SQLite3AuthorizationDenied class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.688389-05:00'!nativeErrorCode	^ SQLITE_AUTH! !!SQLite3Busy class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.688449-05:00'!nativeErrorCode	^ SQLITE_BUSY! !!SQLite3BusyRecovery class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.688508-05:00'!nativeErrorCode	^ SQLITE_BUSY_RECOVERY! !!SQLite3BusySnapshot class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.688567-05:00'!nativeErrorCode	^ SQLITE_BUSY_SNAPSHOT! !!SQLite3CantOpen class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.688627-05:00'!nativeErrorCode	^ SQLITE_CANTOPEN! !!SQLite3CantOpenConvertPath class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.688685-05:00'!nativeErrorCode	^ SQLITE_CANTOPEN_CONVPATH! !!SQLite3CantOpenFullPath class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.688747-05:00'!nativeErrorCode	^ SQLITE_CANTOPEN_FULLPATH! !!SQLite3CantOpenIsDir class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.688805-05:00'!nativeErrorCode	^ SQLITE_CANTOPEN_ISDIR! !!SQLite3CantOpenNoTempDir class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.688864-05:00'!nativeErrorCode	^ SQLITE_CANTOPEN_NOTEMPDIR! !!SQLite3ConstraintViolation class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.688922-05:00'!nativeErrorCode	^ SQLITE_CONSTRAINT! !!SQLite3ConstraintViolationCheck class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.68898-05:00'!nativeErrorCode	^ SQLITE_CONSTRAINT_CHECK! !!SQLite3ConstraintViolationCommitHook class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.689066-05:00'!nativeErrorCode	^ SQLITE_CONSTRAINT_COMMITHOOK! !!SQLite3ConstraintViolationForeignKey class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.689126-05:00'!nativeErrorCode	^ SQLITE_CONSTRAINT_FOREIGNKEY! !!SQLite3ConstraintViolationFunction class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.689186-05:00'!nativeErrorCode	^ SQLITE_CONSTRAINT_FUNCTION! !!SQLite3ConstraintViolationNotNull class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.689245-05:00'!nativeErrorCode	^ SQLITE_CONSTRAINT_NOTNULL! !!SQLite3ConstraintViolationPrimaryKey class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.689305-05:00'!nativeErrorCode	^ SQLITE_CONSTRAINT_PRIMARYKEY! !!SQLite3ConstraintViolationRowID class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.689365-05:00'!nativeErrorCode	^ SQLITE_CONSTRAINT_ROWID! !!SQLite3ConstraintViolationTrigger class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.689425-05:00'!nativeErrorCode	^ SQLITE_CONSTRAINT_TRIGGER! !!SQLite3ConstraintViolationUnique class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.689484-05:00'!nativeErrorCode	^ SQLITE_CONSTRAINT_UNIQUE! !!SQLite3ConstraintViolationVirtualTable class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.689544-05:00'!nativeErrorCode	^ SQLITE_CONSTRAINT_VTAB! !!SQLite3Corrupt class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.689605-05:00'!nativeErrorCode	^ SQLITE_CORRUPT! !!SQLite3CorruptVirtualTable class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.689676-05:00'!nativeErrorCode	^ SQLITE_CORRUPT_VTAB! !!SQLite3Empty class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.689733-05:00'!nativeErrorCode	^ SQLITE_EMPTY! !!SQLite3Error class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.689789-05:00'!nativeErrorCode	^ SQLITE_ERROR! !!SQLite3Format class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.689845-05:00'!nativeErrorCode	^ SQLITE_FORMAT! !!SQLite3Full class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.689901-05:00'!nativeErrorCode	^ SQLITE_FULL! !!SQLite3IOError class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.689958-05:00'!nativeErrorCode	^ SQLITE_IOERR! !!SQLite3IOErrorAccess class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.690014-05:00'!nativeErrorCode	^ SQLITE_IOERR_ACCESS! !!SQLite3IOErrorBlocked class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.690074-05:00'!nativeErrorCode	^ SQLITE_IOERR_BLOCKED! !!SQLite3IOErrorCheckReservedLock class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.690132-05:00'!nativeErrorCode	^ SQLITE_IOERR_CHECKRESERVEDLOCK! !!SQLite3IOErrorClose class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.69019-05:00'!nativeErrorCode	^ SQLITE_IOERR_CLOSE! !!SQLite3IOErrorConvertPath class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.690249-05:00'!nativeErrorCode	^ SQLITE_IOERR_CONVPATH! !!SQLite3IOErrorDelete class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.690307-05:00'!nativeErrorCode	^ SQLITE_IOERR_DELETE! !!SQLite3IOErrorDeleteNoEntry class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.690365-05:00'!nativeErrorCode	^ SQLITE_IOERR_DELETE_NOENT! !!SQLite3IOErrorDirClose class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.690425-05:00'!nativeErrorCode	^ SQLITE_IOERR_DIR_CLOSE! !!SQLite3IOErrorDirFSync class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.690482-05:00'!nativeErrorCode	^ SQLITE_IOERR_DIR_FSYNC! !!SQLite3IOErrorFStat class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.690541-05:00'!nativeErrorCode	^ SQLITE_IOERR_FSTAT! !!SQLite3IOErrorFSync class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.690599-05:00'!nativeErrorCode	^ SQLITE_IOERR_FSYNC! !!SQLite3IOErrorGetTempPath class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.690657-05:00'!nativeErrorCode	^ SQLITE_IOERR_GETTEMPPATH! !!SQLite3IOErrorLock class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.690715-05:00'!nativeErrorCode	^ SQLITE_IOERR_LOCK! !!SQLite3IOErrorMemoryMap class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.690773-05:00'!nativeErrorCode	^ SQLITE_IOERR_MMAP! !!SQLite3IOErrorNoMemory class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.690831-05:00'!nativeErrorCode	^ SQLITE_IOERR_NOMEM! !!SQLite3IOErrorRead class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.690888-05:00'!nativeErrorCode	^ SQLITE_IOERR_READ! !!SQLite3IOErrorReadLock class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.690945-05:00'!nativeErrorCode	^ SQLITE_IOERR_RDLOCK! !!SQLite3IOErrorSeek class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.691002-05:00'!nativeErrorCode	^ SQLITE_IOERR_SEEK! !!SQLite3IOErrorSharedMemoryError class methodsFor: 'testing' stamp: '2025-09-26T14:41:25.691088-05:00'!isAbstract	^self name = #SQLite3IOErrorSharedMemoryError! !!SQLite3IOErrorSharedMemoryLock class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.69115-05:00'!nativeErrorCode	^ SQLITE_IOERR_SHMLOCK! !!SQLite3IOErrorSharedMemoryMap class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.691209-05:00'!nativeErrorCode	^ SQLITE_IOERR_SHMMAP! !!SQLite3IOErrorSharedMemoryOpen class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.691269-05:00'!nativeErrorCode	^ SQLITE_IOERR_SHMOPEN! !!SQLite3IOErrorSharedMemorySize class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.691328-05:00'!nativeErrorCode	^ SQLITE_IOERR_SHMSIZE! !!SQLite3IOErrorShortRead class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.691388-05:00'!nativeErrorCode	^ SQLITE_IOERR_SHORT_READ! !!SQLite3IOErrorTruncate class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.691446-05:00'!nativeErrorCode	^ SQLITE_IOERR_TRUNCATE! !!SQLite3IOErrorUnlock class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.691503-05:00'!nativeErrorCode	^ SQLITE_IOERR_UNLOCK! !!SQLite3IOErrorWrite class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.691561-05:00'!nativeErrorCode	^ SQLITE_IOERR_WRITE! !!SQLite3Internal class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.691618-05:00'!nativeErrorCode	^ SQLITE_INTERNAL! !!SQLite3Interrupt class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.691674-05:00'!nativeErrorCode	^ SQLITE_INTERRUPT! !!SQLite3Locked class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.69173-05:00'!nativeErrorCode	^ SQLITE_LOCKED! !!SQLite3LockedSharedCache class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.691786-05:00'!nativeErrorCode	^ SQLITE_LOCKED_SHAREDCACHE! !!SQLite3LogNotice class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.691843-05:00'!nativeErrorCode	^ SQLITE_NOTICE! !!SQLite3LogNoticeRecoverRollback class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.691899-05:00'!nativeErrorCode	^ SQLITE_NOTICE_RECOVER_ROLLBACK! !!SQLite3LogNoticeRecoverWriteAheadLogging class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.691957-05:00'!nativeErrorCode	^ SQLITE_NOTICE_RECOVER_WAL! !!SQLite3LogWarning class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.692015-05:00'!nativeErrorCode	^ SQLITE_WARNING! !!SQLite3LogWarningAutoIndex class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.692072-05:00'!nativeErrorCode	^ SQLITE_WARNING_AUTOINDEX! !!SQLite3Mismatch class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.692129-05:00'!nativeErrorCode	^ SQLITE_MISMATCH! !!SQLite3Misuse class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.692186-05:00'!nativeErrorCode	^ SQLITE_MISUSE! !!SQLite3NativeError class methodsFor: 'examples' stamp: '2025-09-26T14:41:25.692286-05:00'!example	(SQLite3NativeError forNativeErrorCode: SQLITE_INTERRUPT  messageText: 'Interrupted') signal! !!SQLite3NativeError class methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.69242-05:00'!forNativeErrorCode: anInteger messageText: aString	^(self subclassForNativeErrorCode: anInteger) new			messageText: aString;			yourself! !!SQLite3NativeError class methodsFor: 'testing' stamp: '2025-09-26T14:41:25.692503-05:00'!isAbstract	^self name = #SQLite3NativeError! !!SQLite3NativeError class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.692575-05:00'!nativeErrorCode	"Returns the native error code as defined by SQLite C library."	^ self subclassResponsibility! !!SQLite3NativeError class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.692756-05:00'!subclassForNativeErrorCode: anInteger	^ self subclasses		detect: [ :subclass | subclass nativeErrorCode = anInteger ]! !!SQLite3NoLargeFileSupport class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.692821-05:00'!nativeErrorCode	^ SQLITE_NOLFS! !!SQLite3NoMemory class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.69288-05:00'!nativeErrorCode	^SQLITE_NOMEM! !!SQLite3NotADatabase class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.692937-05:00'!nativeErrorCode	^ SQLITE_NOTADB! !!SQLite3NotFound class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.692993-05:00'!nativeErrorCode	^ SQLITE_NOTFOUND! !!SQLite3OutOfRange class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.693049-05:00'!nativeErrorCode	^ SQLITE_RANGE! !!SQLite3Permission class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.693106-05:00'!nativeErrorCode	^ SQLITE_PERM! !!SQLite3Protocol class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.693161-05:00'!nativeErrorCode	^ SQLITE_PROTOCOL! !!SQLite3ReadOnly class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.693217-05:00'!nativeErrorCode	^ SQLITE_READONLY! !!SQLite3ReadOnlyCantLock class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.693275-05:00'!nativeErrorCode	^ SQLITE_READONLY_CANTLOCK! !!SQLite3ReadOnlyDBMoved class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.693335-05:00'!nativeErrorCode	^ SQLITE_READONLY_DBMOVED! !!SQLite3ReadOnlyRecovery class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.693392-05:00'!nativeErrorCode	^ SQLITE_READONLY_RECOVERY! !!SQLite3ReadOnlyRollback class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.69345-05:00'!nativeErrorCode	^ SQLITE_READONLY_ROLLBACK! !!SQLite3SchemaChanged class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.693509-05:00'!nativeErrorCode	^ SQLITE_SCHEMA! !!SQLite3TooBig class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.693565-05:00'!nativeErrorCode	^ SQLITE_TOOBIG! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '2025-09-26T14:41:25.693746-05:00'!at: aColumn putBoolean: aBoolean	^ self library		with: handle		at: aColumn		putInteger: (aBoolean ifTrue: [ 1 ] ifFalse: [ 0 ])"See http://www.sqlite.org/datatype3.html."! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '2025-09-26T14:41:25.693943-05:00'!at: aColumn putByteArray: anObject	| byteArray |	byteArray := self bindingAt: anObject ifAbsentPut: [ anObject ].	^ self library with: handle at: aColumn putBlob: byteArray! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '2025-09-26T14:41:25.694236-05:00'!at: aColumn putDate: aDate	| string |	string := self bindingAt: aDate ifAbsentPut: [		          String streamContents: [ :stream |			          BasicDatePrinter new printDate: aDate format: #(  ) on: stream ] ].	^ self library with: handle at: aColumn putText: string! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '2025-09-26T14:41:25.694503-05:00'!at: aColumn putDateTime: aDateTime	| string |	string := self		     bindingAt: aDateTime		     ifAbsentPut: [ String streamContents: [ :stream | aDateTime asDateAndTime printOn: stream ] ].	^ self library with: handle at: aColumn putText: string! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '2025-09-26T14:41:25.694719-05:00'!at: aColumn putFloat: aFloat	| f |	f := (aFloat isKindOf: Fraction)		ifTrue: [ aFloat asFloat ]		ifFalse: [ aFloat ].	^ self library with: handle at: aColumn putFloat: f! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '2025-09-26T14:41:25.694825-05:00'!at: aColumn putInteger: anInteger	^ self library with: handle at: aColumn putInteger: anInteger! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '2025-09-26T14:41:25.69493-05:00'!at: aColumn putNil: anObject	"Goofy interface note - anObject is ignored here."	"When used by SQLite3Connection, anObject will always be nil."	^ self library with: handle putNullAt: aColumn! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '2025-09-26T14:41:25.695126-05:00'!at: aColumn putObject: anObject	| blob |	blob := self bindingAt: anObject ifAbsentPut: [ FLSerializer serializeToByteArray: anObject ].	^ self library		  with: handle		  at: aColumn		  putBlob: blob! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '2025-09-26T14:41:25.695302-05:00'!at: aColumn putString: aString	| s |	s := self bindingAt: aString ifAbsentPut: [ aString ].	^ self library with: handle at: aColumn putText: s! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '2025-09-26T14:41:25.695548-05:00'!at: aColumn putTime: aTime	| string |	string := self		          bindingAt: aTime		          ifAbsentPut: [ String streamContents: [ :stream | aTime printOn: stream ] ].	^ self library with: handle at: aColumn putText: string! !!SQLite3PreparedStatement methodsFor: 'public' stamp: '2025-09-26T14:41:25.69586-05:00'!basicExecute: aBlock	| ret |	ret := self step.	(ret = SQLITE_DONE) " == SQLITE_DONE, meaning step should not be sent again."		ifTrue: [ aBlock value: self ]		ifFalse: [			[ ret = SQLITE_ROW ] whileTrue: [ " == SQLITE_ROW, meaning another row is available."				aBlock value: self.				ret := self step ]]! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '2025-09-26T14:41:25.695948-05:00'!bindParameterCount	^ self library bindParameterCount: handle! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '2025-09-26T14:41:25.69604-05:00'!bindParameterIndex: aName	^ self library bindParameterIndex: handle for: aName! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '2025-09-26T14:41:25.697118-05:00'!bindParameters: parameters	"A 'variable' or 'parameter' token specifies a placeholder in the expression for a value that is filled in at runtime using the sqlite3_bind() family of C/C++ interfaces. Parameters can take several forms:?NNN		A question mark followed by a number NNN holds a spot for the NNN-th parameter. NNN must be between 1 and SQLITE_MAX_VARIABLE_NUMBER.?		A question mark that is not followed by a number creates a parameter with a number one greater than the largest parameter number already assigned. If this means the parameter number is greater than SQLITE_MAX_VARIABLE_NUMBER, it is an error. This parameter format is provided for compatibility with other database engines. But because it is easy to miscount the question marks, the use of this parameter format is discouraged. Programmers are encouraged to use one of the symbolic formats below or the ?NNN format above instead.:AAAA		A colon followed by an identifier name holds a spot for a named parameter with the name :AAAA. Named parameters are also numbered. The number assigned is one greater than the largest parameter number already assigned. If this means the parameter would be assigned a number greater than SQLITE_MAX_VARIABLE_NUMBER, it is an error. To avoid confusion, it is best to avoid mixing named and numbered parameters.@AAAA		An 'at' sign works exactly like a colon, except that the name of the parameter created is @AAAA.$AAAA		A dollar-sign followed by an identifier name also holds a spot for a named parameter with the name $AAAA. The identifier name in this case can include one or more occurrences of '::' and a suffix enclosed in '(...)' containing any text at all. This syntax is the form of a variable name in the Tcl programming language. The presence of this syntax results from the fact that SQLite is really a Tcl extension that has escaped into the wild.Parameters that are not assigned values using sqlite3_bind() are treated as NULL. The sqlite3_bind_parameter_index() interface can be used to translate a symbolic parameter name into its equivalent numeric index."	(parameters isCollection and: [ parameters isString not ]) ifFalse: [		SQLite3AbstractError signal:			'Unable to execute SQL on instance of ' , parameters class asString ].	parameters keysAndValuesDo: [ :k :v |		| idx |		k isInteger			ifTrue: [ idx := k ]			ifFalse: [				idx := self bindParameterIndex: k.				idx = 0 ifTrue: [ idx := self bindParameterIndex: '@' , k ].				idx = 0 ifTrue: [ idx := self bindParameterIndex: ':' , k ].				idx = 0 ifTrue: [ idx := self bindParameterIndex: '$' , k ].				(idx = 0 and: [ k isAllDigits ]) ifTrue: [ idx := k asInteger ] ].		idx > 0 ifTrue: [			self perform: (self dataTypeForObject: v) with: idx with: v ] ]! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '2025-09-26T14:41:25.6973-05:00'!bindingAt: anObject ifAbsentPut: aBlock	^bindings at: anObject ifAbsentPut: aBlock! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '2025-09-26T14:41:25.697394-05:00'!booleanAt: aColumn	^self library booleanFrom: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '2025-09-26T14:41:25.69749-05:00'!byteArrayAt: aColumn	^ self library blobFrom: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'public - accessing' stamp: '2025-09-26T14:41:25.697589-05:00'!changes	^changes ifNil: [ changes := 0 ]! !!SQLite3PreparedStatement methodsFor: 'private' stamp: '2025-09-26T14:41:25.697927-05:00'!checkOk: aValue	"These are normal conditions."	aValue = SQLITE_OK ifTrue: [ ^aValue ].	"These are error conditions."	(aValue = SQLITE_BUSY)		ifTrue: [ connection signal: SQLite3Busy with: aValue ].	(aValue = SQLITE_MISUSE)		ifTrue: [ connection signal: SQLite3Misuse with: aValue ].	"Catch any error not specifically handled above."	connection signal: SQLite3AbstractError with: aValue! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '2025-09-26T14:41:25.698073-05:00'!clearBindings	| cleared |	cleared := self library clearBindings: handle on: connection handle.	bindings removeAll.	^cleared! !!SQLite3PreparedStatement methodsFor: 'public' stamp: '2025-09-26T14:41:25.698155-05:00'!columnCount	^self library columnCount: handle! !!SQLite3PreparedStatement methodsFor: 'public - accessing' stamp: '2025-09-26T14:41:25.698388-05:00'!columnNames	^ columnNames ifNil: [		  columnNames := (1 to: self columnCount) collect: [ :c | self nameOfColumn: c - 1 ].		  columnNames ]! !!SQLite3PreparedStatement methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.698461-05:00'!connection: anObject	connection := anObject! !!SQLite3PreparedStatement methodsFor: 'bindings' stamp: '2025-09-26T14:41:25.699035-05:00'!dataTypeForObject: anObject	anObject ifNil: [ ^ #at:putNil: ].	( anObject isKindOf: Boolean )		ifTrue: [ ^ #at:putBoolean: ].	( anObject isKindOf: Integer )		ifTrue: [ ^ #at:putInteger: ].	( self isFloatLike: anObject )		ifTrue: [ ^ #at:putFloat: ].	( anObject isKindOf: String )		ifTrue: [ ^ #at:putString: ].	( anObject isKindOf: ByteArray )		ifTrue: [ ^ #at:putByteArray: ].	( anObject isKindOf: DateAndTime )		ifTrue: [ ^ #at:putDateTime: ].	( anObject isKindOf: Time )		ifTrue: [ ^ #at:putTime: ].	( anObject isKindOf: Date )		ifTrue: [ ^ #at:putDate: ].	^ #at:putObject:! !!SQLite3PreparedStatement methodsFor: 'public - accessing' stamp: '2025-09-26T14:41:25.699133-05:00'!dataValuesAvailable	^ self library dataValuesAvailable: handle! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '2025-09-26T14:41:25.699607-05:00'!dateAt: aColumn	^ Date fromString: ( self stringAt: aColumn )! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '2025-09-26T14:41:25.699701-05:00'!dateTimeAt: aColumn	^ DateAndTime fromString: ( self stringAt: aColumn )! !!SQLite3PreparedStatement methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.699779-05:00'!dbHandle	^(self library dbHandle: handle)! !!SQLite3PreparedStatement methodsFor: 'operating' stamp: '2025-09-26T14:41:25.699966-05:00'!execute: parameters	| result |	self checkOk: self reset.	self clearBindings.	self bindParameters: parameters.	result := self step.	changes := connection changes.	^ SQLite3Cursor on: self! !!SQLite3PreparedStatement methodsFor: 'initialization' stamp: '2025-09-26T14:41:25.70014-05:00'!finalize	"Finalize the statement as required by the SQLite3 API. As per the API, the user is expected to finalize a statement after use.	Since executing a new statement without having finalized the previous one might cause SQLITE_BUSY errors, we can't rely on the garbage collector to execute the finalization, or we'll be exposed to non-deterministic behaviour."	handle		ifNotNil:			[ "Remove the statement object from its finalization registry. This should happen before the actual finalization to avoid finalizing the statement twice, which might result in 'undefined and undesirable behavior such as segfaults and heap corruption' as per the SQLite3 API"			handle manualRelease.			connection finalize: handle.			handle := nil ].	^ 0! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '2025-09-26T14:41:25.700258-05:00'!floatAt: aColumn	^self library floatFrom: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.70033-05:00'!handle	^ handle! !!SQLite3PreparedStatement methodsFor: 'initialization' stamp: '2025-09-26T14:41:25.700456-05:00'!initialize	super initialize.	bindings := IdentityDictionary new.	handle := SQLite3StatementExternalObject new.	handle autoRelease! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '2025-09-26T14:41:25.700713-05:00'!integerAt: aColumn	^self library integerFrom: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'private - testing' stamp: '2025-09-26T14:41:25.700862-05:00'!isFloatLike: anObject	^ (anObject isKindOf: Float) or: [ anObject isKindOf: Fraction ]! !!SQLite3PreparedStatement methodsFor: 'public - accessing' stamp: '2025-09-26T14:41:25.700943-05:00'!isReadOnly	^self library statementReadOnly: handle! !!SQLite3PreparedStatement methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.70218-05:00'!library	^SQLite3Library current! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '2025-09-26T14:41:25.702272-05:00'!nameOfColumn: aColumn	^ self library nameFor: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '2025-09-26T14:41:25.702336-05:00'!nilAt: aColumn	^ nil! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '2025-09-26T14:41:25.702442-05:00'!objectAt: aColumn	^ FLMaterializer materializeFromByteArray: (self library blobFrom: handle at: aColumn)! !!SQLite3PreparedStatement methodsFor: 'public' stamp: '2025-09-26T14:41:25.70268-05:00'!prepare: anSQLText	self library prepare: handle on: connection handle with: anSQLText! !!SQLite3PreparedStatement methodsFor: 'public' stamp: '2025-09-26T14:41:25.70275-05:00'!reset	^connection reset: self! !!SQLite3PreparedStatement methodsFor: 'operating' stamp: '2025-09-26T14:41:25.70295-05:00'!sqlText	^ self library sqlText: handle! !!SQLite3PreparedStatement methodsFor: 'public' stamp: '2025-09-26T14:41:25.703042-05:00'!step	^ self stepOk: (self library step: handle)! !!SQLite3PreparedStatement methodsFor: 'private' stamp: '2025-09-26T14:41:25.703658-05:00'!stepOk: aValue	"These are normal conditions."	(aValue = SQLITE_ROW or: [aValue = SQLITE_DONE]) ifTrue: [		changes := connection changes.		^aValue  ].	"These are error conditions."	(aValue = SQLITE_BUSY)		ifTrue: [ connection signal: SQLite3Busy with: aValue ].	(aValue = SQLITE_MISUSE)		ifTrue: [ connection signal: SQLite3Misuse with: aValue ].	(aValue = SQLITE_CONSTRAINT)		ifTrue:  [ connection signal: SQLite3ConstraintViolation with: aValue].	"Catch any error not specifically handled above."	connection signal: SQLite3AbstractError with: aValue! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '2025-09-26T14:41:25.703781-05:00'!stringAt: aColumn	"Answer the string from the specified column"	"#stringFrom:at: is supplied in a version specific package.	If there are no implementers the appropriate package needs to be loaded. :-)"	^ self library stringFrom: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '2025-09-26T14:41:25.703883-05:00'!timeAt: aColumn	^ Time fromString: ( self stringAt: aColumn )! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '2025-09-26T14:41:25.703978-05:00'!timestampAt: aColumn	^ DateAndTime fromString: ( self stringAt: aColumn )! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '2025-09-26T14:41:25.704067-05:00'!typeOfColumn: aColumn	^ self library typeFor: handle at: aColumn! !!SQLite3PreparedStatement methodsFor: 'fetching' stamp: '2025-09-26T14:41:25.705365-05:00'!valueOfColumn: aColumn	^ self perform: (self typeOfColumn: aColumn) with: aColumn! !!SQLite3DoneResult class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.705435-05:00'!nativeResultCode	^ SQLITE_DONE! !!SQLite3OKResult class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.705496-05:00'!nativeResultCode	^ SQLITE_OK! !!SQLite3Result class methodsFor: 'accessing' stamp: '2025-09-26T14:41:25.705619-05:00'!forNativeResultCode: anInteger	^ (self subclassForNativeResultCode: anInteger) new! !!SQLite3Result class methodsFor: 'testing' stamp: '2025-09-26T14:41:25.705702-05:00'!isAbstract	^self name = #SQLite3Result! !!SQLite3Result class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.705767-05:00'!nativeResultCode	^ self subclassResponsibility! !!SQLite3Result class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.705927-05:00'!subclassForNativeResultCode: anInteger	^ self subclasses		detect: [ :subclass | subclass nativeResultCode = anInteger ]! !!SQLite3RowResult class methodsFor: 'private - accessing' stamp: '2025-09-26T14:41:25.70599-05:00'!nativeResultCode	^ SQLITE_ROW! !"SQLite3-Core"!!SQLite3Benchmark commentStamp: '' prior: 0!Benchmarking harness.!!ManifestSQLite3CoreBenchmarks commentStamp: '' prior: 0!Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!SQLite3Benchmark methodsFor: 'running' stamp: '2025-09-26T14:41:26.066769-05:00'!basicExecute: anSQLText times: aCount	db beginTransaction.	1 to: aCount do: [ :i |		db basicExecute: anSQLText ].	db commitTransaction! !!SQLite3Benchmark methodsFor: 'connecting-disconnecting' stamp: '2025-09-26T14:41:26.067396-05:00'!connectBy: aConnectionClass	db := aConnectionClass openOn: ':memory:'! !!SQLite3Benchmark methodsFor: 'connecting-disconnecting' stamp: '2025-09-26T14:41:26.067713-05:00'!disconnect	db close! !!SQLite3Benchmark methodsFor: 'running' stamp: '2025-09-26T14:41:26.068275-05:00'!execute: anSQLText times: aCount bindingsBlock: bindingsBlock	db beginTransaction.	1 to: aCount do: [ :i |		db execute: anSQLText with: (bindingsBlock value: i) ].	db commitTransaction! !!SQLite3Benchmark methodsFor: 'running' stamp: '2025-09-26T14:41:26.068619-05:00'!finalizeStatement	stmt ifNotNil: [ stmt finalize ]! !!SQLite3Benchmark methodsFor: 'running' stamp: '2025-09-26T14:41:26.069128-05:00'!prepStep: anSQLText times: aCount bindingsBlock: bindingsBlock	stmt := db prepare: anSQLText.	db beginTransaction.	1 to: aCount do: [ :i |		bindingsBlock value: stmt value: i.		stmt step; clearBindings; reset ].	db commitTransaction! !!SQLite3Benchmark methodsFor: 'running' stamp: '2025-09-26T14:41:26.069288-05:00'!runBlock: aBlock	db beginTransaction.	aBlock value: db.	db commitTransaction! !!ManifestSQLite3CoreBenchmarks class methodsFor: 'code coverage' stamp: '2025-09-26T14:41:26.069505-05:00'!classNamesNotUnderTest	^ #( ManifestSQLite3CoreBenchmarks )! !!ManifestSQLite3CoreBenchmarks class methodsFor: 'code-critics' stamp: '2025-09-26T14:41:26.069767-05:00'!ruleClassNotReferencedRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#SQLite3Benchmark)) #'2022-05-10T08:25:40.035+02:00') )! !"SQLite3-Core-Benchmarks"!!SQLite3Library methodsFor: '*SQLite3-Pharo9' stamp: '2025-09-26T14:41:26.236063-05:00'!stringFrom: aStatement at: aColumn	^ self apiColumnText: aStatement atColumn: aColumn! !"SQLite3-Pharo9"!!Random methodsFor: '*SQLite3-Pharo10' stamp: '2025-09-26T14:41:26.36864-05:00'!nextInt: anInteger	^ self nextInteger: anInteger! !"SQLite3-Pharo10"!!SQLite3BaseConnectionTest commentStamp: '' prior: 0!Unit tests for SQLiteBaseConnection!!SQLite3ConnectionTest commentStamp: '' prior: 0!Unit tests for SQLiteConnection!!SQLite3DatabaseTest commentStamp: '' prior: 0!A test class for `SQLite3Database`!!SQLite3RowTest commentStamp: '' prior: 0!Unit tests for SQLite3Row!!SQLite3TableTest commentStamp: '' prior: 0!A test class for `SQLite3Table`!!ManifestSQLite3CoreTests commentStamp: '' prior: 0!Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!SQLite3BaseConnectionTest methodsFor: 'tests - DEACTIVATED' stamp: '2025-09-26T14:41:26.535379-05:00'!deactivatedTestTracing	| sql callback expected actual  |	(SystemVersion current major >= 7) ifTrue: [ self skip ].	"This test invokes a callback from SQLite to Pharo. It works in Pharo 6 and earlier but not in Pharo 7."	sql := #('create table if not exists x (xk integer primary key, iv integer, tv text)'			'insert into x values (NULL, 1, ''two'')'			'drop table x').	expected := String streamContents: [ :s |		s nextPutAll: sql first; cr;			nextPutAll: sql second; cr;			nextPutAll: sql third; cr ].	actual := WriteStream on: String new.	callback := FFICallback						signature: #(void (ExternalAddress appData, String sqlText))						block: [ :appdata :sqltext |							"We ignore appdata in this test, because we're passing a null pointer in."							actual nextPutAll: sqltext; cr ].	"The null pointer appears as appdata in the callback."	db traceUsing: callback with: ExternalAddress new.	res := db basicExecute: sql first.	self assert: res equals: 0.	res := db basicExecute: sql second.	self assert: res equals: 0.	res := db basicExecute: sql third.	self assert: res equals: 0.	self assert: actual contents equals: expected! !!SQLite3BaseConnectionTest methodsFor: 'private' stamp: '2025-09-26T14:41:26.536423-05:00'!executeInDB: anSQLText	| result |	result := db basicExecute: anSQLText.	self assert: result equals: 0! !!SQLite3BaseConnectionTest methodsFor: 'utilities' stamp: '2025-09-26T14:41:26.537359-05:00'!getTempPath	| env |	env := Smalltalk os environment.	^ Smalltalk os isWindows		  ifTrue: [ "See https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-gettemppath2a"			  (env				   at: 'TMP'				   ifAbsent: [ env at: 'TEMP' ifAbsent: [ env at: 'USERPROFILE' ] ])			  , '\' ]		  ifFalse: [ "See https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html"			(env at: 'TMPDIR' ifAbsent: ['/tmp']), '/' ]! !!SQLite3BaseConnectionTest methodsFor: 'utilities' stamp: '2025-09-26T14:41:26.537644-05:00'!invalidFileNameOnCurrentOperatingSystem	^Smalltalk os isWindows		ifTrue: [ '/&*no' ]		ifFalse: [ '/nosuchfile' ]! !!SQLite3BaseConnectionTest methodsFor: 'utilities' stamp: '2025-09-26T14:41:26.537888-05:00'!newUniqueFileName	^ self getTempPath , UUID new asString! !!SQLite3BaseConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.53849-05:00'!noTestColumnNamesBobbyGo	"In this test, Bobby Tables strikes naive SQL string construction."	"20190302, pierce: #basicExecute: uses prepare/step/finalize internally and is no longer susceptible to injection attacks. "	| tables bobby |	res := db basicExecute: 'create table x (xk integer, xv integer);'.	self assert: res equals: 0.	res := db basicExecute:		       'create table students (sk integer, sname varchar);'.	self assert: res equals: 0.	tables := db tableNames.	self assert: tables size equals: 2.	self assert: tables first equals: 'x'.	self assert: tables second equals: 'students'.	bobby := 'x); drop table students; --'.	res := db basicExecute: 'pragma table_info(' , bobby , ')'.	self assert: res equals: 0.	tables := db tableNames.	self assert: tables size equals: 1.	self assert: tables first equals: 'x'! !!SQLite3BaseConnectionTest methodsFor: 'running' stamp: '2025-09-26T14:41:26.53868-05:00'!setUp	super setUp.	db := SQLite3BaseConnection on: ':memory:'.	db open! !!SQLite3BaseConnectionTest methodsFor: 'running' stamp: '2025-09-26T14:41:26.538951-05:00'!tearDown	[ db close ] on: SQLite3Misuse do: [ ].	super tearDown! !!SQLite3BaseConnectionTest methodsFor: 'tests - connections' stamp: '2025-09-26T14:41:26.539188-05:00'!testBadOpen	| newConnection |	newConnection := SQLite3BaseConnection on: self invalidFileNameOnCurrentOperatingSystem.	self should: [ newConnection open ] raise: SQLite3CantOpen.	self deny: newConnection isOpen! !!SQLite3BaseConnectionTest methodsFor: 'tests - execution' stamp: '2025-09-26T14:41:26.539295-05:00'!testBasicExecuteOk	self executeInDB: 'create table x (xk integer, xv integer);'.	self executeInDB: 'drop table x;'! !!SQLite3BaseConnectionTest methodsFor: 'tests - execution' stamp: '2025-09-26T14:41:26.539446-05:00'!testBasicExecuteSyntaxError	self should: [ db basicExecute: 'create table,;' ]		raise: SQLite3AbstractError! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '2025-09-26T14:41:26.539723-05:00'!testBooleanColumnTypeMismatch	self executeInDB: 'create table x (xk integer primary key, xv notboolean);'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row | self should: [ row booleanAt: 0 ] raise: SQLite3AbstractError ] ]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '2025-09-26T14:41:26.540121-05:00'!testBooleanObject	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putObject: true.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row objectAt: 0.			self assert: value equals: true			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '2025-09-26T14:41:26.540482-05:00'!testBooleanWriteIntegerOneThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putInteger: 1.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value equals: true			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '2025-09-26T14:41:26.54086-05:00'!testBooleanWriteIntegerTwoThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putInteger: 2.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row | self should: [ row booleanAt: 0 ] raise: SQLite3AbstractError ] ]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '2025-09-26T14:41:26.541231-05:00'!testBooleanWriteIntegerZeroThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putInteger: 0.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value equals: false			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '2025-09-26T14:41:26.541592-05:00'!testBooleanWriteNilThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putNil: nil.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value isNil			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '2025-09-26T14:41:26.54193-05:00'!testBooleanWriteSQLNullThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, NULL)' do: [ :statement | statement step ].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value isNil			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '2025-09-26T14:41:26.542281-05:00'!testBooleanWriteStringFalseThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putString: 'false'.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value equals: false			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '2025-09-26T14:41:26.54263-05:00'!testBooleanWriteStringTrueThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putString: 'true'.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value equals: true			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '2025-09-26T14:41:26.543002-05:00'!testBooleanWriteStringTwoThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putString: '2'.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row | self should: [ row booleanAt: 0 ] raise: SQLite3AbstractError ] ]! !!SQLite3BaseConnectionTest methodsFor: 'tests - writing' stamp: '2025-09-26T14:41:26.543348-05:00'!testBooleanWriteThenRead	self executeInDB: 'create table x (xk integer primary key, xv boolean);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putBoolean: true.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row booleanAt: 0.			self assert: value equals: true			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - connections' stamp: '2025-09-26T14:41:26.543611-05:00'!testCloseFile	| fileName newConnection |	fileName := self newUniqueFileName.	newConnection := SQLite3BaseConnection on: fileName.	newConnection		open;		close.	newConnection := nil.	Smalltalk garbageCollect.	self		shouldnt: [ File deleteFile: fileName ]		raise: CannotDeleteFileException! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '2025-09-26T14:41:26.543847-05:00'!testColumnNames	| columns |	self executeInDB: 'create table x (xk integer, xv integer);'.	columns := db columnNamesFor: 'x'.	self assert: columns size equals: 2.	self assert: columns first equals: 'xk'.	self assert: columns second equals: 'xv'! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '2025-09-26T14:41:26.544218-05:00'!testColumnNamesBobbyStop	"In this test, Bobby Tables strikes again, but fails, because #columnNamesFor: uses parameter binding."	| columns tables |	self executeInDB: 'create table x (xk integer, xv integer);'.	self executeInDB: 'create table students (sk integer, sname varchar);'.	tables := db tableNames.	self assert: tables size equals: 2.	self assert: tables first equals: 'x'.	self assert: tables second equals: 'students'.	columns := db columnNamesFor: 'x; drop table students; --'.	self assert: columns isNil.	tables := db tableNames.	self assert: tables size equals: 2.	self assert: tables first equals: 'x'.	self assert: tables second equals: 'students'! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '2025-09-26T14:41:26.544782-05:00'!testColumnNamesForNoSuchTableWithSpaces	| columns |	self executeInDB: 'create table x (xk integer, xv integer);'.	columns := db columnNamesFor: 'no such table with spaces'.	self assert: columns isNil! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '2025-09-26T14:41:26.544971-05:00'!testColumnNamesForTableWithSpaces	| columns |	self executeInDB: 'create table [table name with spaces] (xk integer, xv integer);'.	columns := db columnNamesFor: 'table name with spaces'.	self assert: columns size equals: 2.	self assert: columns first equals: 'xk'.	self assert: columns second equals: 'xv'! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '2025-09-26T14:41:26.5451-05:00'!testColumnNamesNoSuchTable	| columns |	self executeInDB: 'create table x (xk integer, xv integer);'.	columns := db columnNamesFor: 'y'.	self assert: columns isNil! !!SQLite3BaseConnectionTest methodsFor: 'tests - connections' stamp: '2025-09-26T14:41:26.545261-05:00'!testConstraintViolation	self		executeInDB: 'create table x (value integer primary key);';		executeInDB: 'insert into x values(1);'.	self should: [ db basicExecute: 'insert into x values(1);' ] raise: SQLite3ConstraintViolation! !!SQLite3BaseConnectionTest methodsFor: 'tests - execution' stamp: '2025-09-26T14:41:26.546875-05:00'!testDataValuesAvailable	self executeInDB: 'create table x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'insert into x values (NULL, 1, "duh");'.	self		withPreparedStatement: 'select * from x'		do: [ :statement |		statement basicExecute: [ :row | self assert: row dataValuesAvailable equals: 3 ] ]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '2025-09-26T14:41:26.547345-05:00'!testDate	| data |	data := Date year: 2015 month: 4 day: 1.	self executeInDB: 'create table x (xv date);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (?)' do: [ :statement |		statement at: 1 putDateTime: data.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row dateTimeAt: 0.			self				assert: value year equals: 2015;				assert: value month equals: 4;				assert: value dayOfMonth equals: 1			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '2025-09-26T14:41:26.547884-05:00'!testDateAndTime	| data |	data := DateAndTime year: 2015 month: 4 day: 1.	self executeInDB: 'create table x (xv datetime);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (?)' do: [ :statement |		statement at: 1 putDateTime: data.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row dateTimeAt: 0.			self				assert: value year equals: 2015;				assert: value month equals: 4;				assert: value dayOfMonth equals: 1;				assert: value hours equals: 0;				assert: value minutes equals: 0;				assert: value seconds equals: 0			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '2025-09-26T14:41:26.548132-05:00'!testDeclaredColumnTypes	| columns |	self executeInDB: 'create table x (xk integer, xv blob, xb boolean);'.	columns := db declaredColumnTypesFor: 'x'.	self assert: columns size equals: 3.	self assert: columns first equals: 'INTEGER'.	self assert: columns second equals: 'BLOB'.	self assert: columns third equals: 'boolean'! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '2025-09-26T14:41:26.548266-05:00'!testDeclaredColumnTypesForNoSuchTable	| columns |	self executeInDB: 'create table x (xk integer, xv integer);'.	columns := db declaredColumnTypesFor: 'y'.	self assert: columns isNil! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '2025-09-26T14:41:26.548392-05:00'!testDeclaredColumnTypesForNoSuchTableWithSpaces	| columns |	self executeInDB: 'create table x (xk integer, xv integer);'.	columns := db declaredColumnTypesFor: 'no such table with spaces'.	self assert: columns isNil! !!SQLite3BaseConnectionTest methodsFor: 'tests - columns' stamp: '2025-09-26T14:41:26.548605-05:00'!testDeclaredColumnTypesForTableWithSpaces	| columns |	self executeInDB: 'create table [table name with spaces] (xk INTEGER, xv BLOB, xb BOOLEAN);'.	columns := db declaredColumnTypesFor: 'table name with spaces'.	self assert: columns size equals: 3.	self assert: columns first equals: 'INTEGER'.	self assert: columns second equals: 'BLOB'.	self assert: columns third equals: 'BOOLEAN'! !!SQLite3BaseConnectionTest methodsFor: 'tests - multilingual' stamp: '2025-09-26T14:41:26.549042-05:00'!testDefaultMultilingualStrings	self executeInDB:		'create table x (xk integer primary key, xm1 text default '''', xm2 text default '''');'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x (xk) values (NULL)' do: [ :statement | statement step ].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xm1, xm2 from x order by xk' do: [ :statement |		statement basicExecute: [ :row |			self assert: ( row stringAt: 0 ) equals: ''.			self assert: ( row stringAt: 1 ) equals: ''			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - connections' stamp: '2025-09-26T14:41:26.549296-05:00'!testDoubleClose	db close.	[ db close ] on: SQLite3Misuse do: [ ]	"#tearDown will close the db again, and is similarly guarded."! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '2025-09-26T14:41:26.549614-05:00'!testFloat	self executeInDB: 'create table x (xk integer primary key, xv real);'.	self executeInDB: 'insert into x values (NULL, 1.141);'.	self withPreparedStatement: 'select * from x' do: [ :statement |		statement basicExecute: [ :row |			self assert: ( row nameOfColumn: 1 ) equals: 'xv'.			self assert: ( row floatAt: 1 ) equals: 1.141			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '2025-09-26T14:41:26.549974-05:00'!testInteger	"The large integer comes from Glorp's testInt8."	self executeInDB: 'create table x (xk integer primary key, xv integer);'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putInteger: 3212321555.		statement step		].	self withPreparedStatement: 'select * from x' do: [ :statement |		statement basicExecute: [ :row |			self assert: ( row nameOfColumn: 1 ) equals: 'xv'.			self assert: ( row integerAt: 1 ) equals: 3212321555			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.55007-05:00'!testIsAbstract	self assert: SQLite3BaseConnection isAbstract! !!SQLite3BaseConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.550167-05:00'!testIsThreadsafe	self assert: (SQLite3BaseConnection isThreadsafe isKindOf: Boolean)! !!SQLite3BaseConnectionTest methodsFor: 'tests - multilingual' stamp: '2025-09-26T14:41:26.550898-05:00'!testMultilingualStrings	| data index |	data := OrderedCollection with: 'English' with: '' with: '' , ''.	self executeInDB: 'create table x (xk integer primary key, xv varchar);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		data do: [ :ea |			statement at: 1 putString: ea.			statement				step;				clearBindings;				reset			]		].	self executeInDB: 'commit'.	index := 1.	self withPreparedStatement: 'select xv from x order by xk asc' do: [ :statement |		statement basicExecute: [ :row |			self assert: ( row stringAt: 0 ) equals: ( data at: index ).			index := index + 1			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - multilingual' stamp: '2025-09-26T14:41:26.551301-05:00'!testMultilingualTableName	self executeInDB: 'create table  (xk integer primary key, xm1 text default '''');'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into  (xk) values (NULL)' do: [ :statement | statement step ].	self executeInDB: 'commit'.	self		withPreparedStatement: 'select xm1 from  order by xk'		do: [ :statement |		statement basicExecute: [ :row | self assert: ( row stringAt: 0 ) equals: '' ] ]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '2025-09-26T14:41:26.551848-05:00'!testObjectBlob	| data |	data := OrderedCollection with: 1 with: 'two' with: 3.3.	self		executeInDB: 'create table x (xk integer primary key, xv blob);';		executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putObject: data.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row objectAt: 0.			self				assert: value size equals: 3;				assert: value first equals: 1;				assert: value second equals: 'two';				assert: value third equals: 3.3			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.553267-05:00'!testPrepareStep	self executeInDB: 'create table x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?, ?)' do: [ :statement |		self assert: statement sqlText equals: 'insert into x values (NULL, ?, ?)'.		1 to: 10 do: [ :x |			statement at: 1 putInteger: x * x.			statement at: 2 putString: ( '<1p> * <1p>' expandMacrosWith: x ).			statement step.			statement clearBindings.			statement reset			]		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select * from x' do: [ :statement |		| i |		self assert: statement sqlText equals: 'select * from x'.		statement basicExecute: [ :row |			i := row integerAt: 0.			self assert: ( row integerAt: 1 ) equals: i * i.			self assert: ( row stringAt: 2 ) equals: ( '<1p> * <1p>' expandMacrosWith: i )			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.554523-05:00'!testPrepareStepSelective	| i count |	self executeInDB: 'create table x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (NULL, ?, ?)' do: [ :statement |		self assert: statement sqlText equals: 'insert into x values (NULL, ?, ?)'.		1 to: 10 do: [ :x |			statement				at: 1 putInteger: x * x;				at: 2 putString: x asString , ' * ' , x asString;				step;				clearBindings;				reset			]		].	self executeInDB: 'commit'.	count := 0.	self withPreparedStatement: 'select * from x where iv < ?' do: [ :statement |		self assert: statement sqlText equals: 'select * from x where iv < ?'.		statement at: 1 putInteger: 27.		statement basicExecute: [ :row |			count := count + 1.			i := row integerAt: 0.			self assert: ( row integerAt: 1 ) equals: i * i.			self assert: ( row stringAt: 2 ) equals: i asString , ' * ' , i asString			]		].	self assert: count equals: 5! !!SQLite3BaseConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.555094-05:00'!testResultSetColumnIntrospection	self executeInDB: 'create table x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'insert into x values (NULL, 1, "duh");'.	self withPreparedStatement: 'select * from x' do: [ :statement |		statement basicExecute: [ :row |			self assert: ( row nameOfColumn: 0 ) equals: 'xk'.			self assert: ( row valueOfColumn: 0 ) equals: 1.			self assert: ( row nameOfColumn: 1 ) equals: 'iv'.			self assert: ( row valueOfColumn: 1 ) equals: 1.			self assert: ( row nameOfColumn: 2 ) equals: 'tv'.			self assert: ( row valueOfColumn: 2 ) equals: 'duh'			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '2025-09-26T14:41:26.555623-05:00'!testScaledDecimal	"This test is a simplified version of GlorpNumericTest>>tesNumeric."	| number float |	number := Number readFrom: '12345678s'.	float := number asFloat.	self executeInDB: 'create table x (xk integer primary key, xv real);'.	self withPreparedStatement: 'insert into x values (NULL, ?)' do: [ :statement |		statement at: 1 putFloat: number.		statement step		].	self withPreparedStatement: 'select * from x' do: [ :statement |		statement basicExecute: [ :row |			self				assert: ( row nameOfColumn: 1 ) equals: 'xv';				assert: ( row floatAt: 1 ) equals: float			]		]! !!SQLite3BaseConnectionTest methodsFor: 'tests - tables' stamp: '2025-09-26T14:41:26.556491-05:00'!testTableNames	| tables |	self executeInDB: 'create table x (xk integer, xv integer);'.	tables := db tableNames.	self assert: tables size equals: 1.	self assert: tables first equals: 'x'! !!SQLite3BaseConnectionTest methodsFor: 'tests - tables' stamp: '2025-09-26T14:41:26.556622-05:00'!testTableNamesOfEmptyDatabase	| tables |	tables := db tableNames.	self assert: tables isEmpty! !!SQLite3BaseConnectionTest methodsFor: 'tests - types' stamp: '2025-09-26T14:41:26.557131-05:00'!testTime	| data |	data := Time noon.	self		executeInDB: 'create table x (xv time);';		executeInDB: 'begin'.	self withPreparedStatement: 'insert into x values (?)' do: [ :statement |		statement at: 1 putTime: data.		statement step		].	self executeInDB: 'commit'.	self withPreparedStatement: 'select xv from x' do: [ :statement |		statement basicExecute: [ :row |			| value |			value := row timeAt: 0.			self				assert: value hour equals: data hour;				assert: value minute equals: data minute;				assert: value second equals: data second			]		]! !!SQLite3BaseConnectionTest methodsFor: 'private' stamp: '2025-09-26T14:41:26.557393-05:00'!withPreparedStatement: anSQLText do: aBlock	| statement |	statement := db prepare: anSQLText.	[ aBlock value: statement ] ensure: [ statement finalize ]! !!SQLite3ColumnTest methodsFor: 'running' stamp: '2025-09-26T14:41:26.557646-05:00'!setUp	super setUp.	db := SQLite3Database memory.	db connection open.	db connection execute: self tableCreationScript.	table := db tables first.	firstColumn := table columns first.	secondColumn := table columns second! !!SQLite3ColumnTest methodsFor: 'accessing' stamp: '2025-09-26T14:41:26.557743-05:00'!tableCreationScript	^'CREATE TABLE "SAMPLE"(    [ID] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,    [NAME] NVARCHAR(120))'! !!SQLite3ColumnTest methodsFor: 'running' stamp: '2025-09-26T14:41:26.557845-05:00'!tearDown	db connection close.	db := nil.	super tearDown! !!SQLite3ColumnTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.557953-05:00'!testHasNotNullConstraint	self assert: firstColumn hasNotNullConstraint.	self deny: secondColumn hasNotNullConstraint! !!SQLite3ColumnTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.558061-05:00'!testIndex	self assert: firstColumn index equals: 0.	self assert: secondColumn index equals: 1! !!SQLite3ColumnTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.55817-05:00'!testInitialization	| instance |	instance := SQLite3Column new.	self deny: instance hasNotNullConstraint! !!SQLite3ColumnTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.558276-05:00'!testName	self assert: firstColumn name equals: 'ID'.	self assert: secondColumn name equals: 'NAME'! !!SQLite3ColumnTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.558382-05:00'!testPrintString	self assert: firstColumn printString equals: 'a SQLite3Column("ID")'.	self assert: secondColumn printString equals: 'a SQLite3Column("NAME")'! !!SQLite3ColumnTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.558488-05:00'!testType	self assert: firstColumn type equals: 'INTEGER'.	self assert: secondColumn type equals: 'NVARCHAR(120)'! !!SQLite3ConnectionTest methodsFor: 'private' stamp: '2025-09-26T14:41:26.558611-05:00'!executeInDB: anSQLText	| result |	result := db basicExecute: anSQLText.	self assert: result equals: 0! !!SQLite3ConnectionTest methodsFor: 'utilities' stamp: '2025-09-26T14:41:26.559196-05:00'!populateRowsInto: tableName of: database	| rand rows schema insert rn rt |	 rand := Random new.	rows := rand nextInt: 100.	schema := 'create table ', tableName, ' (rk integer primary key, rn integer, rt text);'.	insert := 'insert into ', tableName, ' values (?, ?, ?)'.	database basicExecute: 'begin'.	database	basicExecute: schema.	1 to: rows do: [ :i |		rn := i * (rand nextInt: 10).		rt := i asString, '-ZZZ'.		database execute: insert with: (Array with: i with: rn with: rt) ].	database basicExecute: 'commit'.	^ rows! !!SQLite3ConnectionTest methodsFor: 'running' stamp: '2025-09-26T14:41:26.559319-05:00'!setUp	super setUp.	db := SQLite3Connection memory.	db open! !!SQLite3ConnectionTest methodsFor: 'running' stamp: '2025-09-26T14:41:26.559658-05:00'!tearDown	[ db close ] on: SQLite3Misuse do: [ ].	[ target ifNotNil:[target close] ] on: SQLite3Misuse do: [ ].	super tearDown! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.560012-05:00'!testBackup	| row backup |	target := SQLite3Connection memory.	target open.	self populateRowsInto: 'junk' of: db.	backup := db backupTo: target.	backup open; step; finish.	row := (target execute: 'select * from junk where rt = ''1-ZZZ''') onlyRow.	self assert: (row at: 'rk') equals: 1.	self assert: (row at: 'rt') equals: '1-ZZZ'.	self assert: (row at: 1) equals: 1.	self assert: (row at: 3) equals: '1-ZZZ'! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.560202-05:00'!testChanges	| count |	count := self populateRowsInto: 'stuff' of: db.	self assert: db changes equals: 1.	(db basicExecute: 'delete from stuff').	self assert: db changes equals: count! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.561145-05:00'!testDo	| arrayResults dictResults |	self executeInDB:		'create table if not exists x (id integer , tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	db basicExecute: 'insert into x values (10, "abc")'.	db basicExecute: 'insert into x values (20, "def")'.	db basicExecute: 'insert into x values (30, "ghi")'.	res := db commitTransaction.	self assert: res equals: 0.	arrayResults := OrderedCollection new.	dictResults := OrderedCollection new.	rs := db execute: 'select * from x;'.	rs do: [ :row |		arrayResults add: row asArray.		dictResults add: row asDictionary ].	rs close.	self deny: arrayResults isEmpty.	self assert: arrayResults size equals: 3.	self assert: arrayResults first equals: #( 10 'abc' ).	self assert: arrayResults second equals: #( 20 'def' ).	self assert: arrayResults third equals: #( 30 'ghi' ).	self deny: dictResults isEmpty.	self assert: dictResults size equals: 3.	self assert: dictResults first equals: { ('id' -> 10). ('tv' -> 'abc') } asDictionary.	self assert: dictResults second equals: { ('id' -> 20). ('tv' -> 'def') } asDictionary.	self assert: dictResults third equals: { ('id' -> 30). ('tv' -> 'ghi') } asDictionary! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.561432-05:00'!testExactlyOneRow	| row |	self populateRowsInto: 'junk' of: db.	row := (db execute: 'select * from junk where rt = ''1-ZZZ''') onlyRow.	self assert: (row at: 'rk') equals: 1.	self assert: (row at: 'rt') equals: '1-ZZZ'.	self assert: (row at: 1) equals: 1.	self assert: (row at: 3) equals: '1-ZZZ'! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.561579-05:00'!testExactlyOneRowGotNone	| row |	self populateRowsInto: 'junk' of: db.	row := (db execute: 'select * from junk where rt = ''0-ZZZ''') onlyRow.	self assert: row isNil! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.561718-05:00'!testExecuteDelete	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	rs := db execute: 'delete from x;'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.561857-05:00'!testExecuteDrop	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	rs := db execute: 'drop table x;'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.562109-05:00'!testExecuteNoResult	rs := db execute: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self assert: (rs next isNil).	rs close.	rs := db execute: 'delete from x;'.	self assert: (rs next isNil).	rs close.	rs := db execute: 'drop table x;'.	self assert: (rs next isNil).	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.562649-05:00'!testExecuteValueInsertArray	| rd |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 1 value: 'two'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rd := ( db execute: 'select * from x' ) rows first.	self assert: ( rd at: 'xk' ) equals: 1.	self assert: ( rd at: 'iv' ) equals: 1.	self assert: ( rd at: 'tv' ) equals: 'two'.	self assert: ( rd at: 1 ) equals: 1.	self assert: ( rd at: 2 ) equals: 1.	self assert: ( rd at: 3 ) equals: 'two'.	self assert: rd first equals: 1.	self assert: rd last equals: 'two'! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.564216-05:00'!testExecuteValueInsertBooleanNilThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, bv boolean);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?)' value: nil.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'bv' ) equals: nil.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: nil.	self assert: row first equals: 1.	self assert: row last equals: nil.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.564759-05:00'!testExecuteValueInsertBooleanThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, bv boolean);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?)' value: true.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'bv' ) equals: true.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: true.	self assert: row first equals: 1.	self assert: row last equals: true.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.565286-05:00'!testExecuteValueInsertChanges	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 1 value: 'two'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	self assert: db changes equals: 1.	self assert: db totalChanges equals: 1.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 2 value: 'too'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	self assert: db changes equals: 1.	self assert: db totalChanges equals: 2! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.56589-05:00'!testExecuteValueInsertThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 1 value: 'two'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'iv' ) equals: 1.	self assert: ( row at: 'tv' ) equals: 'two'.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: 1.	self assert: ( row at: 3 ) equals: 'two'.	self assert: row first equals: 1.	self assert: row last equals: 'two'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.566799-05:00'!testExecuteValueInsertThenSelect2	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 1 value: 'two'.	self assert: rs next isNil.	rs close.	rs := db execute: 'insert into x values (NULL, ?, ?)' value: 2 value: 'three'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'iv' ) equals: 1.	self assert: ( row at: 'tv' ) equals: 'two'.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: 1.	self assert: ( row at: 3 ) equals: 'two'.	self assert: row first equals: 1.	self assert: row last equals: 'two'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 2.	self assert: ( row at: 'iv' ) equals: 2.	self assert: ( row at: 'tv' ) equals: 'three'.	self assert: ( row at: 1 ) equals: 2.	self assert: ( row at: 2 ) equals: 2.	self assert: ( row at: 3 ) equals: 'three'.	self assert: row first equals: 2.	self assert: row last equals: 'three'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.567451-05:00'!testExecuteValueInsertThenSelectDateTime	| row data |	self executeInDB: 'create table if not exists x (xv datetime);'.	res := db beginTransaction.	self assert: res equals: 0.	data := DateAndTime year: 2015 month: 4 day: 1.	rs := db execute: 'insert into x values (?)' value: data.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select xv from x'.	row := rs next.	data := row at: 'xv'.	self assert: data class equals: DateAndTime.	self assert: data year equals: 2015.	self assert: data month equals: 4.	self assert: data dayOfMonth equals: 1.	data := row at: 1.	self assert: data class equals: DateAndTime.	self assert: data year equals: 2015.	self assert: data month equals: 4.	self assert: data dayOfMonth equals: 1.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.567988-05:00'!testExecuteWithAllInsertManyValues	| results |	self executeInDB:		'create table if not exists x (iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	db		execute: 'insert into x values (?, ?)'		withAll: #( #( 1 'two' ) #( 2 'three' ) #( 3 'four' ) ).	res := db commitTransaction.	self assert: res equals: 0.	results := OrderedCollection new.	rs := db execute: 'select * from x'.	rs do: [ :each | results add: each asArray ].	rs close.	self deny: results isEmpty.	self assert: results size equals: 3.	self assert: results first equals: #( 1 'two' ).	self assert: results second equals: #( 2 'three' ).	self assert: results third equals: #( 3 'four' )! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.568873-05:00'!testExecuteWithAllUpdateManyValues	| results |	self executeInDB:		'create table if not exists x (iv integer, tv text);'.	self executeInDB: 'delete from x;'.	self executeInDB: 'insert into x values (1, ''two'')'.	self executeInDB: 'insert into x values (2, ''three'')'.	self executeInDB: 'insert into x values (3, ''four'')'.	results := OrderedCollection new.	rs := db execute: 'select * from x'.	rs do: [ :each | results add: each asArray ].	rs close.	self deny: results isEmpty.	self assert: results size equals: 3.	self assert: results first equals: #( 1 'two' ).	self assert: results second equals: #( 2 'three' ).	self assert: results third equals: #( 3 'four' ).	res := db beginTransaction.	self assert: res equals: 0.	db		execute: 'update x set tv = ?2 where iv = ?1'		withAll: #( #( 1 'five' ) #( 2 'six' ) #( 3 'seven' ) ).	res := db commitTransaction.	self assert: res equals: 0.	results := OrderedCollection new.	rs := db execute: 'select * from x'.	rs do: [ :each | results add: each asArray ].	rs close.	self deny: results isEmpty.	self assert: results size equals: 3.	self assert: results first equals: #( 1 'five' ).	self assert: results second equals: #( 2 'six' ).	self assert: results third equals: #( 3 'seven' )! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.569453-05:00'!testExecuteWithInsertArray	| rd |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 1 'two' ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rd := ( db execute: 'select * from x' ) rows first.	self assert: ( rd at: 'xk' ) equals: 1.	self assert: ( rd at: 'iv' ) equals: 1.	self assert: ( rd at: 'tv' ) equals: 'two'.	self assert: ( rd at: 1 ) equals: 1.	self assert: ( rd at: 2 ) equals: 1.	self assert: ( rd at: 3 ) equals: 'two'.	self assert: rd first equals: 1.	self assert: rd last equals: 'two'! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.569999-05:00'!testExecuteWithInsertBooleanNilThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, bv boolean);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?)' with: ( Array with: nil ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'bv' ) equals: nil.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: nil.	self assert: row first equals: 1.	self assert: row last equals: nil.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.570518-05:00'!testExecuteWithInsertBooleanSQLNullThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, bv boolean);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, NULL)'.	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'bv' ) equals: nil.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: nil.	self assert: row first equals: 1.	self assert: row last equals: nil.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.571091-05:00'!testExecuteWithInsertBooleanThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, bv boolean);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?)' with: ( Array with: true ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'bv' ) equals: true.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: true.	self assert: row first equals: 1.	self assert: row last equals: true.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.571998-05:00'!testExecuteWithInsertChanges	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 1 'two' ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	self assert: db changes equals: 1.	self assert: db totalChanges equals: 1.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 2 'too' ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	self assert: db changes equals: 1.	self assert: db totalChanges equals: 2! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.572571-05:00'!testExecuteWithInsertDictionary	| rd |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db		      execute: 'insert into x values (NULL, :first, :two)'		      with: ( Dictionary newFromPairs: #( ':first' 1 ':two' '2' ':nosuch' 3 ) ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rd := ( db execute: 'select * from x' ) rows first.	self assert: ( rd at: 'xk' ) equals: 1.	self assert: ( rd at: 'iv' ) equals: 1.	self assert: ( rd at: 'tv' ) equals: '2'.	self assert: ( rd at: 1 ) equals: 1.	self assert: ( rd at: 2 ) equals: 1.	self assert: ( rd at: 3 ) equals: '2'.	self assert: rd first equals: 1.	self assert: rd last equals: '2'! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.573246-05:00'!testExecuteWithInsertMultilingualStringsThenSelect	| data s row idx |	data := OrderedCollection with: 'English' with: '' with: '' , ''.	self executeInDB: 'create table if not exists x (xk integer primary key, tv text);'.	self executeInDB: 'delete from x;'.	self executeInDB: 'begin'.	s := db prepare: 'insert into x values (NULL, ?)'.	data do: [ :x |		s at: 1 putString: x.		s step.		s clearBindings.		s reset		].	s finalize.	self executeInDB: 'commit'.	idx := 1.	rs := db execute: 'select xk, tv from x order by xk asc'.	[ ( row := rs next ) isNotNil ] whileTrue: [		self assert: ( row at: 'xk' ) equals: idx.		self assert: ( row at: 'tv' ) equals: ( data at: idx ).		idx := idx + 1		].	rs close.	self assert: idx equals: 4! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.573716-05:00'!testExecuteWithInsertNoDataThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL)' with: #(  ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 1 ) equals: 1.	self assert: row first equals: 1.	self assert: row last equals: 1.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.574307-05:00'!testExecuteWithInsertThenSelect	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 1 'two' ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'iv' ) equals: 1.	self assert: ( row at: 'tv' ) equals: 'two'.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: 1.	self assert: ( row at: 3 ) equals: 'two'.	self assert: row first equals: 1.	self assert: row last equals: 'two'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.575226-05:00'!testExecuteWithInsertThenSelect2	| row |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 1 'two' ).	self assert: rs next isNil.	rs close.	rs := db execute: 'insert into x values (NULL, ?, ?)' with: #( 2 'three' ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select * from x'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 1.	self assert: ( row at: 'iv' ) equals: 1.	self assert: ( row at: 'tv' ) equals: 'two'.	self assert: ( row at: 1 ) equals: 1.	self assert: ( row at: 2 ) equals: 1.	self assert: ( row at: 3 ) equals: 'two'.	self assert: row first equals: 1.	self assert: row last equals: 'two'.	row := rs next.	self assert: ( row at: 'xk' ) equals: 2.	self assert: ( row at: 'iv' ) equals: 2.	self assert: ( row at: 'tv' ) equals: 'three'.	self assert: ( row at: 1 ) equals: 2.	self assert: ( row at: 2 ) equals: 2.	self assert: ( row at: 3 ) equals: 'three'.	self assert: row first equals: 2.	self assert: row last equals: 'three'.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.576231-05:00'!testExecuteWithInsertThenSelect3	| s row idx |	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	self executeInDB: 'begin'.	s := db prepare: 'insert into x values (NULL, ?, ?)'.	1 to: 10 do: [ :x |		s at: 1 putInteger: x * x.		s at: 2 putString: x asString , ' * ' , x asString.		s step.		s clearBindings.		s reset		].	s finalize.	self executeInDB: 'commit'.	idx := 1.	rs := db execute: 'select * from x where iv < ?' with: #( 27 ).	[ ( row := rs next ) isNotNil ] whileTrue: [		self assert: ( row at: 'xk' ) equals: idx.		self assert: ( row at: 'iv' ) equals: idx * idx.		self assert: ( row at: 'tv' ) equals: idx asString , ' * ' , idx asString.		self assert: ( row at: 1 ) equals: idx.		self assert: ( row at: 2 ) equals: idx * idx.		self assert: ( row at: 3 ) equals: idx asString , ' * ' , idx asString.		self assert: row first equals: idx.		self assert: row last equals: idx asString , ' * ' , idx asString.		idx := idx + 1		].	rs close.	self assert: idx equals: 6! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.576887-05:00'!testExecuteWithInsertThenSelectChineseTableName	| data s row idx |	data := OrderedCollection with: 'English' with: '' with: '' , ''.	self executeInDB: 'create table if not exists  (xk integer primary key, tv text);'.	self executeInDB: 'delete from ;'.	self executeInDB: 'begin'.	s := db prepare: 'insert into  values (NULL, ?)'.	data do: [ :x |		s at: 1 putString: x.		s step.		s clearBindings.		s reset		].	s finalize.	self executeInDB: 'commit'.	idx := 1.	rs := db execute: 'select xk, tv from  order by xk asc'.	[ ( row := rs next ) isNotNil ] whileTrue: [		self assert: ( row at: 'xk' ) equals: idx.		self assert: ( row at: 'tv' ) equals: ( data at: idx ).		idx := idx + 1		].	rs close.	self assert: idx equals: 4! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.577573-05:00'!testExecuteWithInsertThenSelectDateTime	| row data |	self executeInDB: 'create table if not exists x (xv datetime);'.	res := db beginTransaction.	self assert: res equals: 0.	data := DateAndTime year: 2015 month: 4 day: 1.	rs := db execute: 'insert into x values (?)' with: ( Array with: data ).	self assert: rs next isNil.	rs close.	res := db commitTransaction.	self assert: res equals: 0.	rs := db execute: 'select xv from x'.	row := rs next.	data := row at: 'xv'.	self assert: data class equals: DateAndTime.	self assert: data year equals: 2015.	self assert: data month equals: 4.	self assert: data dayOfMonth equals: 1.	data := row at: 1.	self assert: data class equals: DateAndTime.	self assert: data year equals: 2015.	self assert: data month equals: 4.	self assert: data dayOfMonth equals: 1.	self assert: rs next isNil.	rs close! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.578201-05:00'!testExecuteWithInsertThenSelectJapaneseTableName	| data s row idx |	data := OrderedCollection with: 'English' with: '' with: '' , ''.	self executeInDB: 'create table if not exists  (xk integer primary key, tv text);'.	self executeInDB: 'delete from ;'.	self executeInDB: 'begin'.	s := db prepare: 'insert into  values (NULL, ?)'.	data do: [ :x |		s at: 1 putString: x.		s step.		s clearBindings.		s reset		].	s finalize.	self executeInDB: 'commit'.	idx := 1.	rs := db execute: 'select xk, tv from  order by xk asc'.	[ ( row := rs next ) isNotNil ] whileTrue: [		self assert: ( row at: 'xk' ) equals: idx.		self assert: ( row at: 'tv' ) equals: ( data at: idx ).		idx := idx + 1		].	rs close.	self assert: idx equals: 4! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.578488-05:00'!testExecuteWithToFail	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	self		should: [ db execute: 'insert into x values (NULL, ?, ?)' with: 42 ]		raise: SQLite3AbstractError.	res := db rollbackTransaction.	self assert: res equals: 0! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.57874-05:00'!testExecuteWithToFail2	self executeInDB: 'create table if not exists x (xk integer primary key, iv integer, tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	self		should: [ db execute: 'insert into x values (NULL, ?, ?)' with: '42' ]		raise: SQLite3AbstractError.	res := db rollbackTransaction.	self assert: res equals: 0! !!SQLite3ConnectionTest methodsFor: 'tests - open / close' stamp: '2025-09-26T14:41:26.579054-05:00'!testForcedClose	| fileRef conn |	fileRef := FileReference		           newTempFilePrefix: 'sqlite3_test_forced_close_'		           suffix: '.db'.	self assert: fileRef exists not.	conn := SQLite3Connection on: fileRef fullName.	conn open.	self assert: fileRef exists.	conn execute: 'create table if not exists BOOK (ID integer primary key, NAME VARCHAR2);'.	"now force closing"	conn forceClose.	Smalltalk garbageCollect.		"it must be possible to delete the DB now"	fileRef delete.	self assert: fileRef exists not! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.57923-05:00'!testGetAutocommit	self assert: db getAutoCommit equals: true.	db beginTransaction.	self assert: db getAutoCommit equals: false.	db rollbackTransaction.	self assert: db getAutoCommit equals: true! !!SQLite3ConnectionTest methodsFor: 'tests - glorp compatibility' stamp: '2025-09-26T14:41:26.580499-05:00'!testGlorpAutoID	| schema rows |	schema := 'CREATE TABLE BOOK (ID INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, STUFF TEXT NOT NULL);'.	db basicExecute: schema.	db beginTransaction.	db execute: 'insert into BOOK (STUFF) values (?)'		with: #('The Bad Beginning').	db execute: 'insert into BOOK (STUFF) values (?)'		with: #('Better Now').	db commitTransaction.	rows := (db execute: 'select last_insert_rowid() as lid') rows.	self assert: (rows first at: 'lid') equals: 2.	rows := (db execute: 'select * from BOOK') rows.	self assert: rows size equals: 2.	self assert: (rows first at: 'ID') equals: 1.	self assert: (rows first at: 'STUFF') equals: 'The Bad Beginning'! !!SQLite3ConnectionTest methodsFor: 'tests - glorp compatibility' stamp: '2025-09-26T14:41:26.58084-05:00'!testGlorpCompositeKey	| schema rows |	"This is the schema generated by Glorp."	schema := 'CREATE TABLE GR_USER (ID integer  NOT NULL ,NAME text  NULL , CONSTRAINT GR_USER_PK PRIMARY KEY  (ID), CONSTRAINT GR_USER_UNIQ UNIQUE  (ID));'.	db basicExecute: schema.	db beginTransaction.	db execute: 'insert into GR_USER values (?, ?)' with: #(1 'User One').	db execute: 'insert into GR_USER values (?, ?)' with: #(2 'User Two').	db commitTransaction.	rs := db execute: 'select ID,NAME from GR_USER'.	rows := rs rows.	self assert: rows size equals: 2.	self assert: (rows first at: 'ID') equals: 1.	self assert: (rows first at: 'NAME') equals: 'User One'! !!SQLite3ConnectionTest methodsFor: 'tests - glorp compatibility' stamp: '2025-09-26T14:41:26.581233-05:00'!testGlorpDoubleInsertPrimaryKey	| schema rows |	schema := 'CREATE TABLE GR_USER (ID integer  NOT NULL ,NAME text  NULL , CONSTRAINT GR_USER_PK PRIMARY KEY  (ID), CONSTRAINT GR_USER_UNIQ UNIQUE  (ID));'.	db basicExecute: schema.	db beginTransaction.	db execute: 'insert into GR_USER values (?, ?)'		with: #(1 'Fred').	self should: [ db execute: 'insert into GR_USER values (?, ?)' with: #(1 'Barney') ]		raise: SQLite3AbstractError.	db commitTransaction.	rs := db execute: 'select * from GR_USER'.	rows := rs rows.	self assert: rows size equals: 1.	self assert: (rows first at: 'ID') equals: 1.	self assert: (rows first at: 'NAME') equals: 'Fred'! !!SQLite3ConnectionTest methodsFor: 'tests - glorp compatibility' stamp: '2025-09-26T14:41:26.581611-05:00'!testGlorpUpdate	| schema rows |	schema := 'CREATE TABLE BOOK (ID INTEGER PRIMARY KEY AUTOINCREMENT  NOT NULL ,TITLE text  NULL ,DESCRIPTION text  NULL ,COPIES_IN_STOCK int  NULL ,VERSION int  NULL );'.	db basicExecute: schema.	db beginTransaction.	db execute: 'insert into BOOK (TITLE,COPIES_IN_STOCK,VERSION) values (?, ?, ?)'		with: #('The Bad Beginning' 3 6).	db execute: 'UPDATE BOOK SET TITLE = ?,COPIES_IN_STOCK = ?,VERSION = ? WHERE ID = ? AND BOOK.VERSION = ?'		with: #('The Bad Beginning' 6 7 1 6).	db commitTransaction.	rs := db execute: 'select * from BOOK'.	rows := rs rows.	self assert: rows size equals: 1.	self assert: (rows first at: 'ID') equals: 1.	self assert: (rows first at: 'TITLE') equals: 'The Bad Beginning'.	self assert: (rows first at: 'COPIES_IN_STOCK') equals: 6! !!SQLite3ConnectionTest methodsFor: 'tests - glorp compatibility' stamp: '2025-09-26T14:41:26.582004-05:00'!testGlorpUpdateTwice	| schema rows |	schema := 'CREATE TABLE BOOK (ID INTEGER PRIMARY KEY AUTOINCREMENT  NOT NULL ,TITLE text  NULL ,DESCRIPTION text  NULL ,COPIES_IN_STOCK int  NULL ,VERSION int  NULL );'.	db basicExecute: schema.	db beginTransaction.	db execute: 'insert into BOOK (TITLE,COPIES_IN_STOCK,VERSION) values (?, ?, ?)'		with: #('The Bad Beginning' 3 6).	db execute: 'UPDATE BOOK SET COPIES_IN_STOCK = 7'.	db execute: 'UPDATE BOOK SET TITLE = ?,COPIES_IN_STOCK = ?,VERSION = ? WHERE ID = ? AND BOOK.VERSION = ?'		with: #('The Bad Beginning' 6 7 1 6).	db commitTransaction.	rs := db execute: 'select * from BOOK'.	rows := rs rows.	self assert: rows size equals: 1.	self assert: (rows first at: 'ID') equals: 1.	self assert: (rows first at: 'TITLE') equals: 'The Bad Beginning'.	self assert: (rows first at: 'COPIES_IN_STOCK') equals: 6! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.582342-05:00'!testInsertThenSelectInTransaction	"From GlorpDatabaseBasicTest>>testNameBinding."	self executeInDB: 'create table if not exists x (id integer , tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	db basicExecute: 'insert into x values (10, "abc")'.	db basicExecute: 'insert into x values (20, "def")'.	db basicExecute: 'insert into x values (30, "ghi")'.	rs := db execute: 'select * from x where id = ? or id = ?' with: { 10. 30 }.	self assert: rs rows size equals: 2.	res := db rollbackTransaction.	self assert: res equals: 0! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.583275-05:00'!testRows	"SQLite uses 1-based column indexing for database rows."	| rowCount rows any |	rowCount := self populateRowsInto: 'junk' of: db.	rs := db execute: 'select * from junk'.	rs rowClass: SQLite3Row.	rows := rs rows.	self assert: rows size equals: rowCount.	self assert: ( rows first at: 'rk' ) equals: 1.	self assert: ( rows first at: 'rt' ) equals: '1-ZZZ'.	self assert: ( rows first at: 1 ) equals: 1.	self assert: ( rows first at: 3 ) equals: '1-ZZZ'.	1 to: 5 do: [ :x |		any := Random new nextInt: rowCount.		self assert: ( ( rows at: any ) at: 'rk' ) equals: any.		self assert: ( ( rows at: any ) at: 'rt' ) equals: any asString , '-ZZZ'.		self assert: ( ( rows at: any ) at: 1 ) equals: any.		self assert: ( ( rows at: any ) at: 3 ) equals: any asString , '-ZZZ'		].	self assert: ( rows last at: 'rk' ) equals: rowCount.	self assert: ( rows last at: 'rt' ) equals: rowCount asString , '-ZZZ'.	self assert: ( rows last at: 1 ) equals: rowCount.	self assert: ( rows last at: 3 ) equals: rowCount asString , '-ZZZ'! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.5835-05:00'!testStatementReadOnly	| stmt |	self populateRowsInto: 'junk' of: db.	stmt := db prepare: 'select * from junk'.	self assert: stmt isReadOnly equals: true.	stmt := db prepare: 'delete from junk'.	self assert: stmt isReadOnly equals: false! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.583793-05:00'!testValueInsertThenSelectInTransaction	"From GlorpDatabaseBasicTest>>testNameBinding."	self executeInDB: 'create table if not exists x (id integer , tv text);'.	self executeInDB: 'delete from x;'.	res := db beginTransaction.	self assert: res equals: 0.	db basicExecute: 'insert into x values (10, "abc")'.	db basicExecute: 'insert into x values (20, "def")'.	db basicExecute: 'insert into x values (30, "ghi")'.	rs := db execute: 'select * from x where id = ? or id = ?' value: 10 value: 30.	self assert: rs rows size equals: 2.	res := db rollbackTransaction.	self assert: res equals: 0! !!SQLite3ConnectionTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.584057-05:00'!untestStatementInProgress	"XXX Doesn't work yet."	| s1 s2 |	res := db basicExecute: 'create table if not exists x (xk integer primary key, iv integer);'.	self assert: res equals: 0.	db beginTransaction.	s1 := db prepare: 'insert into x values (NULL, ?)'.	s1 at: 1 putInteger: 1.	"s1 step."	db execute: 'delete from x;'.	"self should: [ db rollbackTransaction ] raise: SQLite3Error."	db commitTransaction.	s1 reset.	s1 finalize! !!SQLite3DatabaseTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.584846-05:00'!testPrintString	self assert: SQLite3Database memory printString equals: 'a SQLite3Database(":memory:")'! !!SQLite3RowTest methodsFor: 'running' stamp: '2025-09-26T14:41:26.585068-05:00'!setUp	super setUp.	emptyRow := SQLite3Row new.	filledRow := SQLite3Row new columnNames: {'foo'. 'bar'. 'pi'}; yourself.	filledRow		at: 'foo' put: 1;		at: 'bar' put: true;		at: 'pi' put: '3.14'! !!SQLite3RowTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.585211-05:00'!testAsArray	self assert: emptyRow asArray equals: #().	self assert: filledRow asArray equals: #(1 true '3.14')! !!SQLite3RowTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.585472-05:00'!testAsCombinedDictionary	| dict  |	dict := Dictionary new.	dict at: 'foo' put: 1.	dict at: 'bar' put: true.	dict at: 'pi' put: '3.14'.	dict at: 1 put: 1.	dict at: 2 put: true.	dict at: 3 put: '3.14'.	self assert: emptyRow asCombinedDictionary equals: Dictionary new.	self assert: filledRow asCombinedDictionary equals: dict! !!SQLite3RowTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.585682-05:00'!testAsDictionary	| dict  |	dict := Dictionary new.	dict at: 'foo' put: 1.	dict at: 'bar' put: true.	dict at: 'pi' put: '3.14'.	self assert: emptyRow asDictionary equals: Dictionary new.	self assert: filledRow asDictionary equals: dict! !!SQLite3RowTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.585942-05:00'!testColumnAccessingIfAbsent	|blockExecutedFlag|	blockExecutedFlag := false.	filledRow at: 'foo' ifAbsent: [ blockExecutedFlag := true ].	self deny: blockExecutedFlag.	filledRow at: 'nope' ifAbsent: [ blockExecutedFlag := true ].	self assert: blockExecutedFlag! !!SQLite3RowTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.586033-05:00'!testColumnAccessingOnEmptyRow	self assert: (emptyRow at: 'foo') equals: nil! !!SQLite3RowTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.586212-05:00'!testColumnAccessingOnFilledRow	self assert: (filledRow at: 'foo') equals: 1.	self assert: (filledRow at: 'bar') equals: true.	self assert: (filledRow at: 'pi') equals: '3.14'.	self assert: (filledRow at: 'nope') equals: nil! !!SQLite3RowTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.586298-05:00'!testColumnNamesOnEmptyRow	self assert: emptyRow columnNames equals: #()! !!SQLite3RowTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.586383-05:00'!testColumnNamesOnFilledRow	self assert: filledRow columnNames equals: #('foo' 'bar' 'pi')! !!SQLite3RowTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.586514-05:00'!testColumnPuttingOnEmptyRow	self assert: (emptyRow at: 'foo') equals: nil.	emptyRow at: 'foo' put: 42.	self assert: (emptyRow at: 'foo') equals: 42! !!SQLite3RowTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.586648-05:00'!testColumnPuttingOnFilledRow	self assert: (filledRow at: 'foo') equals: 1.	filledRow at: 'foo' put: 2.	self assert: (filledRow at: 'foo') equals: 2! !!SQLite3TableBasedTest class methodsFor: 'testing' stamp: '2025-09-26T14:41:26.586743-05:00'!isAbstract	^ self == SQLite3TableBasedTest! !!SQLite3TableBasedTest methodsFor: 'running' stamp: '2025-09-26T14:41:26.586959-05:00'!setUp	super setUp.	db := SQLite3Database memory.	db connection open.	db connection execute: self tableCreationScript.	table := db tables first! !!SQLite3TableBasedTest methodsFor: 'accessing' stamp: '2025-09-26T14:41:26.587061-05:00'!tableCreationScript	^ self subclassResponsibility! !!SQLite3TableBasedTest methodsFor: 'running' stamp: '2025-09-26T14:41:26.587157-05:00'!tearDown	db connection close.	db := nil.	super tearDown! !!SQLite3TableBasedTest methodsFor: 'tests - sample' stamp: '2025-09-26T14:41:26.587246-05:00'!testSampleTableSchema	self assert: table schema equals: self tableCreationScript! !!SQLite3TableTest methodsFor: 'accessing' stamp: '2025-09-26T14:41:26.587308-05:00'!tableCreationScript	^'CREATE TABLE "SAMPLE"(    [ID] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,    [NAME] NVARCHAR(120))'! !!SQLite3TableTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.587481-05:00'!testName	| properties instance |	properties := Dictionary newFromPairs: #( #name 'SimpleTable' ).	instance := SQLite3Table properties: properties in: nil.	self assert: instance name equals: 'SimpleTable'! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '2025-09-26T14:41:26.587569-05:00'!testNumberOfRows	self assert: table numberOfRows equals: 0! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '2025-09-26T14:41:26.587666-05:00'!testNumberOfRowsIsOne	db execute: 'INSERT INTO SAMPLE(NAME) VALUES (''first example'');'.	self assert: table numberOfRows equals: 1! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '2025-09-26T14:41:26.587779-05:00'!testNumberOfRowsIsTwo	db execute: 'INSERT INTO SAMPLE(NAME) VALUES (''first example''), (''second example'');'.	self assert: table numberOfRows equals: 2! !!SQLite3TableTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.587866-05:00'!testPrintString	self assert: table printString equals: 'a SQLite3Table("SAMPLE")'! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '2025-09-26T14:41:26.587948-05:00'!testRows	self assert: table rows isEmpty! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '2025-09-26T14:41:26.588134-05:00'!testRowsHasOneRow	| rows |	db execute: 'INSERT INTO SAMPLE(NAME) VALUES (''first example'');'.	rows := table rows.	self deny: rows isEmpty.	self assert: rows size equals: 1.	self assert: (rows first at: 'NAME') equals: 'first example'! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '2025-09-26T14:41:26.588367-05:00'!testRowsHasTwoRows	| rows |	db execute:		'INSERT INTO SAMPLE(NAME) VALUES (''first example''), (''second example'');'.	rows := table rows.	self deny: rows isEmpty.	self assert: rows size equals: 2.	self assert: (rows first at: 'NAME') equals: 'first example'.	self assert: (rows second at: 'NAME') equals: 'second example'! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '2025-09-26T14:41:26.588454-05:00'!testSampleTable	self assert: table name equals: 'SAMPLE'! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '2025-09-26T14:41:26.588541-05:00'!testSampleTableColumnNames	self assert: table columnNames size equals: 2! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '2025-09-26T14:41:26.588625-05:00'!testSampleTableColumns	self assert: table columns size equals: 2! !!SQLite3TableTest methodsFor: 'tests - sample' stamp: '2025-09-26T14:41:26.588935-05:00'!testSampleTableProperties	|props|	props := table properties.	self assert: props size equals: 5.	self assert: (props at: #type) equals: 'table'.	self assert: (props at: #tbl_name) equals: 'SAMPLE'.	self assert: (props at: #rootpage) equals: 2.	self assert: (props at: #name) equals: 'SAMPLE'.	self assert: (props at: #sql) equals: self tableCreationScript! !!SQLite3TableTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.589034-05:00'!testUnitializedName	self assert: SQLite3Table new name equals: ''! !!SQLite3TableWithSpacesTest methodsFor: 'accessing' stamp: '2025-09-26T14:41:26.58909-05:00'!tableCreationScript	^'CREATE TABLE "ANOTHER TABLE"(    [ID] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,    [SOME NAME] NVARCHAR(120))'! !!SQLite3TableWithSpacesTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.58922-05:00'!testColumnNameHasSpace	self assert: table columnNames size equals: 2.	self assert: table columnNames second equals: 'SOME NAME'! !!SQLite3TableWithSpacesTest methodsFor: 'tests' stamp: '2025-09-26T14:41:26.589303-05:00'!testPrintStringHasTableNameWithSpace	self assert: table printString equals: 'a SQLite3Table("ANOTHER TABLE")'! !!ManifestSQLite3CoreTests class methodsFor: 'code coverage' stamp: '2025-09-26T14:41:26.589376-05:00'!classNamesNotUnderTest	^ #( ManifestSQLite3CoreTests )! !!ManifestSQLite3CoreTests class methodsFor: 'code-critics' stamp: '2025-09-26T14:41:26.589489-05:00'!ruleEmptyExceptionHandlerRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#SQLite3ConnectionTest #tearDown #false)) #'2022-05-10T08:25:11.111+02:00') #(#(#RGMethodDefinition #(#SQLite3BaseConnectionTest #tearDown #false)) #'2022-05-10T08:27:13.419+02:00') )! !!ManifestSQLite3CoreTests class methodsFor: 'code-critics' stamp: '2025-09-26T14:41:26.589574-05:00'!ruleLiteralArrayContainsCommaRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#SQLite3BaseConnectionTest #deactivatedTestTracing #false)) #'2022-05-10T08:24:31.021+02:00') )! !!ManifestSQLite3CoreTests class methodsFor: 'code-critics' stamp: '2025-09-26T14:41:26.589654-05:00'!ruleLiteralArrayContainsSuspiciousTrueFalseOrNilRuleV1FalsePositive	^ #(#(#(#RGMetaclassDefinition #(#'ManifestSQLite3CoreTests class' #ManifestSQLite3CoreTests)) #'2022-05-10T08:26:37.973+02:00') )! !"SQLite3-Core-Tests"!!SQLite3Row methodsFor: '*SQLite3-Inspector-Extensions' stamp: '2025-09-26T14:41:26.820558-05:00'!inspectionSQLite3Row	<inspectorPresentationOrder: 10 title: 'SQlite3 - Contents'>	| presenter |	presenter := SpTablePresenter new.	presenter items: (Array with: self).	self columnNames do: [:each |		presenter addColumn: (SpStringTableColumn title: each evaluated: [ :assoc | self at: each ])	].	^presenter! !!SQLite3Database methodsFor: '*SQLite3-Inspector-Extensions' stamp: '2025-09-26T14:41:26.821641-05:00'!inspectionSQLite3Tables	<inspectorPresentationOrder: 10 title: 'Sqlite3 - Tables'>	^ SpTablePresenter new		items: self tables;		beResizable;		addColumn: (SpStringTableColumn title: 'Name' evaluated: [ :assoc | assoc name ]);		addColumn: (SpStringTableColumn title: 'Number of rows' evaluated: [ :assoc | assoc numberOfRows ]);		yourself! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions' stamp: '2025-09-26T14:41:26.822952-05:00'!databaseSize	|s|	s := self size.	s / 1024 > 1024 ifTrue: [ ^ ((s / 1024 / 1024) roundDownTo: 0.01) asString, ' MB' ].	^ ((s / 1024) roundDownTo: 0.01) asString, ' KB'! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions' stamp: '2025-09-26T14:41:26.82544-05:00'!inspectionSQLite3Info	<inspectorPresentationOrder: -2 title: 'SQLite3 - Info'>	| label1 label2 |	label1 := SpLabeledPresenter		          label: 'Database file:'		          input: (SpTextInputFieldPresenter new text: self fullName).	label2 := SpLabeledPresenter		          label: 'Database size:'		          input: (SpTextInputFieldPresenter new text: self databaseSize).	^ SpPresenter new		  layout: (SpBoxLayout newTopToBottom				   add: label1;					add: label2;				   yourself);		  yourself! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions' stamp: '2025-09-26T14:41:26.825798-05:00'!inspectionSQLite3InfoContext: aContext	^ aContext active: self isSQlite3Database! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions' stamp: '2025-09-26T14:41:26.826463-05:00'!inspectionSQLite3Tables	<inspectorPresentationOrder: -1 title: 'SQLite3 - Tables'>	^ SpTablePresenter new			items: (SQLite3Database tableInfoFor: self fullName);			addColumn: (SpStringTableColumn title: 'Table Name' evaluated: [ :assoc | assoc name ]);			addColumn: (SpStringTableColumn title: 'Number of Rows' evaluated: [ :assoc | assoc numberOfRows ]);			yourself! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions' stamp: '2025-09-26T14:41:26.826702-05:00'!inspectionSQLite3TablesContext: aContext	^ aContext active: self isSQlite3Database! !!AbstractFileReference methodsFor: '*SQLite3-Inspector-Extensions' stamp: '2025-09-26T14:41:26.82739-05:00'!isSQlite3Database	"Return true if the reference is an SQLite3 database file"	^ self isFile and: [		  self extension = 'db' and: [			  (self readStreamDo: [ :s | s next: 16 ])			  = ('SQLite format 3' , Character null asString) ] ]! !!SQLite3Table methodsFor: '*SQLite3-Inspector-Extensions' stamp: '2025-09-26T14:41:26.828038-05:00'!inspectionSQLite3Columns	<inspectorPresentationOrder: 13 title: 'SQLite3 - Columns'>	^ SpTablePresenter new		  items: self columns;		  beResizable;		  addColumn: (SpStringTableColumn				   title: 'Column Name'				   evaluated: [ :each | each name ]);		  addColumn: (SpStringTableColumn				   title: 'Column Type'				   evaluated: [ :each | each type ]);		  addColumn:			  (SpStringTableColumn				   title: 'Non-empty values'				   evaluated: [ :each |					   each hasNotNullConstraint						   ifTrue: [ 'NOT NULL' ]						   ifFalse: [ '' ] ]);		  yourself! !!SQLite3Table methodsFor: '*SQLite3-Inspector-Extensions' stamp: '2025-09-26T14:41:26.828578-05:00'!inspectionSQLite3Data	<inspectorPresentationOrder: 11 title: 'SQLite3 - Data'>	| presenter |	presenter := SpTablePresenter new		             items: self rows;		             beResizable;		             yourself.	self columnNames do: [ :col |		presenter addColumn:			(SpStringTableColumn title: col evaluated: [ :each | each at: col ]) ].	^ presenter! !!SQLite3Table methodsFor: '*SQLite3-Inspector-Extensions' stamp: '2025-09-26T14:41:26.828784-05:00'!inspectionSQLite3Schema	<inspectorPresentationOrder: 10 title: 'SQLite3 - Schema'>	^ SpTextPresenter new		text: self schema;		yourself! !!SQLite3Table methodsFor: '*SQLite3-Inspector-Extensions' stamp: '2025-09-26T14:41:26.829171-05:00'!inspectionSQLite3TableProperties	<inspectorPresentationOrder: 40 title: 'SQLite3 - Table Properties'>	^ SpTablePresenter new		  items: self properties associations;		  beResizable;		  addColumn: (SpStringTableColumn				   title: 'Property'				   evaluated: [ :assoc | assoc key ]);		  addColumn: (SpStringTableColumn				   title: 'Value'				   evaluated: [ :assoc | assoc value ]);		  yourself! !"SQLite3-Inspector-Extensions"!!BaselineOfZincHTTPComponents commentStamp: 'SvenVanCaekenberghe 7/5/2020 16:32' prior: 0!I am BaselineOfZincHTTPComponents.I am a BaselineOf.I am used to load the Zinc HTTP Components project from GitHub as in   Metacello new    repository: 'github://svenvc/zinc/repository';    baseline: 'ZincHTTPComponents';    load.The following groups are available to load: - default (Core & Tests) - Core (Zinc-HTTP Zinc-HTTP-Examples Zinc-Zodiac-Core) - Tests (Zinc-Tests Zinc-Character-Encoding-Tests Zinc-Resource-Meta-Tests Zodiac-Tests Zinc-Zodiac-Tests) - Character-Encoding - Resource-Meta - Zodiac - AWS - WebDAV - WebSocket - SSO-OAuth1 - SSO-OAuth2 - SSO-OpenID - SSO-Demo - SSO (SSO-OAuth1 SSO-OAuth2 SSO-OpenID SSO-Demo Zinc-SSO-Demo) - WWS (Zinc-WWS-Server Zinc-WWS-Client) - REST - Server-Sent-EventsSee also https://github.com/svenvc/zincPart of Zinc HTTP Components.!!BaselineOfZincHTTPComponents methodsFor: 'baselines' stamp: '9/23/2025 02:00:26'!baseline: spec	<baseline>	spec for: #common do: [		spec baseline: 'NeoJSON' with: [ spec repository: 'github://svenvc/NeoJSON:master/repository' ].		spec baseline: 'XMLParser' with: [ spec repository: 'github://pharo-contributions/XML-XMLParser:master/src' ].		spec package: 'Zodiac-Core' with: [ spec repository: 'github://svenvc/zodiac:master/repository' ].		spec package: 'Zodiac-Tests' with: [ spec repository: 'github://svenvc/zodiac:master/repository' ].		spec			package: 'Zinc-Character-Encoding-Core';			package: 'Zinc-Character-Encoding-Tests' with: [ spec requires: 'Zinc-Character-Encoding-Core' ];			package: 'Zinc-Resource-Meta-Core' with: [ spec requires: 'Zinc-Character-Encoding-Core' ];			package: 'Zinc-Resource-Meta-Tests' with: [ spec requires: 'Zinc-Resource-Meta-Core' ];			package: 'Zinc-HTTP' with: [ 				spec postLoadDoIt: #recompileZnLogEventHierarchy; requires: #('Zinc-Character-Encoding-Core' 'Zinc-Resource-Meta-Core') ];			package: 'Zinc-HTTP-Examples' with: [ spec requires: #('Zinc-HTTP') ];			package: 'Zinc-Tests' with: [ spec requires: 'Zinc-HTTP' ];			package: 'Zinc-Zodiac-Core' with: [ spec requires: #('Zinc-HTTP' 'Zodiac-Core') ];			package: 'Zinc-Zodiac-Tests' with: [ spec requires:  #('Zinc-Zodiac-Core') ].		spec			package: 'Zinc-AWS' with: [ spec requires: #('Zinc-HTTP' 'XMLParser') ];			package: 'Zinc-REST' with: [ spec requires: #('Zinc-HTTP' 'NeoJSON') ];			package: 'Zinc-WebSocket-Core' with: [ spec requires: 'Zinc-HTTP' ];			package: 'Zinc-WebSocket-Tests' with: [ spec requires: 'Zinc-WebSocket-Core' ];			package: 'Zinc-SSO-OAuth1-Core' with: [ spec requires: #('Zinc-HTTP' 'NeoJSON') ];			package: 'Zinc-SSO-OAuth2-Core' with: [ spec requires: #('Zinc-HTTP' 'NeoJSON') ];			package: 'Zinc-SSO-OpenID-Core' with: [ spec requires: #('Zinc-HTTP' 'XMLParser') ];			package: 'Zinc-SSO-Demo' with: [ spec requires: #('Zinc-SSO-OAuth1-Core' 'Zinc-SSO-OAuth2-Core' 'Zinc-SSO-OpenID-Core') ];			package: 'Zinc-SSO-OAuth1-Tests' with: [ spec requires: #('Zinc-SSO-OAuth1-Core') ];			package: 'Zinc-SSO-OpenID-Tests' with: [ spec requires: #('Zinc-SSO-OpenID-Core') ];			package: 'Zinc-WebDAV' with: [ spec requires: 'Zinc-HTTP' ];			package: 'Zinc-WWS-Server' with: [ spec requires: 'Zinc-HTTP' ];			package: 'Zinc-WWS-Client' with: [ spec requires: 'Zinc-HTTP' ];			package: 'Zinc-Server-Sent-Events' with: [ spec requires: 'Zinc-HTTP' ].		spec			group: 'default' with: #('Core' 'Tests');			group: 'Core' with: #('Zinc-HTTP' 'Zinc-HTTP-Examples' 'Zinc-Zodiac-Core');			group: 'Tests' with: #('Zinc-Tests' 'Zinc-Character-Encoding-Tests' 'Zinc-Resource-Meta-Tests' 'Zodiac-Tests' 'Zinc-Zodiac-Tests');			group: 'Character-Encoding' with: #('Zinc-Character-Encoding-Core' 'Zinc-Character-Encoding-Tests');			group: 'Resource-Meta' with: #('Zinc-Resource-Meta-Core' 'Zinc-Resource-Meta-Tests');			group: 'Zodiac' with: #('Zodiac-Core' 'Zodiac-Tests');			group: 'AWS' with: #('Zinc-AWS');			group: 'WebDAV' with: #('Zinc-WebDAV');			group: 'WebSocket' with: #('Zinc-WebSocket-Core' 'Zinc-WebSocket-Tests');			group: 'SSO-OAuth1' with: #('Zinc-SSO-OAuth1-Core' 'Zinc-SSO-OAuth1-Tests');			group: 'SSO-OAuth2' with: #('Zinc-SSO-OAuth2-Core');			group: 'SSO-OpenID' with: #('Zinc-SSO-OpenID-Core' 'Zinc-SSO-OpenID-Tests');			group: 'SSO-Demo' with: #('Zinc-SSO-OAuth1-Core' 'Zinc-SSO-OAuth2-Core' 'Zinc-SSO-OpenID-Core');			group: 'SSO' with: #('SSO-OAuth1' 'SSO-OAuth2' 'SSO-OpenID' 'SSO-Demo' 'Zinc-SSO-Demo');			group: 'WWS' with: #('Zinc-WWS-Server' 'Zinc-WWS-Client');			group: 'REST' with: #('Zinc-REST');			group: 'Server-Sent-Events' with: #('Zinc-Server-Sent-Events') ]! !!BaselineOfZincHTTPComponents methodsFor: 'doits' stamp: '9/23/2025 02:00:26'!recompileZnLogEventHierarchy	"This is a hack, but somehow there is something wrong in the instance variables layout, 	which can only be fixed by recompiling, which should happen but doesn't, so force it."	ZnLogEvent withAllSubclassesDo: #recompile! !"BaselineOfZincHTTPComponents"!!ZdcUtils commentStamp: 'Anonymous 6/16/2024 18:13' prior: 0!I am ZdcUtils.!!ZdcIOBuffer methodsFor: 'initialize-release' stamp: '9/11/2025 06:10:01' prior: 88202516!close	buffer ifNotNil: [		ZdcByteArrayManager current recycle: buffer.		buffer := nil.		self reset ]! !!ZdcIOBuffer methodsFor: 'initialize-release' stamp: '9/11/2025 06:10:01' prior: 88202904!on: sequenceableCollection	buffer := sequenceableCollection.	self reset! !!ZdcAbstractSocketStream methodsFor: 'initialize-release' stamp: '9/11/2025 06:10:01' prior: 88139822!close	"Close the stream, flush if necessary"	[ self flush ] ensure: [		socket ifNotNil: [			self socketClose.			socket := nil ].		readBuffer close.		writeBuffer close ]! !!ZdcAbstractSocketStream methodsFor: 'initialize-release' stamp: '9/11/2025 06:10:01' prior: 88151384!initializeBuffers	readBuffer := ZdcIOBuffer onByteArrayOfSize: 4096.	writeBuffer := ZdcIOBuffer onByteArrayOfSize: 4096! !!ZdcAbstractSocketStream methodsFor: 'initialize-release' stamp: '9/11/2025 06:10:01' prior: 88142642!on: object	socket := object! !!ZdcAbstractSocketStream methodsFor: 'private - socket' stamp: '9/11/2025 06:10:01' prior: 88148210!socketWaitForSendDone	"Compatibility shim for Pharo <11, where #waitForSendDone: returns a boolean	indicating success, rather than signaling exceptions on failure.	A true return (in P11) or nothing/self (in P12) both indicate success,	so check for specifically false."	(socket waitForSendDoneFor: self timeout) == false ifTrue: [		ConnectionTimedOut signal: 'Data send timed out.' ]! !!ZdcSimpleSocketStream methodsFor: 'initialize-release' stamp: '9/11/2025 06:10:01' prior: 88308508!connectTo: hostAddress port: portNumber	"Connect our socket to hostAddress:portNumber.	Wait up to timeout for a connection"	self socketConnectTo: hostAddress port: portNumber! !!ZdcSimpleSocketStream methodsFor: 'private - out' stamp: '9/11/2025 06:10:01' prior: 88309062!flushBytes: bytes startingAt: offset count: count	"Ask the socket to write count bytes starting from offset. Wait. Fail if not successful"	| writeCount |	self isConnected ifFalse: [ ConnectionClosed signal: 'Cannot write data' ].	writeCount := 0.	[ | written |		written := self socketSendData: bytes startingAt: offset + writeCount count: count - writeCount.		(writeCount := writeCount + written) = count ] whileFalse: [		self socketWaitForSendDone ]! !!ZdcPluginSSLSession methodsFor: 'initialization' stamp: '9/11/2025 06:10:01' prior: 88247986!destroy	"Destroys the platform handle in the VM plugin"	handle ifNil: [ ^ self ].	self primitiveSSLDestroy: handle.	handle := nil.	self finalizationRegistry remove: self ifAbsent: [  ]! !!ZdcPluginSSLSession methodsFor: 'finalization' stamp: '9/11/2025 06:10:01' prior: 88253646!finalize	self destroy! !!ZdcPluginSSLSession methodsFor: 'initialization' stamp: '9/11/2025 06:10:01' prior: 88245604!initialize	"Initialize the receiver"	super initialize.	[ handle := self primitiveSSLCreate ]		on: (ZdcUtils exceptionSet: #( #SocketError #PrimitiveFailed ))		do: [ :exception | "Give a more human friendly error message"			ZdcPluginMissing signal ].	self finalizationRegistry add: self.	self logging: false! !!ZdcSecureSocketStream methodsFor: 'testing' stamp: '9/11/2025 06:10:01' prior: 88291650!atEnd	"I am atEnd when there is no more data to be read and there never will be.	This means that readBuffer must be empty, there must be no more unread data	available at the socket, and the socket must be closed"	readBuffer isEmpty ifFalse: [ ^ false ].	socket notNil		ifTrue: [			"Try reading (there might stil be data in the SSL session) and test again"			[ self fillReadBufferNoWait ]				on: ConnectionClosed				do: [ ^ true ].			readBuffer isEmpty ifFalse: [ ^ false ] ].	^ self isConnected not! !!ZdcSecureSocketStream methodsFor: 'initialize-release' stamp: '9/11/2025 06:10:01' prior: 88286056!close	"Close the stream, flush if necessary.	Destory the SSLSession object."	[ super close ] ensure: [		sslSession ifNotNil: [			sslSession destroy.			sslSession := nil ].		ZdcByteArrayManager current recycle: in; recycle: out.		in := out := nil ]! !!ZdcSecureSocketStream methodsFor: 'initialize-release' stamp: '9/11/2025 06:10:01' prior: 88286768!initializeBuffers	"The maximum payload message length of a TLS record is 16Kb,	add a margin for the header and trailer."	readBuffer := ZdcIOBuffer onByteArrayOfSize: 16 * 1024.	writeBuffer := ZdcIOBuffer onByteArrayOfSize: 4 * 1024.	in := ZdcByteArrayManager current byteArrayOfSize: 4096 zero: false.	out := ZdcByteArrayManager current byteArrayOfSize: (16 + 1) * 1024 zero: false! !!ZdcSecureSocketStream methodsFor: 'testing' stamp: '9/11/2025 06:10:01' prior: 88298486!isDataAvailable	"Return true when there is data available for reading.	This does not block."	readBuffer isEmpty ifFalse: [ ^ true ].	socket notNil		ifTrue: [			"Try reading (there might stil be data in the SSL session) and test again"			[ self fillReadBufferNoWait ]				on: ConnectionClosed				do: [ ^ false ].			readBuffer isEmpty ifFalse: [ ^ true ] ].	^ false! !!ZdcUtils class methodsFor: 'converting' stamp: '9/11/2025 06:10:01'!exceptionSet: classNames	^ classNames inject: ExceptionSet new into: [ :set :each |		  (Smalltalk globals includesKey: each)			  ifTrue: [				  set					  add: (Smalltalk at: each);					  yourself ]			  ifFalse: [ set ] ]! !"Zodiac-Core"!!ZdcReferenceSocketStreamTest methodsFor: 'private' stamp: '9/11/2025 06:10:01' prior: 88263678!openConnectionToHost: host port: port	| stream |	stream := super openConnectionToHost: host port: port.	self setReferenceSocketStreamOptions: stream.	^ stream! !!ZdcReferenceSocketStreamTest methodsFor: 'private' stamp: '9/11/2025 06:10:01' prior: 88264476!openConnectionToHostNamed: host port: port	| stream |	stream := super openConnectionToHostNamed: host port: port.	self setReferenceSocketStreamOptions: stream.	^ stream! !!ZdcAbstractSocketStreamTest methodsFor: 'private' stamp: '9/11/2025 06:10:01' prior: 88182970!openConnectionToHost: host port: port	^ self socketStreamClass		openConnectionToHost: host port: port! !!ZdcAbstractSocketStreamTest methodsFor: 'private' stamp: '9/11/2025 06:10:01' prior: 88188216!openConnectionToHostNamed: host port: port	^ self socketStreamClass		openConnectionToHostNamed: host port: port! !!ZdcAbstractSocketStreamTest methodsFor: 'accessing' stamp: '9/11/2025 06:10:01' prior: 88173830!port	^ serverPort! !!ZdcAbstractSocketStreamTest methodsFor: 'private' stamp: '9/11/2025 06:10:01' prior: 88186852!runServer: block	| serverSocket semaphore |	serverSocket := self serverSocketOn: 0.	self assert: serverSocket notNil.	serverPort := serverSocket port.		semaphore := Semaphore new.	[	semaphore signal.	[ block cull: serverSocket cull: semaphore ]		ensure: [			serverSocket closeAndDestroy.			semaphore signal ] ] forkAt: self serverPriority.	semaphore wait.	^ semaphore! !!ZdcAbstractSocketStreamTest methodsFor: 'private' stamp: '9/11/2025 06:10:01' prior: 88166232!serverSocketOn: port	| socket |	(socket := Socket newTCP)		setOption: 'TCP_NODELAY' value: 1;		setOption: 'SO_SNDBUF' value: self socketBufferSize;		setOption: 'SO_RCVBUF' value: self socketBufferSize .	socket listenOn: port backlogSize: self listenBacklogSize.	socket isValid		ifFalse: [ self error: 'Cannot create socket on port ', port printString ].	^ socket! !!ZdcPluginSSLSessionTest methodsFor: 'tests' stamp: '9/11/2025 06:10:01' prior: 88260420!testServerName	[ session serverName; serverName: nil ] 		on: (ZdcUtils exceptionSet: #( #SocketError #PrimitiveFailed )) 		do: [ ^ self skip ].	self assert: session serverName equals: nil.	session serverName: 'pharo.org'.	self assert: session serverName equals: 'pharo.org'.	session serverName: 'smalltalkhub.com'.	self assert: session serverName equals: 'smalltalkhub.com'.	session serverName: nil.	self assert: session serverName equals: nil! !!ZdcPluginSSLSessionFinalizationTest methodsFor: 'running' stamp: '9/11/2025 06:10:01' prior: 88259624!tearDown	client ifNotNil: [ client close ].	clone ifNotNil: [		[ clone destroy ]			on: PrimitiveFailed			do: [ "I ignore, because if the test works... it has been alread done"			#ignore ] ].	super tearDown! !!ZdcPluginSSLSessionFinalizationTest methodsFor: 'tests' stamp: '9/11/2025 06:10:01' prior: 88258558!testPluginSSLSessionIsCorrectlyFinalized	| previousState afterState |	client := ZnClient new.	client url: 'https://www.google.com'.	client method: #GET.	client execute.	client response.	clone := client connection sslSession clone.	previousState := clone serverName.	client := nil.	3 timesRepeat: [ Smalltalk garbageCollect ].	afterState := clone serverName.	self deny: previousState equals: afterState! !ManifestZodiacTests class removeSelector: #ruleReClassNotCategorizedRuleV1FalsePositive!ManifestZodiacTests class removeSelector: #ruleEmptyExceptionHandlerRuleV1FalsePositive!Smalltalk globals removeClassNamed: #AnObsoleteManifestZodiacTests!"Zodiac-Tests"!!ZnLossyUTF8Encoder commentStamp: '<historical>' prior: 0!I am ZnLossyUTF8Decoder.I am a ZnUTF8Decoder.I behave like my superclass but will not signal errors when I see illegal UTF-8 encoded input,instead I will output a Unicode Replacement Character (U+FFFD) for each error.In contrast to my superclass I can read any random byte sequence, decoding both legal and illegal UTF-8 sequences. Due to my stream based design and usage as well as my stateless implementation,  I will output multiple replacement characters when multiple illegal sequences occur.  My convenience method #decodeBytesSingleReplacement: shows how to decode bytes so that  only a single replacement character stands for any amount of illegal encoding between legal encodings.  When I encounter an illegal code point while writing, I output the encoding for the replacement character. Part of Zinc HTTP Components.!!ZnDebuggingUTF8Encoder commentStamp: '<historical>' prior: 0!I am ZnDebuggingUTF8Encoder..I am a ZnLossyUTF8Decoder and a ZnUTF8Decoder.I behave like my superclass but will output a verbose error when I am asked to write a Unicode code point that I cannot encode.For reading I inherit from my superclass. Part of Zinc HTTP Components.!!Stream methodsFor: '*Zinc-Character-Encoding-Core' stamp: '9/23/2025 02:00:26'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Since this the base stream, answer ourself."	^ self! !!Stream methodsFor: '*Zinc-Character-Encoding-Core' stamp: '9/23/2025 02:00:26'!wrappedStream	"Answer the stream that the receiver wraps.	Since this the base stream, answer nil"	^ nil! !!ZnBufferedReadWriteStream methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnBufferedReadWriteStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88687056!sizeBuffer: anInteger	readStream sizeBuffer: anInteger.	writeStream sizeBuffer: anInteger! !!SocketStream methodsFor: '*Zinc-Character-Encoding-Core' stamp: '9/23/2025 02:00:26'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Since this the base stream, answer ourself."	^ self! !!SocketStream methodsFor: '*Zinc-Character-Encoding-Core' stamp: '9/23/2025 02:00:26'!wrappedStream	"Answer the stream that the receiver wraps.	Since this the base stream, answer nil"	^ nil! !!ZnEndianessReadWriteStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89317930!on: aStream	stream := aStream! !!ZnPositionableReadStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89830420!close	"Close me after which I can no longer be accessed. I delegate this to the stream that I wrap."	stream close! !!ZnPositionableReadStream methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnPositionableReadStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89840938!sizeBuffer: size	"Change the buffer size. This should be done when I am still in my initial state."	buffer := self collectionSpecies new: size! !!ZnUTF16Encoder methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!byteOrderMarkLE	"My little endian sequence of the Unicode BOM. See #byteOrderMark"		^ 16rFFFE! !!ZnUTF16Encoder methodsFor: 'encoding - decoding' stamp: '9/23/2025 02:00:26' prior: 90241278!encodedByteCountForCodePoint: codePoint	"Return how many bytes are needed to encode integer code point"	codePoint <= 65535 ifTrue: [ ^ 2 ].	codePoint <= self maximumUTFCode ifTrue: [ ^ 4 ].	^ self errorOutsideRangeByteCount: codePoint! !!ZnUTF16Encoder methodsFor: 'encoding - decoding' stamp: '9/23/2025 02:00:26' prior: 90240008!nextCodePointFromStream: stream	"Read and return the next integer code point from stream"	| word leadSurrogate trailSurrogate code |	word := self read16BitWordFromStream: stream.	((self processByteOrderMark: word) and: [ self ignoreByteOrderMark ])		ifTrue: [ word := self read16BitWordFromStream: stream ].	^ (word < 16rD800 or: [ word > 16rDBFF ])		ifTrue: [			word ]		ifFalse: [			leadSurrogate := word.			trailSurrogate := self read16BitWordFromStream: stream.			code := (leadSurrogate - 16rD800) * 16r400 + (trailSurrogate - 16rDC00).			16r10000 + code ]! !!ZnUTF16Encoder methodsFor: 'encoding - decoding' stamp: '9/23/2025 02:00:26' prior: 90245570!nextPutCodePoint: codePoint toStream: stream	"Write the encoding for integer code point to stream"	| leadSurrogate trailSurrogate shifted |	(self isSurrogateCodePoint: codePoint) 		ifTrue: [ ^ self errorOutsideRange: codePoint to: stream ].	codePoint <= 65535		ifTrue: [			^ self write16BitWord: codePoint toStream: stream ].	codePoint <= self maximumUTFCode		ifTrue: [			shifted := codePoint - 16r10000.			leadSurrogate := 16rD800 + (shifted // 16r400).			trailSurrogate := 16rDC00 + (shifted \\ 16r400).			self write16BitWord: leadSurrogate toStream: stream.			self write16BitWord: trailSurrogate toStream: stream ]		ifFalse: [			^ self errorOutsideRange: codePoint to: stream ]! !!ZnUTF16Encoder methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 90241884!processByteOrderMark: word	^ (word = self byteOrderMark or: [ word = self byteOrderMarkLE ])		ifTrue: [			word = self byteOrderMarkLE 				ifTrue: [ self swapEndianness ].			true ]		ifFalse: [ false ]! !!ZnUTF16Encoder methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 90242390!read16BitWordFromStream: stream	| firstByte secondByte |	firstByte := stream next.	secondByte := stream next.	(firstByte isNil or: [ secondByte isNil ])		ifTrue: [ ^ self errorIncompleteFrom: stream ].	^ self isBigEndian		ifTrue: [ secondByte + (firstByte << 8) ]		ifFalse: [ firstByte + (secondByte << 8) ]! !!ZnBufferedWriteStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88715662!close	self flushBuffer.	stream close! !!ZnBufferedWriteStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88715936!finish	self flushBuffer! !!ZnBufferedWriteStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88716560!on: writeStream	stream := writeStream.	position := 0! !!ZnBufferedWriteStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnBufferedWriteStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26'!wrappedStream	^ stream! !!ZnSimplifiedByteEncoder methodsFor: 'encoding - decoding' stamp: '9/23/2025 02:00:26' prior: 90092372!nextCodePointFromStream: stream	"In non-strict mode, we let byte values for holes in our mapping pass through"	| byteValue |	^ (byteValue := stream next) < 128		ifTrue: [ byteValue ]		ifFalse: [			(byteToUnicode at: byteValue - 127 ifAbsent: [ nil ])				ifNotNil: [ :unicode | unicode asInteger ]				ifNil: [					strict						ifTrue: [ ^ self errorOutsideRange: byteValue from:stream ]						ifFalse: [ byteValue ] ] ]! !!ZnSimplifiedByteEncoder methodsFor: 'encoding - decoding' stamp: '9/23/2025 02:00:26' prior: 90087666!nextFromStream: stream	"In non-strict mode, we let byte values for holes in our mapping pass through.	Overwritten for performance reasons"	| byteValue |	^ (byteValue := stream next ifNil: [ ^ self errorIncompleteFrom: stream ]) < 128		ifTrue: [ Character value: byteValue ]		ifFalse: [			(byteToUnicode at: byteValue - 127 ifAbsent: [ nil ])				ifNotNil: [ :unicode | unicode ]				ifNil: [					strict						ifTrue: [ ^ Character value: (self errorOutsideRange: byteValue from:stream) ]						ifFalse: [ Character value: byteValue ] ] ]! !!ZnSimplifiedByteEncoder methodsFor: 'encoding - decoding' stamp: '9/23/2025 02:00:26' prior: 90095336!nextPutCodePoint: codePoint toStream: stream	"In non-strict mode, we let code points for holes in our mapping table pass through"	codePoint < 128		ifTrue: [ stream nextPut: codePoint ]		ifFalse: [			| byte |			byte := unicodeToByte at: codePoint ifAbsent: [ nil ].			(byte isNil and: [ strict or: [ codePoint > 255 ] ])				ifTrue: [ ^ self errorOutsideRange: codePoint to: stream ].			stream nextPut: (byte ifNil: [ codePoint ]) ]! !!ZnCharacterEncoder methodsFor: 'error handling' stamp: '9/23/2025 02:00:26'!errorIncompleteFrom: stream	^ self errorIncomplete! !!ZnCharacterEncoder methodsFor: 'error handling' stamp: '9/23/2025 02:00:26'!errorOutsideRange: codePoint from: stream	self errorOutsideRange.	^ 0! !!ZnCharacterEncoder methodsFor: 'error handling' stamp: '9/23/2025 02:00:26'!errorOutsideRange: codePoint to: stream	^ self errorOutsideRange! !!ZnCharacterEncoder methodsFor: 'error handling' stamp: '9/23/2025 02:00:26'!errorOutsideRangeByteCount: codePoint	self errorOutsideRange.	^ 0! !!ZnEndianSensitiveUTFEncoder class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!handlesEncoding: string	"Return true when my instances handle the encoding described by string"	^ false! !!ZnEndianSensitiveUTFEncoder class methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!isAbstract	^ self = ZnEndianSensitiveUTFEncoder! !!ZnEndianSensitiveUTFEncoder class methodsFor: 'instance creation' stamp: '9/23/2025 02:00:26' prior: 89316706!newForEncoding: string	"Return a new character encoder object for an encoding described by string.	Try to infer endianness from string, defaulting to big endian."	| encoder |	encoder := self new.	encoder identifier: string.	(string asLowercase endsWith: 'be') ifTrue: [ encoder beBigEndian ].	(string asLowercase endsWith: 'le') ifTrue: [ encoder beLittleEndian ].	^ encoder! !!ZnEndianSensitiveUTFEncoder methodsFor: 'comparing' stamp: '9/23/2025 02:00:26' prior: 89314450!= anObject	^ super = anObject and: [ self identifier == anObject identifier ]! !!ZnEndianSensitiveUTFEncoder methodsFor: 'comparing' stamp: '9/23/2025 02:00:26' prior: 89316382!hash	^ self identifier hash! !!ZnEndianSensitiveUTFEncoder methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!identifier	^ identifier! !!ZnEndianSensitiveUTFEncoder methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!identifier: anObject	identifier := anObject! !!ZnEndianSensitiveUTFEncoder methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 89315912!printOn: stream	super printOn: stream.	stream nextPut: $(.	stream print: self identifier asString; space.	stream nextPutAll: endianness; nextPutAll: ' endian'.	stream nextPut: $)! !!ZnUTFEncoder class methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!isAbstract	^ self = ZnUTFEncoder ! !!ZnUTFEncoder methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 90281266!byteOrderMark	"The code point of the Unicode Byte-Order-Mark or BOM character.	This is the big endian sequence.	See https://en.wikipedia.org/wiki/Byte_order_mark"	^ 16rFEFF! !!ZnUTFEncoder methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!ignoreByteOrderMark	"Return true when I ignore Unicode byte-order mark (BOM) occurences that I read (the default)."		^ ignoreByteOrderMark ifNil: [ ignoreByteOrderMark := true ]! !!ZnUTFEncoder methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!ignoreByteOrderMark: boolean	"When boolean is true I ignore Unicode byte-order mark (BOM) occurences that I read (the default)."	ignoreByteOrderMark := boolean! !!ZnBufferedReadStream methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 88662486!back	"Move backwards one element and return it"	^ position > limit		ifTrue: [			stream back ]		ifFalse: [ | targetPosition bufferPosition char |			position = 1 ifTrue:				[ stream position = 0 ifTrue:					[ self error: 'Cannot move back from beginning' ]				ifFalse:					[ targetPosition := self position - 1.					"Assume that the caller may want to go back a few elements before reading forward again"					bufferPosition := targetPosition - 10 max: 0.					self position: bufferPosition.					self nextBuffer.					self position: targetPosition.					self peek ] ]			ifFalse:				[ char := buffer at: position.				position := position - 1.				char ] ]! !!ZnBufferedReadStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88643038!close	stream close! !!ZnBufferedReadStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88644476!on: readStream	stream := readStream.	self sizeBuffer: self defaultBufferSize! !!ZnBufferedReadStream methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnBufferedReadStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88659444!sizeBuffer: size	buffer := self collectionSpecies new: size! !!ZnNullEncoder class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 89783512!knownEncodingIdentifiers	^ #( 'null' )! !!ZnNullEncoder methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 89777688!identifier	^ 'null'! !!ZnNullEncoder methodsFor: 'encoding - decoding' stamp: '9/23/2025 02:00:26' prior: 89774454!nextPutCodePoint: codePoint toStream: stream	"Write the encoding for Integer code point to stream"	codePoint < 256		ifTrue: [ stream nextPut: codePoint ]		ifFalse: [ ^ self errorOutsideRange: codePoint to: stream ]! !!ZnEncodedStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89304462!close	stream close! !!ZnEncodedStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89304166!encoder: characterEncoder	encoder := characterEncoder! !!ZnEncodedStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89307094!encoding: encoding	encoder := encoding asZnCharacterEncoder! !!ZnEncodedStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89304896!on: wrappedStream	stream := wrappedStream! !!ZnEncodedStream methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnEncodedStream methodsFor: 'initialization' stamp: '9/23/2025 02:00:26' prior: 89306550!reset	^ stream reset! !!ZnPercentEncoder methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89814026!characterEncoder: object	"Set the character encoding to use to object."	characterEncoder := object! !!ZnPercentEncoder methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89815550!decodePlusAsSpace: boolean	"When boolean is true, $+ on input will be decoded as Character space.	Else $+ is treated as a normal character, filtered by the safe set.	This is normally only done application/x-www-form-urlencoded data,	but is is on by default anyway."	decodePlusAsSpace := boolean! !!ZnPercentEncoder methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89818270!safeSet: string	"Set my safe set to be the characters in string, which I will convert to bytes"	safeSet := string asByteArray! !!ZnNewLineWriterStream methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnNewLineWriterStream methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!wrappedStream	^ stream! !!ZnDebuggingUTF8Encoder class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!handlesEncoding: string	"Return true when my instances handle the encoding described by string"	^ (self canonicalEncodingIdentifier: string) = 'utf8debug'! !!ZnDebuggingUTF8Encoder class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!knownEncodingIdentifiers	^ #( 'utf8debug' )! !!ZnDebuggingUTF8Encoder methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!defaultWriteErrorBlock	^ [ :codePoint | 		'<Cannot utf-8 encode code point {1}>' format: { codePoint } ]! !!ZnDebuggingUTF8Encoder methodsFor: 'error handling' stamp: '9/23/2025 02:00:26'!errorOutsideRange: codePoint to: stream	| errorMessage |	errorMessage := self writeErrorBlock value: codePoint.	errorMessage isByteString		ifFalse: [ errorMessage := self defaultWriteErrorBlock value: codePoint ].	stream nextPutAll: errorMessage asByteArray! !!ZnDebuggingUTF8Encoder methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!identifier	^ 'utf8debug'! !!ZnDebuggingUTF8Encoder methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!writeErrorBlock	^ writeErrorBlock ifNil: [ writeErrorBlock := self defaultWriteErrorBlock ]! !!ZnDebuggingUTF8Encoder methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!writeErrorBlock: aOneArgumentBlock	writeErrorBlock := aOneArgumentBlock! !!ZnLossyUTF8Encoder class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!handlesEncoding: string	"Return true when my instances handle the encoding described by string"	^ (self canonicalEncodingIdentifier: string) = 'utf8lossy'! !!ZnLossyUTF8Encoder class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!knownEncodingIdentifiers	^ #( 'utf8lossy' )! !!ZnLossyUTF8Encoder methodsFor: 'convenience' stamp: '9/23/2025 02:00:26'!decodeBytesSingleReplacement: bytes	"Decode bytes and return the resulting string.	This variant of #decodeBytes: will only ever use 	a single replacement character for each illegal UTF-8 sequence"	| byteStream replaced replacement char |	byteStream := bytes readStream.	replaced := false.	replacement := self replacementCodePoint asCharacter.	^ String streamContents: [ :stream |		[ byteStream atEnd ] whileFalse: [			char := self nextFromStream: byteStream.			char = replacement				ifTrue: [					replaced 						ifFalse: [							replaced := true.							stream nextPut: replacement ] ]				ifFalse: [					replaced := false.					stream nextPut: char ] ] ]! !!ZnLossyUTF8Encoder methodsFor: 'error handling' stamp: '9/23/2025 02:00:26'!errorIllegalContinuationByte: byte from: stream	^ self replacementCodePoint! !!ZnLossyUTF8Encoder methodsFor: 'error handling' stamp: '9/23/2025 02:00:26'!errorIllegalLeadingByte: byte from: stream	^ self replacementCodePoint! !!ZnLossyUTF8Encoder methodsFor: 'error handling' stamp: '9/23/2025 02:00:26'!errorIncompleteFrom: stream	^ self replacementCodePoint! !!ZnLossyUTF8Encoder methodsFor: 'error handling' stamp: '9/23/2025 02:00:26'!errorOutsideRange: codePoint from: stream	^ self replacementCodePoint! !!ZnLossyUTF8Encoder methodsFor: 'error handling' stamp: '9/23/2025 02:00:26'!errorOutsideRange: codePoint to: stream	stream nextPutAll: self replacementCodePointEncoded! !!ZnLossyUTF8Encoder methodsFor: 'error handling' stamp: '9/23/2025 02:00:26'!errorOutsideRangeByteCount: codePoint	^ 0! !!ZnLossyUTF8Encoder methodsFor: 'error handling' stamp: '9/23/2025 02:00:26'!errorOverlong: codePoint from: stream	^ self replacementCodePoint! !!ZnLossyUTF8Encoder methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!identifier	^ 'utf8lossy'! !!ZnLossyUTF8Encoder methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!replacementCodePoint	"Return the code point for the Unicode Replacement Character U+FFFD"		^ 16rFFFD! !!ZnLossyUTF8Encoder methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!replacementCodePointEncoded	"Return the encoded utf-8 byte sequence for the Unicode Replacement Character U+FFFD"		"self replacementCodePoint asCharacter utf8Encoded"		^ #[239 191 189]! !!ZnUTF8Encoder class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 90275724!knownEncodingIdentifiers	^ #( 'utf8' )! !!ZnUTF8Encoder methodsFor: 'encoding - decoding' stamp: '9/23/2025 02:00:26' prior: 90269626!encodedByteCountForCodePoint: codePoint	"Return how many bytes are needed to encode integer code point"	codePoint < 128 ifTrue: [ ^ 1 ].	codePoint < 2048 ifTrue: [ ^ 2 ].	codePoint < 65535 ifTrue: [ ^ 3 ].	codePoint <= self maximumUTFCode ifTrue: [ ^ 4 ].	^ self errorOutsideRangeByteCount: codePoint! !!ZnUTF8Encoder methodsFor: 'encoding - decoding' stamp: '9/23/2025 02:00:26' prior: 90258280!ensureAtBeginOfCodePointOnStream: stream	"Ensure that the current position of stream is a the beginning of an encoded code point,	if not move further backwards. This is necessary when a position in the binary stream is set,	not knowing if that position is on a proper encoded character boundary."	"If we are at end-of-stream, we can't be in the middle of an encoded codepoint	(unless that codepoint is incomplete and thus invalid, which we won't worry about)"	stream atEnd ifTrue: [ ^ self ].	"Back up until we are not longer on a continuation byte but on a leading byte"	[ (stream peek bitAnd: 2r11000000) == 2r10000000 ] whileTrue: [ stream back ]! !!ZnUTF8Encoder methodsFor: 'error handling' stamp: '9/23/2025 02:00:26'!errorIllegalContinuationByte: byte from: stream	^ self error: 'Illegal continuation byte for utf-8 encoding'! !!ZnUTF8Encoder methodsFor: 'error handling' stamp: '9/23/2025 02:00:26'!errorIllegalLeadingByte: byte from: stream	^ self error: 'Illegal leading byte for utf-8 encoding'! !!ZnUTF8Encoder methodsFor: 'error handling' stamp: '9/23/2025 02:00:26'!errorOverlong: codePoint from: stream	^ self error: 'Overlong utf-8 encoding (non-shortest form)'! !!ZnUTF8Encoder methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 90263490!identifier	^ 'utf8'! !!ZnUTF8Encoder methodsFor: 'encoding - decoding' stamp: '9/23/2025 02:00:26' prior: 90266072!nextCodePointFromStream: stream	"Read and return the next integer code point from stream"	| code byte next |	(byte := stream next ifNil: [ ^ self errorIncompleteFrom: stream ]) < 128		ifTrue: [ ^ byte ].	(byte bitAnd: 2r11100000) == 2r11000000		ifTrue: [			code := byte bitAnd: 2r00011111.			((next := stream next ifNil: [ ^ self errorIncompleteFrom: stream ]) bitAnd: 2r11000000) == 2r10000000				ifTrue: [ code := (code bitShift: 6) + (next bitAnd: 2r00111111) ]				ifFalse: [ ^ self errorIllegalContinuationByte: next from: stream ].			code < 128 ifTrue: [ ^ self errorOverlong: code from: stream ].			^ code ].	(byte bitAnd: 2r11110000) == 2r11100000		ifTrue: [			code := byte bitAnd: 2r00001111.			2 timesRepeat: [				((next := stream next ifNil: [ ^ self errorIncompleteFrom: stream ]) bitAnd: 2r11000000) == 2r10000000					ifTrue: [ code := (code bitShift: 6) + (next bitAnd: 2r00111111) ]					ifFalse: [ ^ self errorIllegalContinuationByte: next from: stream ] ].			code < 2048 ifTrue: [ ^ self errorOverlong: code from: stream ].			(self isSurrogateCodePoint: code) ifTrue: [ ^ self errorOutsideRange: code from: stream ].			(code = self byteOrderMark and: [ self ignoreByteOrderMark ]) ifTrue: [				stream atEnd ifTrue: [ ^ self errorIncompleteFrom: stream ].				^ self nextCodePointFromStream: stream ].			^ code ].	(byte bitAnd: 2r11111000) == 2r11110000		ifTrue: [			code := byte bitAnd: 2r00000111.			3 timesRepeat: [				((next := stream next ifNil: [ ^ self errorIncompleteFrom: stream ]) bitAnd: 2r11000000) == 2r10000000					ifTrue: [ code := (code bitShift: 6) + (next bitAnd: 2r00111111) ]					ifFalse: [ ^ self errorIllegalContinuationByte: next from: stream ] ].			code < 65535 ifTrue: [ ^ self errorOverlong: code from: stream ].			code > self maximumUTFCode ifTrue: [ ^ self errorOutsideRange: code from: stream ].			^ code ].	^ self errorIllegalLeadingByte: byte from: stream! !!ZnUTF8Encoder methodsFor: 'encoding - decoding' stamp: '9/23/2025 02:00:26' prior: 90273142!nextPutCodePoint: codePoint toStream: stream	"Write the encoding for Integer code point to stream"	codePoint < 128 ifTrue: [		^ stream nextPut: codePoint ].	codePoint < 2048 ifTrue: [		^ stream			nextPut: (2r11000000 + (codePoint bitShift: -6));			nextPut: (2r10000000 + (codePoint bitAnd: 2r111111)) ].	(self isSurrogateCodePoint: codePoint) ifTrue: [ ^ self errorOutsideRange: codePoint to: stream ].	codePoint < 65536 ifTrue: [		^ stream			nextPut: (2r11100000 + (codePoint bitShift: -12));			nextPut: (2r10000000 + ((codePoint bitShift: -6) bitAnd: 2r111111));			nextPut: (2r10000000 + (codePoint bitAnd: 2r111111)) ].	codePoint <= self maximumUTFCode ifTrue: [		^ stream			nextPut: (2r11110000 + (codePoint bitShift: -18));			nextPut: (2r10000000 + ((codePoint bitShift: -12) bitAnd: 2r111111));			nextPut: (2r10000000 + ((codePoint bitShift: -6) bitAnd: 2r111111));			nextPut: (2r10000000 + (codePoint bitAnd: 2r111111)) ].	^ self errorOutsideRange: codePoint to: stream! !!ZnUTF32Encoder methodsFor: 'private' stamp: '9/23/2025 02:00:26'!byteOrderMarkLE	"My little endian sequence of the Unicode BOM. See #byteOrderMark"		^ 16rFFFE0000! !!ZnUTF32Encoder methodsFor: 'encoding - decoding' stamp: '9/23/2025 02:00:26' prior: 90253548!encodedByteCountForCodePoint: codePoint	"Return how many bytes are needed to encode integer codePoint"	codePoint > self maximumUTFCode		ifTrue: [ ^ self errorOutsideRangeByteCount: codePoint ].	^ 4! !!ZnUTF32Encoder methodsFor: 'encoding - decoding' stamp: '9/23/2025 02:00:26' prior: 90250158!nextCodePointFromStream: stream	"Read and return the next integer code point from stream"	| codePoint |	codePoint := self readCodePointFrom: stream.	((self processByteOrderMark: codePoint) and: [ self ignoreByteOrderMark ])		ifTrue: [ codePoint := self readCodePointFrom: stream ].	((self isSurrogateCodePoint: codePoint) or: [ codePoint > self maximumUTFCode ])		ifTrue: [ ^ self errorOutsideRange: codePoint from: stream ].	^ codePoint! !!ZnUTF32Encoder methodsFor: 'encoding - decoding' stamp: '9/23/2025 02:00:26' prior: 90255996!nextPutCodePoint: codePoint toStream: stream	"Write the encoding for integer code point to stream"	(self isSurrogateCodePoint: codePoint)		ifTrue: [ ^ self errorOutsideRange: codePoint to: stream ].	codePoint <= self maximumUTFCode		ifTrue: [			self writeCodePoint: codePoint to: stream ]		ifFalse: [			^ self errorOutsideRange: codePoint to: stream ]! !!ZnUTF32Encoder methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 90254084!processByteOrderMark: codePoint	^ (codePoint = self byteOrderMark or: [ codePoint = self byteOrderMarkLE ])		ifTrue: [			codePoint = self byteOrderMarkLE 				ifTrue: [ self swapEndianness ].			true ]		ifFalse: [ false ]! !!ZnUTF32Encoder methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 90252428!readCodePointFrom: stream	| byte1 byte2 byte3 byte4 |	byte1 := stream next.	byte2 := stream next.	byte3 := stream next.	byte4 := stream next.	(byte1 isNil or: [ byte2 isNil or: [ byte3 isNil or: [ byte4 isNil ] ] ])		ifTrue: [ ^ self errorIncompleteFrom: stream ].	^ self isBigEndian		ifTrue: [			(byte1 bitShift: 24) + (byte2 bitShift: 16) + (byte3 bitShift: 8) + byte4 ]		ifFalse: [			(byte4 bitShift: 24) + (byte3 bitShift: 16) + (byte2 bitShift: 8) + byte1 ]! !ZnUTF8Encoder removeSelector: #errorOverlong!ZnUTF8Encoder removeSelector: #errorIllegalLeadingByte!ZnUTF8Encoder removeSelector: #errorIllegalContinuationByte!ZnUTF16Encoder removeSelector: #identifier!ZnUTF16Encoder removeSelector: #errorIncomplete!ZnUTF32Encoder removeSelector: #identifier!ZnUTF32Encoder removeSelector: #errorIncomplete!"Zinc-Character-Encoding-Core"!!ZnCharacterEncoderTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!testDebuggingUTF8	self 		assert: (({ $A. 55296 asCharacter . $B } as: String) encodeWith: #utf8debug) utf8Decoded 		equals: 'A<Cannot utf-8 encode code point 55296>B'! !!ZnCharacterEncoderTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 88862232!testKnownEncodingIdentifiers	| all minimal asciiString notSelfIdentifying|	all := ZnCharacterEncoder knownEncodingIdentifiers asSet.	minimal := #('utf8' 'latin1' 'null' 'ascii' 'iso88591') asSet.	"make sure at least a minimal set is present"	self assert: (all intersection: minimal) equals: minimal.	asciiString := String withAll: ($a to: $z) , ($A to: $Z) , ($0 to: $9).	"make sure that each identifier can be used to instanciate a decoder,	and that those decoders at least work on a ASCII string in both directions"	all do: [ :each |		| encoder bytes |		encoder := ZnCharacterEncoder newForEncoding: each.		bytes := encoder encodeString: asciiString.		self assert: (encoder decodeBytes: bytes) equals: asciiString ].	"make sure identifiers are preserved"	notSelfIdentifying := ZnCharacterEncoder knownEncodingIdentifiers reject: [ :each | 		each asZnCharacterEncoder identifier = each ].	self assert: notSelfIdentifying isEmpty! !!ZnCharacterEncoderTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!testLossyUTF8	| encoder replacement |	encoder := ZnLossyUTF8Encoder new.	self assert: #utf8lossy asZnCharacterEncoder equals: encoder.	replacement := encoder replacementCodePoint asCharacter.	self 		assert: (#[65 160 66] decodeWith: encoder) 		equals: ({ $A. replacement . $B } as: String).	self 		assert: (#[16rE1 16rA0 16rC0] decodeWith: encoder) 		equals: replacement asString.	self 		assert: (encoder decodeBytes: #[16r41 16rA1 16rA2 16rA3 16r42]) 		equals: ({ $A. replacement . replacement . replacement . $B } as: String).	self 		assert: (encoder decodeBytesSingleReplacement: #[16r41 16rA1 16rA2 16rA3 16r42])		equals: ({ $A. replacement . $B } as: String).	self		assert: (encoder encodeString: ({ $A . 16rFFFD asCharacter . $B } as: String))		equals: ({ $A . replacement . $B } as: String) utf8Encoded! !!ZnCharacterEncoderTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!testLossyUTF8Random	| bytes string |	bytes := ((1 to: 10000) collect: [ :_ | 256 atRandom - 1 ]) asByteArray.	string := bytes decodeWith: ZnLossyUTF8Encoder new.	self assert: string isString! !!ZnCharacterEncoderTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!testUTF8ByteOrderMarkSignificant	| input encoder result |	input := #[16r41 16rEF 16rBB 16rBF 16r42].	encoder := ZnUTF8Encoder new.	encoder ignoreByteOrderMark: false.	result := encoder decodeBytes: input.	self assert: result first equals: $A.	self assert: result second equals: encoder byteOrderMark asCharacter.	self assert: result third equals: $B! !!ZnCharacterStreamTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26' prior: 88941142!testUTF8ReadStreamPositioning	| bytes stream |	bytes := 'lve' utf8Encoded.	stream := ZnCharacterReadStream on: bytes readStream.	self assert: stream position equals: 0.	stream position: 0.	self assert: stream next equals: $.	stream position: 1.	self assert: stream next equals: $.	stream position: 2.	self assert: stream next equals: $l.	stream position: 3.	self assert: stream next equals: $.	stream position: 4.	self assert: stream next equals: $.	stream position: 5.	self assert: stream next equals: $v.	stream position: 6.	self assert: stream next equals: $e.	stream position: 7.	self assert: stream atEnd.! !"Zinc-Character-Encoding-Tests"!!ZnDataUrl commentStamp: 'SvenVanCaekenberghe 10/6/2023 18:45' prior: 0!I am ZnDataUrl, I implement the Data URI scheme as defined in RFC 2397.I am like a URL/URI, but as an immediate value. As such I encapsulate a mime type and data. The data can optionally be base64 encoded, which is needed for non textual types.Note that there is a difference between my external and internal representation. See #printOn: and #parseFrom:References- https://en.wikipedia.org/wiki/Data_URI_scheme- https://datatracker.ietf.org/doc/html/rfc2397!!ZnCurrentOptions class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 89218614!at: key	^ self value		ifNil: [ ZnOptions globalDefault at: key ]		ifNotNil: [ :options | options at: key ]! !!UNCNetworkPath methodsFor: '*Zinc-Resource-Meta-Core' stamp: '9/23/2025 02:00:26'!asUrl	"Convert the receiver in a file:// ZnUrl"	^ self asZnUrl! !!UNCNetworkPath methodsFor: '*Zinc-Resource-Meta-Core' stamp: '9/23/2025 02:00:26'!asZnUrl	"Convert the receiver in a file:// ZnUrl"	| fileUrl |	fileUrl := ZnUrl new.	fileUrl scheme: #file.	self do: [ :each | fileUrl addPathSegment: each ].	^ fileUrl! !!ZnUrl methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 90311112!isSchemeNotUsingDoubleSlash: schemeString	^ self class schemesNotUsingDoubleSlash , self class schemesOptionallyNotUsingDoubleSlash		includes: schemeString asLowercase asSymbol! !!ZnUrl methodsFor: 'parsing' stamp: '9/23/2025 02:00:26' prior: 90311820!parseFrom: string defaultScheme: defaultScheme	| start end index |	start := 1.	end := string size.	(index := string indexOf: $#) > 0		ifTrue: [			self fragment: (self decodePercent: (string copyFrom: index + 1 to: end)).			end := index - 1 ].	((index := (string indexOf: $?)) between: 1 and: end)		ifTrue: [			self query: (self parseQueryFrom: (ReadStream on: string from: index + 1 to: end)).			end := index - 1 ].	((index := string indexOfSubCollection: '://') > 0 and: [ index <= end ])		ifTrue: [			self scheme: (string copyFrom: 1 to: index - 1).			start := index + 3 ]		ifFalse: [			((index := string indexOf: $:) > 0					and: [ index <= end						and: [ self isSchemeNotUsingDoubleSlash: (string copyFrom: 1 to: index - 1) ] ])				ifTrue: [					self scheme: (string copyFrom: 1 to: index - 1).					start := index + 1 ]				ifFalse: [					defaultScheme ifNotNil: [ self scheme: defaultScheme ] ] ].	self hasScheme		ifTrue: [			(index := string indexOf: $/ startingAt: start) > 0				ifTrue: [					self parseAuthority: string from: start to: index - 1.					start := index ]				ifFalse: [					^ self parseAuthority: string from: start to: end ] ].	self parsePath: (ReadStream on: string from: start to: end)! !!ZnMimeType methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89638176!isBinary	"Answers whether the contents of a resource described by me	should be considered as binary instead of textual."		| subParts |	self main = 'text'		ifTrue: [ ^ false ].	subParts := self sub substrings: '+-'.	(subParts anySatisfy: [ :subPart |				self class textSubTypeFragments includes: subPart ])		ifTrue: [ ^ false ].	(subParts anySatisfy: [ :subPart | 				self class textSubTypeFragments anySatisfy: [ :fragment | 						subPart includesSubstring: fragment ] ])		ifTrue: [ ^ false ].	^ true! !!ZnMultiValueDictionary class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 89740990!defaultLimit	"Return the maximum number dictionary entries to accept.	Used by ZnMultiValueDictionary and thus for reading headers,	url query and application form url encoded entity fields.	This helps to protect us from malicious content."	^ ZnCurrentOptions at: #maximumNumberOfDictionaryEntries! !!ZnMultiValueDictionary methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89740410!initialize: n	super initialize: n.	limit := self class defaultLimit! !!ZnMultiValueDictionary methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89737546!limit: numberOfEntries	limit := numberOfEntries! !!ZnMultiValueDictionary methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89738864!unlimited	self limit: nil! !!ZnDataUrl class methodsFor: 'instance creation' stamp: '9/23/2025 02:00:26'!bytes: bytes type: mimeType	"self bytes: #[71 73 70 56 55 97 48 0 48 0 240 0 0 0 0 0 255 255 255 44 0 0 0 0 48 0 48 0 0 2 240 140 143 169 203 237 223 0 156 14 72 139 115 176 180 171 12 134 30 20 150 166 52 46 231 42 166 9 139 26 167 43 175 81 73 111 56 217 142 102 215 243 128 92 193 201 48 117 209 8 49 57 29 19 168 20 30 142 20 77 204 231 228 84 159 185 98 37 42 173 113 121 99 153 74 135 240 222 184 215 15 231 34 214 26 193 27 180 184 142 74 150 191 76 248 59 38 146 71 199 39 167 119 53 147 5 245 244 115 19 167 40 248 224 7 56 184 118 40 167 88 103 100 23 201 35 117 249 242 113 6 87 101 230 6 122 57 137 149 151 134 151 216 182 137 197 106 104 213 90 138 84 250 23 152 137 247 73 186 154 251 147 75 131 138 211 147 52 188 57 52 67 133 212 183 11 202 59 58 220 119 120 170 246 232 172 23 205 76 212 226 28 71 185 68 123 12 28 46 158 237 184 211 100 51 123 141 157 173 197 216 148 5 163 222 213 174 44 191 94 94 63 127 87 31 229 85 179 95 44 166 236 241 225 135 30 29 110 6 10 0 0 59] type: ZnMimeType imageGif"		^ self new		mediaType: mimeType;		data: bytes;		base64Encoded: true;		yourself! !!ZnDataUrl class methodsFor: 'instance creation' stamp: '9/23/2025 02:00:26'!fromString: string	"Parse the external representation of a Data URI from string.	The general format being data:[<mediatype>][;base64],<data>"		"self fromString: 'data:image/gif;base64,R0lGODdhMAAwAPAAAAAAAP///ywAAAAAMAAwAAAC8IyPqcvt3wCcDkiLc7C0qwyGHhSWpjQu5yqmCYsapyuvUUlvONmOZtfzgFzByTB10QgxOR0TqBQejhRNzOfkVJ+5YiUqrXF5Y5lKh/DeuNcP5yLWGsEbtLiOSpa/TPg7JpJHxyendzWTBfX0cxOnKPjgBzi4diinWGdkF8kjdfnycQZXZeYGejmJlZeGl9i2icVqaNVailT6F5iJ90m6mvuTS4OK05M0vDk0Q4XUtwvKOzrcd3iq9uisF81M1OIcR7lEewwcLp7tuNNkM3uNna3F2JQFo97Vriy/Xl4/f1cf5VWzXyym7PHhhx4dbgYKAAA7'"		^ self new		parseFrom: string;		yourself! !!ZnDataUrl class methodsFor: 'instance creation' stamp: '9/23/2025 02:00:26'!text: string	"self text: 'Hello there !!'"		^ self new		mediaType: ZnMimeType textPlain;		data: string;		yourself! !!ZnDataUrl methodsFor: 'comparing' stamp: '9/23/2025 02:00:26'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject ifTrue: [ ^ true ].	self class = anObject class ifFalse: [ ^ false ].	^ mediaType = anObject mediaType and: [		  base64Encoded = anObject isBase64Encoded and: [			  data = anObject data ] ]! !!ZnDataUrl methodsFor: 'initialization' stamp: '9/23/2025 02:00:26'!base64Encoded: boolean	base64Encoded := boolean! !!ZnDataUrl methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!data	"Answer the data that I hold, either a ByteArray or a String"		^ data! !!ZnDataUrl methodsFor: 'initialization' stamp: '9/23/2025 02:00:26'!data: stringOrBytes	data := stringOrBytes! !!ZnDataUrl methodsFor: 'comparing' stamp: '9/23/2025 02:00:26'!hash	"Answer an integer value that is related to the identity of the receiver."	^ mediaType hash bitXor: (base64Encoded hash bitXor: data hash)! !!ZnDataUrl methodsFor: 'initialization' stamp: '9/23/2025 02:00:26'!initialize	super initialize.	mediaType := 'text/plain;charset=ASCII' asZnMimeType.	base64Encoded := false.	data := #[]! !!ZnDataUrl methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!isBase64Encoded	"Am I using Base64 encoding ?"		^ base64Encoded! !!ZnDataUrl methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!isBinary	"Am I binary ?"		^ mediaType isBinary! !!ZnDataUrl methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!isEmpty	^ data isEmpty! !!ZnDataUrl methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!mediaType	"Answer the media type that described my content, a ZnMimeType"		^ mediaType! !!ZnDataUrl methodsFor: 'initialization' stamp: '9/23/2025 02:00:26'!mediaType: mimeType	mediaType := mimeType asZnMimeType! !!ZnDataUrl methodsFor: 'parsing' stamp: '9/23/2025 02:00:26'!parseFrom: string	| commaIndex |	(string beginsWith: 'data:')		ifFalse: [ ^ self error: 'missing data: scheme' ].	(commaIndex := string indexOf: $,) isZero		ifTrue: [ ^ self error: 'missing comma in data: scheme' ].	commaIndex = string size 		ifTrue: [ ^ self ].	commaIndex > 7		ifTrue: [ mediaType := ZnMimeType fromString: (string copyFrom: 6 to: commaIndex - 1) ].	(base64Encoded := mediaType parameters includesKey: 'base64')		ifTrue: [ 			 mediaType removeParameter: 'base64' ].	data := string copyFrom: commaIndex + 1 to: string size.	data := base64Encoded 		ifTrue: [ 			ZnBase64Encoder new				decode: data ]		ifFalse: [			ZnPercentEncoder new 				characterEncoder: mediaType charSet asZnCharacterEncoder;				decode:	data ]! !!ZnDataUrl methodsFor: 'printing' stamp: '9/23/2025 02:00:26'!printOn: stream	stream nextPutAll: 'data:'.	mediaType printOn: stream.	base64Encoded		ifTrue: [ 			stream nextPutAll: ';base64,'.			ZnBase64Encoder new 				encode: data readStream to: stream ]		ifFalse: [			stream nextPut: $,.			ZnPercentEncoder new 				characterEncoder: mediaType charSet asZnCharacterEncoder;				encode: data readStream to: stream ]! !!ZnDataUrl methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!scheme	"Answer my URL scheme"		^ #data! !!ZnOptions class methodsFor: 'options' stamp: '9/23/2025 02:00:26'!acceptStrategy	"The server accept strategy controls how incoming connections are handled.	If set to #unlimited, any incoming connection is accepted, 	but could later on be refused when maximumNumberOfConcurrentConnections is reached, 	in which case the connection is closed after sending a 503 Service Unavailable response.	If set to #limited, incoming connections are accepted as long as maximumNumberOfConcurrentConnections has not yet been reached, 	once it does, incoming connections are no longer accepted and the server waits for existing connections to close.	In this case, 503 Service Unavailable responses are normally not sent."	<znOption>	^ #unlimited! !!ZnOptions class methodsFor: 'utilities' stamp: '9/23/2025 02:00:26' prior: 89793454!definitionOf: key	| implementors options |	implementors := key implementors.	options := implementors select: [ :method |		method method pragmas			anySatisfy: [ :pragma | pragma selector = #znOption ] ].	options ifEmpty: [ self error: 'Not option definition found for ' , key printString ].	options size > 1 ifTrue: [ self error: 'Multiple conflicting option definitions found for ' , key printString ].	^ options first method! !!ZnOptions class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 89798688!globalDefault	^ globalDefault ifNil: [ globalDefault := self root clone ]! !!ZnOptions class methodsFor: 'class initialization' stamp: '9/23/2025 02:00:26' prior: 89796116!initialize	"Changed at 2025-09-10"	self resetGlobalDefault! !!ZnOptions class methodsFor: 'options' stamp: '9/23/2025 02:00:26'!listenBacklogSize	"Server socket listen backlog size.	The number of pending connections queued up, waiting to be accepted, at any one time."		<znOption>	^ 32! !!ZnOptions class methodsFor: 'options' stamp: '9/23/2025 02:00:26' prior: 89799236!maximumEntitySize	"The maximum entity size in bytes that can be read from a stream before ZnEntityTooLarge is signalled.	Entities are the resources transferred by the HTTP procotol. Malicious parties could hurt a client or	server by sending artificially large payloads. Setting a maximum is a protection against this."	<znOption>	^ 16 * 1024 * 1024! !!ZnOptions class methodsFor: 'options' stamp: '9/23/2025 02:00:26'!maximumLineLength	"The maximum line length in bytes that can be read from a stream before ZnLineTooLong is signalled.	This is applicable to each message's first line and each header line. Malicious parties could hurt 	a client or server by sending artificially large lines. Setting a maximum is a protection against this."	<znOption>	^ 4 * 1024! !!ZnOptions class methodsFor: 'options' stamp: '9/23/2025 02:00:26' prior: 89791706!maximumNumberOfConcurrentConnections	"The maximum number of concurrent connections that I will accept.	When this threshold is reached, a 503 Service Unavailable response will be sent	and the connection will be closed. This protects me from certain forms of attacks.	It is possible to raise this number when other system parameters are adjusted as well."	<znOption>	^ 32! !!ZnOptions class methodsFor: 'options' stamp: '9/23/2025 02:00:26'!maximumNumberOfDictionaryEntries	"The maximum number dictionary entries to accept,	before ZnTooManyDictionaryEntries is signalled.	Used by ZnMultiValueDictionary and thus for reading headers,	url query and application form url encoded entity fields.	This helps to protect us from malicious content."	<znOption>	^ 256! !!ZnOptions class methodsFor: 'options' stamp: '9/23/2025 02:00:26' prior: 89794774!myOption	"This is an example option.	This class side method defines the option and its global default value"	<znOption>	^ 'myOptionDefaultValue'! !!ZnOptions class methodsFor: 'instance creation' stamp: '9/23/2025 02:00:26' prior: 89795268!onClass: targetClass	| dictionary |	dictionary := Dictionary new.	(Pragma allNamed: #znOption in: targetClass class)		do: [ :each |			dictionary				at: each method selector				put: (each method methodClass instanceSide perform: each method selector) ].	^ self new		options: dictionary;		writable: false;		yourself! !!ZnOptions class methodsFor: 'options' stamp: '9/23/2025 02:00:26' prior: 89796412!queryKeyValueSafeSet	"When encoding the key/value pairs of a URL or form-url-encoded entity,	the characters part of this safe set are not percent encoded.	Some servers expect more characters to be percent encoded, some less,	in which case this option can be modified."	<znOption>	^ 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_.~!!$''()*,;:@/?'	"When a query is interpreted as a list of key=value&.. pairs,	it is better to encode = and & and leave them out of the safe set.	Furthermore, since + is interpreted as space in the query part,	it is unsafe as well. This is a restriction of #querySafeSet"! !!ZnOptions class methodsFor: 'class initialization' stamp: '9/23/2025 02:00:26' prior: 89794520!resetGlobalDefault	globalDefault := nil! !!ZnOptions class methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89799010!root	^ self onClass: self! !!ZnOptions class methodsFor: 'options' stamp: '9/23/2025 02:00:26' prior: 89797850!serverString	"The string a server uses in the Server header of responses to identify itself.	To provide malicious parties as little information as possible it could make sense to overwrite this.	Also, to idenitify yourself as a specific server, you could use its server string."	<znOption>	^ ZnConstants defaultServerString! !!ZnOptions class methodsFor: 'options' stamp: '9/23/2025 02:00:26' prior: 89791058!signalProgress	"Boolean indicating if HTTPProgress notifications are signalled during the transfer of HTTP resources.	Although unhandled notifications are harmless, it is a bit more efficient not to signal them."	<znOption>	^ false! !!ZnOptions class methodsFor: 'options' stamp: '9/23/2025 02:00:26'!socketStreamTimeout	"The timeout in seconds for network socket stream operations like connecting, reading and writing."	<znOption>	^ 30! !!ZnOptions class methodsFor: 'options' stamp: '9/23/2025 02:00:26' prior: 89792642!userAgentString	"The value a client uses in the User-Agent header of requests to identify itself.	To provide as little information to a server it could make sense to overwrite this.	Also to idenitify yourself as a specific client, you could use its user agent string."	<znOption>	^ ZnConstants defaultUserAgent! !!ZnOptions class methodsFor: 'options' stamp: '9/23/2025 02:00:26'!verifyCertificates	"Boolean indicating if TLS/SSL certificates should be verified.	When true, ZnCertificateVerificationFailed could be signalled."	<znOption>	^ false! !!ZnOptions methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 89786572!allBindings	| bindings |	bindings := Dictionary new.	parent ifNotNil: [		parent allBindings keysAndValuesDo: [ :key :value |			bindings at: key put: value ] ].	options ifNotNil: [		options keysAndValuesDo: [ :key :value |			bindings at: key put: value ] ].	^ bindings! !!ZnOptions methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 89789426!at: key	options ifNotNil: [ options at: key ifPresent: [ :value | ^ value ] ].	^ parent		ifNil: [ KeyNotFound signalFor: key in: self ]		ifNotNil: [ parent at: key ]! !!ZnOptions methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 89790232!at: key put: value	writable		ifFalse: [ (ModificationForbidden				for: self				at: key				with: value				retrySelector: #at:put:) signal ].	(parent isNotNil and: [ parent includesKey: key ])		ifFalse: [ KeyNotFound signalFor: key in: self ].	options ifNil: [ options := Dictionary new ].	^ options at: key put: value! !!ZnOptions methodsFor: 'copying' stamp: '9/23/2025 02:00:26' prior: 89789926!clone	^ (self class new)		parent: self;		writable: true;		yourself! !!ZnOptions methodsFor: 'execution' stamp: '9/23/2025 02:00:26' prior: 89787288!conditionallyDuring: block	^ ZnCurrentOptions value		ifNil: [ ZnCurrentOptions value: self during: block ]		ifNotNil: block! !!ZnOptions methodsFor: 'execution' stamp: '9/23/2025 02:00:26' prior: 89785786!during: block	^ ZnCurrentOptions value: self during: block! !!ZnOptions methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89787702!includesKey: key	^ (options isNotNil and: [ options includesKey: key ])		or: [ parent isNotNil and: [ parent includesKey: key ] ]! !!ZnOptions methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89788126!options: dictionary	options		ifNotNil: [ (ModificationForbidden				for: self				at: nil				with: dictionary				retrySelector: #options:) signal ].	options := dictionary! !!ZnOptions methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89788638!parent: otherOptions	parent		ifNotNil: [ (ModificationForbidden				for: self				at: nil				with: otherOptions				retrySelector: #parent:) signal ].	parent := otherOptions! !!ZnOptions methodsFor: 'initialization' stamp: '9/23/2025 02:00:26' prior: 89789168!reset	options ifNotNil: [ options removeAll ]! !!ZnOptions methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89786066!writable: boolean	writable		ifNotNil: [ (ModificationForbidden				for: self				at: nil				with: boolean				retrySelector: #writable:) signal ].	writable := boolean! !ZnMaximumNumberOfDictionaryEntries removeSelector: #default!Smalltalk globals removeClassNamed: #AnObsoleteZnMaximumNumberOfDictionaryEntries!"Zinc-Resource-Meta-Core"!!ZnDataUrlTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26'!testABriefNote	| dataUrl |	dataUrl := ZnDataUrl fromString: 'data:,A%20brief%20note'.	self assert: dataUrl data equals: 'A brief note'.	self deny: dataUrl isBase64Encoded.! !!ZnDataUrlTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26'!testBinary	self		assert: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream')		equals: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream').	self		assert: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream') hash		equals: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream') hash.	self		assert: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream') printString		equals: (ZnDataUrl bytes: #[1 2 3] type: 'application/octet-stream') printString! !!ZnDataUrlTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26'!testBinaryAll	| dataUrl |	dataUrl := ZnDataUrl new.	dataUrl data: (0 to: 255) asByteArray.	dataUrl mediaType: ZnMimeType applicationOctetStream.	dataUrl base64Encoded: true.	self assert: dataUrl data equals: (0 to: 255) asByteArray.	self assert: dataUrl isBase64Encoded.	self assert: dataUrl mediaType equals: ZnMimeType applicationOctetStream.	self assert: (ZnDataUrl fromString: dataUrl printString) data equals: (0 to: 255) asByteArray! !!ZnDataUrlTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26'!testEmpty	| dataUrl |	dataUrl := ZnDataUrl new.	self assert: dataUrl isEmpty.	self assert: dataUrl scheme equals: #data.	self assert: ('text/plain' asZnMimeType matches: dataUrl mediaType).	self assert: dataUrl equals: ZnDataUrl new! !!ZnDataUrlTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26'!testGreek	| dataUrl |	dataUrl := ZnDataUrl fromString: 'data:text/plain;charset=iso-8859-7,%e1%f8%e2'.	self assert: dataUrl data equals: ''.	self deny: dataUrl isBase64Encoded.	self assert: (dataUrl printString sameAs: 'data:text/plain;charset=iso-8859-7,%e1%f8%e2')! !!ZnDataUrlTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26'!testParseMinimal	| dataUrl |	dataUrl := ZnDataUrl fromString: 'data:,'.	self assert: dataUrl isEmpty.	self assert: dataUrl scheme equals: #data.	self assert: ('text/plain' asZnMimeType matches: dataUrl mediaType).! !!ZnDataUrlTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26'!testPng	| logoPngBytes dataUrl representation |	logoPngBytes := PolymorphSystemSettings pharoLogoContents base64Decoded.	dataUrl := ZnDataUrl bytes: logoPngBytes type: ZnMimeType imagePng.	representation := dataUrl printString.	dataUrl := ZnDataUrl fromString: representation.	self assert: dataUrl data equals: logoPngBytes ! !!ZnDataUrlTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26'!testSimpleBinary	| dataUrl |	dataUrl := ZnDataUrl new.	dataUrl data: #[ 0 1 2 3 4 5 6 7 8 9 ].	dataUrl mediaType: ZnMimeType applicationOctetStream.	dataUrl base64Encoded: true.	self assert: dataUrl data equals: #[ 0 1 2 3 4 5 6 7 8 9 ].	self assert: dataUrl isBase64Encoded.	self assert: dataUrl mediaType equals: ZnMimeType applicationOctetStream! !!ZnDataUrlTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26'!testSimpleString	| dataUrl |	dataUrl := ZnDataUrl new.	dataUrl data: 'foo'.	self assert: dataUrl data equals: 'foo'! !!ZnDataUrlTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26'!testSmallGif	| dataUrl |	dataUrl := ZnDataUrl fromString: 'data:image/gif;base64,R0lGODdhMAAwAPAAAAAAAP///ywAAAAAMAAwAAAC8IyPqcvt3wCcDkiLc7C0qwyGHhSWpjQu5yqmCYsapyuvUUlvONmOZtfzgFzByTB10QgxOR0TqBQejhRNzOfkVJ+5YiUqrXF5Y5lKh/DeuNcP5yLWGsEbtLiOSpa/TPg7JpJHxyendzWTBfX0cxOnKPjgBzi4diinWGdkF8kjdfnycQZXZeYGejmJlZeGl9i2icVqaNVailT6F5iJ90m6mvuTS4OK05M0vDk0Q4XUtwvKOzrcd3iq9uisF81M1OIcR7lEewwcLp7tuNNkM3uNna3F2JQFo97Vriy/Xl4/f1cf5VWzXyym7PHhhx4dbgYKAAA7'.	self assert: dataUrl mediaType equals: ZnMimeType imageGif.	self deny: dataUrl isEmpty.	self assert: dataUrl isBase64Encoded.	ImageReadWriter formFromStream: dataUrl data readStream.	self assert: dataUrl printString equals: 'data:image/gif;base64,R0lGODdhMAAwAPAAAAAAAP///ywAAAAAMAAwAAAC8IyPqcvt3wCcDkiLc7C0qwyGHhSWpjQu5yqmCYsapyuvUUlvONmOZtfzgFzByTB10QgxOR0TqBQejhRNzOfkVJ+5YiUqrXF5Y5lKh/DeuNcP5yLWGsEbtLiOSpa/TPg7JpJHxyendzWTBfX0cxOnKPjgBzi4diinWGdkF8kjdfnycQZXZeYGejmJlZeGl9i2icVqaNVailT6F5iJ90m6mvuTS4OK05M0vDk0Q4XUtwvKOzrcd3iq9uisF81M1OIcR7lEewwcLp7tuNNkM3uNna3F2JQFo97Vriy/Xl4/f1cf5VWzXyym7PHhhx4dbgYKAAA7'! !!ZnDataUrlTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26'!testText	self 		assert: (ZnDataUrl text: 'Les lves Franais')		equals: (ZnDataUrl text: 'Les lves Franais').	self 		assert: (ZnDataUrl text: 'Les lves Franais') hash		equals: (ZnDataUrl text: 'Les lves Franais') hash.	self 		assert: (ZnDataUrl text: 'Les lves Franais') printString		equals: (ZnDataUrl text: 'Les lves Franais') printString! !!ZnOptionsTest class methodsFor: 'options' stamp: '9/23/2025 02:00:26' prior: 89808438!bar	"Test option bar"	<znOption>	^ 2! !!ZnOptionsTest class methodsFor: 'options' stamp: '9/23/2025 02:00:26' prior: 89808702!foo	"Test option foo"	<znOption>	^ 1! !!ZnOptionsTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26' prior: 89802524!testAllBindings	| options |	options := (ZnOptions onClass: self class) clone.	self assert: options allBindings equals: { #foo -> 1. #bar -> 2 } asDictionary.	options at: #foo put: -1.	self assert: options allBindings equals: { #foo -> -1. #bar -> 2 } asDictionary.	options := options clone.	options at: #bar put: -2.	self assert: options allBindings equals: { #foo -> -1. #bar -> -2 } asDictionary.! !!ZnOptionsTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26' prior: 89800106!testClone	| options |	options := (ZnOptions onClass: self class) clone.	self assert: (options at: #foo) equals: 1.	self assert: (options at: #bar) equals: 2.	options at: #foo put: -1.	self assert: (options at: #foo) equals: -1.	self should: [ options at: #xyz ] raise: KeyNotFound.	self should: [ options at: #xyz put: -1 ] raise: KeyNotFound.	options reset.	self assert: (options at: #foo) equals: 1.! !!ZnOptionsTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26' prior: 89803502!testCreate	| options |	options := ZnOptions onClass: self class.	self assert: (options at: #foo) equals: 1.	self assert: (options at: #bar) equals: 2.	self assert: (options includesKey: #foo).	self should: [ options at: #foo put: 0 ] raise: ModificationForbidden.	self should: [ options at: #xyz ] raise: KeyNotFound.	self should: [ options at: #xyz put: -1 ] raise: ModificationForbidden.	self should: [ options writable: true ] raise: ModificationForbidden! !!ZnOptionsTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26' prior: 89807444!testCurrent	| options |	self should: [ ZnCurrentOptions at: #foo ] raise: KeyNotFound.	options := (ZnOptions onClass: self class) clone.	self assert: (options at: #foo) equals: 1.	options during: [		self assert: (ZnCurrentOptions at: #foo) equals: 1 ].	options clone		at: #foo put: -1;		during: [			self assert: (ZnCurrentOptions at: #foo) equals: -1 ].	self assert: (options at: #foo) equals: 1! !!ZnOptionsTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26' prior: 89801094!testCurrentConditionally	| options |	self should: [ ZnCurrentOptions at: #foo ] raise: KeyNotFound.	options := (ZnOptions onClass: self class) clone.	self assert: (options at: #foo) equals: 1.	options conditionallyDuring: [		self assert: (ZnCurrentOptions at: #foo) equals: 1 ].	options clone		at: #foo put: -1;		conditionallyDuring: [			self assert: (ZnCurrentOptions at: #foo) equals: -1 ].	options clone		at: #foo put: -1;		conditionallyDuring: [			options clone				at: #foo put: 0;				conditionallyDuring: [					self assert: (ZnCurrentOptions at: #foo) equals: -1 ] ].	self assert: (options at: #foo) equals: 1.! !!ZnOptionsTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26' prior: 89804602!testPublicAPI	| localOptions originalValue |	localOptions := ZnOptions globalDefault clone.	originalValue := ZnOptions globalDefault at: #signalProgress.	"Access an option, anywhere"	self assert: (ZnCurrentOptions at: #signalProgress) equals: originalValue.	"Set a global writable option, visible to anyone"	ZnOptions globalDefault at: #signalProgress put: originalValue not.	self assert: (ZnCurrentOptions at: #signalProgress) equals: originalValue not.	ZnOptions globalDefault at: #signalProgress put: originalValue.	"Access an option, using local option, unless set dynamically"	localOptions conditionallyDuring: [		self assert: (ZnCurrentOptions at: #signalProgress) equals: originalValue ].	"Access an option, using local option, unless set dynamically, when set locally"	localOptions at: #signalProgress put: originalValue not.	localOptions conditionallyDuring: [		self assert: (ZnCurrentOptions at: #signalProgress) equals: originalValue not ].	"Access an option, using local option, unless set dynamically, when set locally,	but again overwritten dynamically"	localOptions at: #signalProgress put: originalValue not.	localOptions clone		at: #signalProgress put: originalValue;		during: [			localOptions conditionallyDuring: [				self assert: (ZnCurrentOptions at: #signalProgress) equals: originalValue ] ]! !!ZnMimeTypeTest methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 89690642!someNonBinaryMimeTypes	^ #(		'text/plain;charset=ascii'		'application/json;charset=utf-8'		'application/ston'		'application/vnd.com.runkeeper.user+json;charset=ISO-8859-1'		'application/xml-dtd'		'application/xslt+xml'		'image/svg+xml'		'application/SGML'		'model/x3d+xml'		'application/csv'		'application/x-ndjson')! !!ZnMultiValueDictionaryTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89743034!testDynamicLimit	ZnOptions globalDefault clone		at: #maximumNumberOfDictionaryEntries put: 10;		during: [			| dictionary |			dictionary := ZnMultiValueDictionary new.			self assert: dictionary limit equals: 10.			1 to: 10 do: [ :each | dictionary at: each put: each ].			self				should: [ dictionary at: 11 put: 11 ]				raise: ZnTooManyDictionaryEntries ]! !!ZnUrlTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 90389638!testQueryAccessing	| url |	url := 'http://www.google.com/?one=1&two=2' asZnUrl.	self assert: url hasQuery.	self assert: url queryKeys sorted equals: #('one' 'two').	self assert: (url queryAt: 'two' ifAbsent: [ self fail ]) equals: '2'.	self assert: (url queryAt: 'three' ifAbsent: [ #missing ]) equals: #missing.	url queryAt: 'one' ifPresent: [ :value | self assert: value equals: '1' ].	self assert: (url queryAt: 'three' ifPresent: [ :value | self fail ]) isNil! !!ZnUrlTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 90404382!testQueryManipulation	| url |	url := 'http://www.google.com/?one=1&two=2' asZnUrl.	url queryAt: 'three' put: '3'.	url queryRemoveKey: 'one'.	self assert: url queryKeys sorted equals: #('three' 'two').	self assert: (url queryAt: 'two') equals: '2'.	self assert: (url queryAt: 'three') equals: '3'.	url queryRemoveAll.	self deny: url hasQuery! !"Zinc-Resource-Meta-Tests"!!ZnCertificateVerificationFailed commentStamp: '<historical>' prior: 0!ZnCertificateVerificationFailed is signalled when an SSL/TLS connection has an invalid certificate.See ZdcPluginSSLSession>>#certificateVerificationStatePart of Zinc HTTP Components.!!ZnTooManyRedirects commentStamp: '<historical>' prior: 90234844!ZnTooManyRedirects is signalled when an HTTP client has been following more redirects than allowed.The default resume behavior is to retry, signal with any other value to give up just return the redirect.Part of Zinc HTTP Components. !!ZnClientTransactionEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 89161638!printContentsOn: stream	super printContentsOn: stream.	request requestLine printMethodAndUriOn: stream.	stream space; print: response code.	response hasEntity		ifTrue: [			stream space; print: response entity contentLength; nextPut: $B ].	stream space; print: self duration; nextPutAll: 'ms'! !!ZnServerStartedEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 90031250!printContentsOn: stream	super printContentsOn: stream.	description ifNotNil: [ stream << 'Started '; << description ]! !!ZnServer methodsFor: 'options' stamp: '9/23/2025 02:00:26'!acceptStrategy: strategy	"Set the server accept strategy that controls how incoming connections are handled.	If set to #unlimited, any incoming connection is accepted, 	but could later on be refused when maximumNumberOfConcurrentConnections is reached, 	in which case the connection is closed after sending a 503 Service Unavailable response.	If set to #limited, incoming connections are accepted as long as maximumNumberOfConcurrentConnections has not yet been reached, 	once it does, incoming connections are no longer accepted and the server waits for existing connections to close.	In this case, 503 Service Unavailable responses are normally not sent."	self assert: (#(limited unlimted) includes: strategy).	self localOptions at: #acceptStrategy put: strategy! !!ZnServer methodsFor: 'options' stamp: '9/23/2025 02:00:26' prior: 89981002!delegate	"Return the optional delegate,	the object that will be sent #handleRequest: to handle a request and produce a response.	The default delegate is ZnDefaultServerDelegate"	^ self 		optionAt: #delegate		ifAbsentPut: [ ZnDefaultServerDelegate new server: self; yourself ]! !!ZnServer methodsFor: 'options' stamp: '9/23/2025 02:00:26'!listenBacklogSize: integer	"Set my server socket listen backlog size, the number of pending connections queued up, waiting to be accepted, at any one time."	self localOptions at: #listenBacklogSize put: integer! !!ZnServer methodsFor: 'options' stamp: '9/23/2025 02:00:26'!maximumLineLength: integer	"Set the maximum line length in bytes that I will read from a stream before signalling ZnLineTooLong"	self localOptions at: #maximumLineLength put: integer! !!ZnServer methodsFor: 'options' stamp: '9/23/2025 02:00:26' prior: 89978402!maximumNumberOfDictionaryEntries: anInteger	"Set the maximum number of entries allowed in ZnMutliValueDictionaries before signalling ZnTooManyDictionaryEntries. This protects us from overflow attacks."	self localOptions at: #maximumNumberOfDictionaryEntries put: anInteger! !!ZnServer methodsFor: 'public' stamp: '9/23/2025 02:00:26'!stopServer	"Stop me. I will stop listening on my port for incoming HTTP connections.	Does nothing when I am not running"	self stopServer: true! !!ZnServer methodsFor: 'public' stamp: '9/23/2025 02:00:26'!stopServer: unregister	"Stop me. I will stop listening on my port for incoming HTTP connections.	If unregister is true, unregister me from the list of managed instances.	Does nothing when I am not running"	self subclassResponsibility! !!ZnServer methodsFor: 'options' stamp: '9/23/2025 02:00:26'!timeout: seconds	"Set the timeout for network socket stream operations	like connecting, reading and writing to seconds."	self localOptions at: #socketStreamTimeout put: seconds! !!ZnChunkedReadStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88951316!close	stream ifNotNil: [ stream close. stream := nil ]! !!ZnChunkedReadStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88951622!on: readStream	stream := readStream! !!ZnBivalentWriteStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88635560!close	stream close! !!ZnBivalentWriteStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88636016!on: writeStream	stream := writeStream! !!ZnBivalentWriteStream methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!print: object	object printOn: self! !!ZnClientIgnoringExceptionOnConnectionReuseEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 89094438!printContentsOn: stream	super printContentsOn: stream.	stream << 'Ignoring Exception On Connection Reuse '; print: exception! !!ZnRequestResponseHandledEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 89910118!printContentsOn: stream	super printContentsOn: stream.	stream << 'Request Handled '; print: request; space; print: duration; << 'ms'! !!ZnHeaders methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89442026!readFrom: stream	| line reader |	reader := ZnLineReader on: stream.	[ (line := reader nextLine) isEmpty ] whileFalse: [ | key |		key := self readOneHeaderFrom: line readStream.		"Continuation header lines start with a space or tab"		[ stream atEnd not and: [ #[ 32 9 ] includes: stream peek asInteger ] ]			whileTrue: [				self extendHeaderAt: key from: reader nextLine ] ]! !!ZnHeaders methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89444334!unlimited	self headers unlimited! !!ZnClientFollowingRedirectEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 89092638!printContentsOn: stream	super printContentsOn: stream.	stream << 'Following Redirect '; print: target! !!ZnRequest methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89881968!method: method	self requestLine method: method! !!ZnRequest methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89884062!readHeaderFrom: stream	self requestLine: (ZnRequestLine readFrom: stream).	super readHeaderFrom: stream! !!ZnRequest methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89891500!url: url	self requestLine uri: url.	self headers request: self url! !!ZnRequestWrittenEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 89922324!printContentsOn: stream	super printContentsOn: stream.	stream << 'Request Written '; print: request; space; print: duration; << 'ms'! !!ZnUtils class methodsFor: 'converting' stamp: '9/23/2025 02:00:26'!exceptionSet: classNames	^ classNames inject: ExceptionSet new into: [ :set :each |		  (Smalltalk globals includesKey: each)			  ifTrue: [				  set					  add: (Smalltalk at: each);					  yourself ]			  ifFalse: [ set ] ]! !!ZnUtils class methodsFor: 'converting' stamp: '9/23/2025 02:00:26' prior: 90424914!parseHttpDate: string	"self parseHttpDate: 'Tue, 13 Sep 2011 08:04:49 GMT'."	"self parseHttpDate: 'Tue, 13-Sep-2011 08:04:51 GMT'."	"self parseHttpDate: 'Tue Jan 01 00:00:01 2036 GMT'."	| tokens day month year hour minute second months map yearToken |	tokens := (string findTokens: #( $ $- $: $, )) allButFirst.	tokens last = 'GMT' ifTrue: [ tokens := tokens allButLast ].	months := #('jan' 'feb' 'mar' 'apr' 'may' 'jun' 'jul' 'aug' 'sep' 'oct' 'nov' 'dec').	(Integer readFrom: tokens first ifFail: [ 0 ]) isZero		ifTrue: [ map := #(2 1 6 3 4 5) ]		ifFalse: [ map := #(1 2 3 4 5 6) ].	day := Integer readFrom: (tokens at: map first) ifFail: [ 0 ].	month := months indexOf: (((tokens at: map second) asLowercase) copyFrom: 1 to: 3) ifAbsent: [ 0 ].	yearToken := tokens at: map third.	year := yearToken isAllDigits		ifTrue: [			year := yearToken asNumber.			yearToken size = 2				ifTrue: [					year < 50						ifTrue: [ year + 2000 ]						ifFalse: [ year + 1900 ] ]				ifFalse: [ year ] ]		ifFalse: [ 0 ].	hour := Integer readFrom: (tokens at: map fourth) ifFail: [ 0 ].	minute := Integer readFrom: (tokens at: map fifth) ifFail: [ 0 ].	second := Integer readFrom: (tokens at: map sixth) ifFail: [ 0 ].	^ DateAndTime year: year month: month day: day hour: hour minute: minute second: second offset: Duration zero! !!ZnUtils class methodsFor: 'streaming' stamp: '9/23/2025 02:00:26' prior: 90437956!signalProgress: amount total: total	(ZnCurrentOptions at: #signalProgress)		ifTrue: [			total				ifNil: [					HTTPProgress new						signal: ('Transferred {1} bytes ...' format: { amount humanReadableSIByteSize }) ]				ifNotNil: [					HTTPProgress new						total: total;						amount: amount;						signal: 'Transferring...' ] ]! !!ZnDefaultServerDelegate methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!bootTime	"When did I become active, i.e. when did my server start me.	This value resets when I am closed by my server.	Returns nil when I am not yet started."	^ bootTime! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26'!brandedPage: title do: block	"Helper to generate uniform HTML pages"	^ ZnHtmlOutputStream streamContents: [ :html |		html html5; tag: #html do: [			html				tag: #head do: [					html tag: #title with: title.					self inlineCssOn: html ];				tag: #body do: [					html tag: #a attributes: #(id logo href '/') with: #Zn.					html tag: #h1 with: title.					block cull: html ] ] ]! !!ZnDefaultServerDelegate methodsFor: 'responses' stamp: '9/23/2025 02:00:26' prior: 89243008!bytes: request	"Answer a number of bytes according to a fixed non random pattern as an application/octet-stream.	Optionally take the size from the URI, as in /bytes/32 for 32 bytes, default to 64 bytes.	A newline is added at the end."	| count byteArray |	count := Integer readFrom: request uri lastPathSegment ifFail: [ 64 ].	byteArray := ByteArray new: count.	1 to: count - 1 do: [ :each |		byteArray at: each put: (#(65 66 67 68) at: (each \\ 4 + 1)) ].	byteArray at: count put: 10.	^ ZnResponse ok: (ZnEntity bytes: byteArray)! !!ZnDefaultServerDelegate methodsFor: 'initialization' stamp: '9/23/2025 02:00:26'!close	"Reset my boot time"	bootTime := nil! !!ZnDefaultServerDelegate methodsFor: 'responses' stamp: '9/23/2025 02:00:26'!echoRequestHtml: request	"Echo the incoming request"	| page entity |	page := self generateEchoRequest: request.	entity := ZnEntity html: page.	^ ZnResponse ok: entity! !!ZnDefaultServerDelegate methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!extraWelcomeText	"Optional extra welcome text to add to the welcome page."	^ extraWelcomeText! !!ZnDefaultServerDelegate methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!extraWelcomeText: string	"Set the optional extra welcome text to add to the welcome page to string"		extraWelcomeText := string! !!ZnDefaultServerDelegate methodsFor: 'responses' stamp: '9/23/2025 02:00:26' prior: 89239302!formTest1: request	| input page |	input := request uri queryAt: #input ifAbsent: [ 'input' ].	page := self brandedPage: 'Form Test 1' do: [ :html |		html			tag: #form			attributes: #(action 'form-test-1' 'accept-charset' 'utf-8' method GET)			do: [				html					str: 'Input'; space;					tag: #input attributes: { #type. #input. #name. #input. #value. input }; space;					tag: #input attributes: #(type submit);					str: 'for input'; space; tag: #em with: input ] ].	^ ZnResponse ok: (ZnEntity html: page)! !!ZnDefaultServerDelegate methodsFor: 'responses' stamp: '9/23/2025 02:00:26' prior: 89233198!formTest2: request	| input page |	input := 'input'.	(request hasEntity and: [ request contentType matches: ZnMimeType applicationFormUrlEncoded  ])		ifTrue: [ input := request entity at: 'input' ifAbsent: [ 'input' ] ].	page := self brandedPage: 'Form Test 2' do: [ :html |		html			tag: #form			attributes: #(action 'form-test-2' 'accept-charset' 'utf-8' method POST)			do: [				html					str: 'Input'; space;					tag: #input attributes: { #type. #input. #name. #input. #value. input }; space;					tag: #input attributes: #(type submit);					str: 'for input'; space; tag: #em with: input ] ].	^ ZnResponse ok: (ZnEntity html: page)! !!ZnDefaultServerDelegate methodsFor: 'responses' stamp: '9/23/2025 02:00:26' prior: 89224330!formTest3: request	| contents filename contentType page |	contents := filename := contentType := ''.	(request hasEntity and: [ request contentType matches: ZnMimeType multiPartFormData ])		ifTrue: [			(request entity partNamed: 'file' ifNone: [ nil ])				ifNotNil: [ :part |					filename := part fileName.					contents := part contents.					contentType := part  contentType.					contentType isBinary ifTrue: [ contents := contents hex ] ] ].	page := self brandedPage: 'Form Test 3' do: [ :html |		html			tag: #form			attributes: #(action 'form-test-3' 'accept-charset' 'utf-8'								enctype 'multipart/form-data' method POST)			do: [				html					str: 'File'; space;					tag: #input attributes: #(type file name file); space;					tag: #input attributes: #(type submit) ];			tag: #p do: [ html str: 'filename = '; str: filename ];			tag: #p do: [ html str: 'content-type = '; str: contentType asString ];			tag: #p do: [ html str: 'contents = '; str: contents asString ] ].	^ ZnResponse ok: (ZnEntity html: page)! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89246208!generateDWBench	"Generate the dynamic DW-Bench HTML page.	Although the date/time is variable, the page size is constant."	^ self brandedPage: 'DW-Bench' do:  [ :html |		html tag: #table attributes: #(border 1 style 'border-collapse:collapse') do: [			1 to: 25 do: [ :row |				html tag: #tr do: [					1 to: 25 do: [ :col |						html tag: #td do: [ html print: row * col ] ] ] ] ].		html tag: #h4 do: [			html << Date today yyyymmdd; space; << Time now print24 ] ]! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26'!generateEchoRequest: request	"Generate a page echoing the incoming request"	^ self brandedPage: 'Request' do: [ :html |		html tag: #p with: 'This is Zinc HTTP Components echoing your request.'.		html tag: #p with: ('Running {1}' format: { request server } ).		html tag: #p with: ('{1} {2} {3}' format: { request method . request uri pathQueryFragmentPrintString . request requestLine version }).				html tag: #h4 with: 'Headers'.		html tag: #ul do: [			request headersDo: [ :key :value |				html tag: #li do: [					html tag: #span attributes: #(style 'color:grey') do: [ html str: key; str: ':' ].					html str: value ] ] ].		request hasEntity ifTrue: [			html tag: #h4 with: 'Body'.			html tag: #p with: request entity printString ] ] ! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89229378!generateEchoRequestString: request	"Generate a string echoing the request"	^ String streamContents: [ :stream |		stream nextPutAll: 'This is Zinc HTTP Components echoing your request.'; crlf.		stream nextPutAll: 'Running '; print: request server; crlf.		stream nextPutAll: request method; space.		request uri printPathQueryFragmentOn: stream.		stream space; nextPutAll: request requestLine version.		stream crlf; nextPutAll: 'Headers'; crlf.		request headersDo: [ :key :value |			stream space; nextPutAll: key; nextPutAll: ': '; nextPutAll: value; crlf ].		request hasEntity ifTrue: [			stream nextPutAll: ' containing '; print: request entity ] ]! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89251534!generateHelp	"Generate an HTML page with links to all routes that I support"	^ self brandedPage: 'Available Routes' do: [ :html |		html tag: #ul do: [			prefixMap keys sorted do: [ :each |				html tag: #li do: [					html tag: #a attributes: { #href . each } with: each ] ] ] ]! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89226680!generateSessionRequest: session	"Generate an HTML page using a session"	^ self brandedPage: 'Session' do: [ :html |		html tag: #p do: [ html << 'I am using '; str: session asString ].		html tag: #p do: [ html << 'Current session id is ' << session id ].		html tag: #p do: [ html << 'Session hit count ' << (session attributeAt: #hitCount) asString ] ]! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89230832!generateStatus	"Generate an HTML page with the state of the server"	^ self brandedPage: 'ZnServer Status' do: [ :html |		html tag: #p do: [ html << 'I am '; print: ZnCurrentServer value ].		html tag: #ul do: [ 			html tag: #li with: self serverVersion.			html tag: #li with: self uptime.			html tag: #li with: self memoryStatistics.			html tag: #li with: self serverClock ].		html tag: #h1 with: 'Processes'.		self processesOn: html ]! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89240610!generateUnicodeTest	"Generate an HTML page containing all Unicode characters with code points between 0 and 16r024F in a nice table"	^ self brandedPage: 'Unicode Test Page' do: [:html |		html tag: #table do: [			0 to: 16r024F by: 8 do: [ :row |				html tag: #tr do: [					row to: row + 7 do: [ :each |						html tag: #td do: [ | unicodeNotation |							unicodeNotation := 'U+{1}' format: { each printPaddedWith: $0 to: 4 base: 16 }.							html 								tag: #span attributes: #(style 'color:grey') with: unicodeNotation;								space;								tag: #span attributes: #(style 'font-weight:bold') with: each asCharacter asString ] ] ] ] ] ]! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89228174!generateWelcomePage	"Generate the HTML for the welcome page"	^ self brandedPage: 'Zinc HTTP Components' do: [ :html |		html tag: #p do: [ 			($\ split: self welcomePageGreeting)				do: [ :each | html str: each ] 				separatedBy: [ html tag: #br ] ].		self welcomePageLinksOn: html.		self extraWelcomeText 			ifNotNil: [ :string | html tag: #p with: string ].		html tag: #h4 with: 'May the Source be with you!!' ]! !!ZnDefaultServerDelegate methodsFor: 'initialization' stamp: '9/23/2025 02:00:26' prior: 89234776!initialize	super initialize.	self		map: 'welcome' to: #welcome:;		map: 'help' to: #help:;		map: 'echo' to: #echoRequest:;		map: 'echo-html' to: #echoRequestHtml:;		map: 'small' to: #small:;		map: 'dw-bench' to: #dwbench:;		map: 'favicon.ico' to: #favicon:;		map: 'random' to: #random:;		map: 'bytes' to: #bytes:;		map: 'status' to: #status:;		map: 'unicode' to: #unicode:;		map: 'session' to: #sessionRequest:;		map: 'error' to: #errorResponse:;		map: 'form-test-1' to: #formTest1:;		map: 'form-test-2' to: #formTest2:;		map: 'form-test-3' to: #formTest3:;		map: 'routes' to: #help:;		map: '/' to: 'welcome'! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26'!inlineCss	"Return the CSS text for inline inclusion in our branded pages"	^ Character space join:	'body { color: black; background: white; width: 900px; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 16px }p { width: 800px; padding: 0 20px 10px 20px }ul, ol { width: 800px; padding: 0 5px 5px 30px }#logo { color: orange; font-family: Helvetica, sans-serif; font-weight: bold; font-size: 128px; text-decoration: none }' lines! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26'!inlineCssOn: html	"Insert our inline CSS"	html		tag: #style		attributes: #( type 'text/css' )		with: self inlineCss! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26'!memoryStatistics	| memoryTotal memoryFree |	memoryTotal := Smalltalk vm memorySize.	memoryFree := Smalltalk vm freeOldSpaceSize + Smalltalk vm edenSpaceSize - Smalltalk vm youngSpaceSize.	^ 'Memory: allocated {1} bytes - {2} % free' format: { 			memoryTotal asStringWithCommas. 			( memoryFree / memoryTotal * 100.0) printShowingDecimalPlaces: 2 }! !!ZnDefaultServerDelegate methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 89232154!prefixMap	"Return my prefix map, with each prefix key mapped to its handler value.	A handler is either a block or one of my methods, taking the request as argument."	^ prefixMap ifNil: [ prefixMap := Dictionary new ]! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26'!process: process on: html	"Render a processes on html"		html 		str: process name; space; 		nextPut: $[; print: process priority; nextPut: $]! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89247372!processes	^ (Process allSubInstances		reject: [ :each | each isTerminated ])		sorted: #priority descending , #name ascending ! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26'!processesOn: html	"Render a the list of processes on html"		html tag: #ol do: [		self processes do: [ :each |			html tag: #li do: [				each = Processor activeProcess 					ifTrue: [ 						html tag: #b do: [							self process: each on: html.							html space; nextPut: $* ] ]					ifFalse: [ 						self process: each on: html  ] ] ] ]! !!ZnDefaultServerDelegate methodsFor: 'responses' stamp: '9/23/2025 02:00:26' prior: 89250342!random: request	"Answer a text plain UTF-8 encoded string of random hex characters.	Optionally take the size from the URI, as in /random/32 for 32 characters.	Default to 64 characters with a newline at the end.	We use a much faster 32-bit naive local integer only PRNG (a Lehmer / Park-Miller variant)"	| count hexString randomState |	count := Integer readFrom: request uri lastPathSegment ifFail: [ 64 ].	randomState := (2 ** 32) atRandom.	hexString := String new: count.	1 to: count - 1 do: [ :each |		hexString at: each put: ('0123456789ABCDEF' at: (randomState \\ 16) + 1).		randomState := randomState * 48271 \\ 16r7fffffff ].	hexString at: count put:	Character lf.	^ ZnResponse ok: (ZnEntity text: hexString)! !!ZnDefaultServerDelegate methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!server	"Return the ZnServer I was configured with, the one I am the delegate for"		^ server! !!ZnDefaultServerDelegate methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!server: znServer	"Set my server to snServer, the one I am the delegate for"		server := znServer! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26'!serverClock	| now |	now := DateAndTime now asUTC.	^ 'Server clock: {1}T{2}Z' format: { now asDate yyyymmdd . now asTime print24 }! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26'!serverVersion	^ 'Version: {1}' format: { ZnConstants defaultServerString }! !!ZnDefaultServerDelegate methodsFor: 'responses' stamp: '9/23/2025 02:00:26' prior: 89223730!small: request	"Answer a small HTML page"	| page |	page := self brandedPage: 'Small' do: [ :html |		html tag: #p with: 'This is a small HTML document' ].	^ ZnResponse ok: (ZnEntity html: page)! !!ZnDefaultServerDelegate methodsFor: 'initialization' stamp: '9/23/2025 02:00:26'!start	"Register a new bootTime"		bootTime := DateAndTime now! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26'!uptime	| sessionAge |	sessionAge := DateAndTime now - self bootTime.	^ 'Uptime: {1}' format: { (sessionAge roundTo: 1 minute) humanReadablePrintString }! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89238292!welcomePageGreeting	^ 'Welcome to Zinc HTTP Components,\a modern, open-source Smalltalk framework\to deal with the HTTP networking protocol.'! !!ZnDefaultServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89236042!welcomePageLinksOn: html	"Add our welcome page links"	html tag: #ul do: [		html tag: #li do: [			html				str: 'GitHub project page'; space;				tag: #a attributes: #(href 'https://github.com/svenvc/zinc') with: 'https://github.com/svenvc/zinc' ].		html tag: #li do: [			html				str: 'Live cloud instance'; space;				tag: #a attributes: #(href 'https://zn.stfx.eu') with: 'https://zn.stfx.eu' ].		html tag: #li do: [			html				str: 'Try'; space;				tag: #a attributes: #(href '/status') with: '/status'; space;				tag: #a attributes: #(href '/echo-html') with: '/echo-html'; space;				tag: #a attributes: #(href '/session') with: '/session'; space;				tag: #a attributes: #(href '/unicode') with: '/unicode' ].		html tag: #li do: [			html				str: 'All available routes'; space;				tag: #a attributes: #(href '/routes') with: '/routes' ] ]! !!ZnNetworkingUtils class methodsFor: 'class initialization' stamp: '9/23/2025 02:00:26' prior: 89764454!initialize	"The default will try to use ZdcSocketStream and ZdcSecureSocketStream"	Default := self new! !!ZnNetworkingUtils class methodsFor: 'constants' stamp: '9/23/2025 02:00:26' prior: 89764926!listenBacklogSize	"Server socket listen backlog size.	The number of pending connections queued up, waiting to be accepted, at any one time."	^ ZnCurrentOptions at: #listenBacklogSize! !!ZnNetworkingUtils class methodsFor: 'constants' stamp: '9/23/2025 02:00:26' prior: 89762180!socketStreamTimeout	"Return the timeout in seconds for network socket stream operations like connecting, reading and writing."	^ ZnCurrentOptions at: #socketStreamTimeout ! !!ZnNetworkingUtils methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89756830!secureSocketStreamClass: anObject	secureSocketStreamClass := anObject! !!ZnNetworkingUtils methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89750292!socketStreamClass: anObject	socketStreamClass := anObject! !!ZnNetworkingUtils methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89751346!sslSessionClass: anObject	sslSessionClass := anObject! !!ZnServerReadErrorEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 90016820!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Read Error ';  print: exception! !!ZnServerLogEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 90015238!printHeaderOn: stream	super printHeaderOn: stream.	serverId ifNotNil: [ stream space; << serverId asString ]! !!ZnServerSession methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 90019714!id: anObject	id := anObject! !!ZnClient methodsFor: 'operations' stamp: '9/23/2025 02:00:26' prior: 88997462!execute	"Execute the currently set up request to generate a response.	Return the #contents of the response, if any."	^ self withDynamicVariablesDo: [		| result |		self prepareRequest.		result := self executeHandlingErrors.		self prepareNextRequest.		result ]! !!ZnClient methodsFor: 'private - protocol' stamp: '9/23/2025 02:00:26'!executeHandlingErrors	^ [ self executeWithRetriesRemaining: self numberOfRetries ]			on: Error			do: self ifFailBlock! !!ZnClient methodsFor: 'private - protocol' stamp: '9/23/2025 02:00:26'!executeWithRedirectsRemaining: redirectCount trail: collectionOfUrls	self getConnectionAndExecute.	response isRedirect		ifTrue: [			(redirectCount > 0 and: [ self followRedirects ])				ifTrue: [					self prepareRedirect.					collectionOfUrls add: self request url.					self 						executeWithRedirectsRemaining: redirectCount - 1 						trail: collectionOfUrls ]				ifFalse: [					self followRedirects						ifTrue: [ | exception |							(exception := ZnTooManyRedirects new) 									trail: collectionOfUrls. 							exception signal = exception defaultResumeValue								ifTrue: [									"when resumed with default resume value, start over"									self 										executeWithRedirectsRemaining: self maxNumberOfRedirects 										trail: collectionOfUrls ] ] ] ].	^ self handleResponse! !!ZnClient methodsFor: 'private - protocol' stamp: '9/23/2025 02:00:26' prior: 89031742!executeWithRetriesRemaining: retryCount	^ [ self 			executeWithRedirectsRemaining: self maxNumberOfRedirects			trail: OrderedCollection new ]		on: self retryExceptionSet		do: [ :exception |			retryCount > 0				ifTrue: [					self						handleRetry: exception;						executeWithRetriesRemaining: retryCount - 1 ]				ifFalse: [					exception pass ] ]! !!ZnClient methodsFor: 'initialization' stamp: '9/23/2025 02:00:26' prior: 88991290!forJsonREST	"Configure me to be a JSON REST client.	Install a JSON content reader and writer and accept application/json."	| reader writer |	reader := ZnUtils defaultJSONReader.	writer := ZnUtils defaultJSONWriter.	self		accept: ZnMimeType applicationJson;		contentReader: [ :entity | reader fromString: entity contents ];		contentWriter: [ :data | ZnEntity json: (writer toString: data) ]! !!ZnClient methodsFor: 'initialization' stamp: '9/23/2025 02:00:26' prior: 89079174!initialize	super initialize.	request := ZnRequest empty.	self loggingOn! !!ZnClient methodsFor: 'options' stamp: '9/23/2025 02:00:26'!maximumLineLength: integer	"Set the maximum line length in bytes that I will read from a stream before signalling ZnLineTooLong"	self localOptions at: #maximumLineLength put: integer! !!ZnClient methodsFor: 'options' stamp: '9/23/2025 02:00:26' prior: 88994930!maximumNumberOfDictionaryEntries: anInteger	"Set the maximum number of entries allowed in ZnMutliValueDictionaries before signalling ZnTooManyDictionaryEntries. This protects us from overflow attacks."	self localOptions at: #maximumNumberOfDictionaryEntries put: anInteger! !!ZnClient methodsFor: 'private - protocol' stamp: '9/23/2025 02:00:26' prior: 88988484!readResponse	self signalHTTPProgress: 'Reading response'.	self withDefaultCharacterEncoderDo: [		response := (#(HEAD CONNECT) includes: request method)			ifTrue: [ ZnResponse readHeaderFrom: connection ]			ifFalse: [				self streaming					ifTrue: [ ZnResponse readStreamingFrom: connection ]					ifFalse: [ self reader value: connection ] ] ].	lastUsed := Time totalSeconds! !!ZnClient methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 88989536!setupTLSTo: url	(ZnNetworkingUtils shouldProxyUrl: url)		ifTrue: [ | originalRequest |			"http://www.ietf.org/rfc/rfc2817.txt (section 5)"			"https://en.wikipedia.org/wiki/HTTP_tunnel#HTTP_CONNECT_tunneling"			originalRequest := request copy.			request entity: nil. "to prevent #resetEntity from being called, resulting in #close of the shared entity"			self method: #CONNECT; writeRequest; readResponse.			response isSuccess ifFalse: [ self error: 'Failed to CONNECT to proxy for TLS/SSL' ].			connection := ZnNetworkingUtils secureSocketStreamOn: connection socket.			request := originalRequest ].	connection sslSession certificateName: self certificate.	[ connection sslSession serverName: url host ]		on: (ZnUtils exceptionSet: #( #SocketError #PrimitiveFailed ))		do: [ :error | "log it?" ].	connection connect.		((ZnCurrentOptions at: #verifyCertificates) 			and: [ connection sslSession certificateVerificationState ~= 0 ])		ifTrue: [ 			ZnCertificateVerificationFailed new 				verificationState: connection sslSession certificateVerificationState;				signal ]! !!ZnClient methodsFor: 'initialization' stamp: '9/23/2025 02:00:26' prior: 89036846!systemPolicy	"Configure me to fail when I don't receive an HTTP success respsone 	or when the content type that I get back is not why I expected. 	Set the number of retries to 2."	self		enforceHttpSuccess: true;		enforceAcceptContentType: true;		numberOfRetries: 2! !!ZnClient methodsFor: 'options' stamp: '9/23/2025 02:00:26' prior: 89040120!timeout: seconds	"Set the timeout for network socket stream operations	like connecting, reading and writing to seconds."	self localOptions at: #socketStreamTimeout put: seconds! !!ZnStringEntity methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 90218998!readFrom: stream	| buffer totalRead read readStream stringStream total |	total := self contentLength.	readStream := total ifNotNil: [ ZnLimitedReadStream on: stream limit: total ] ifNil: [ stream ].	buffer := String new: (ZnUtils streamingBufferSize min: (total ifNil: [ ZnUtils streamingBufferSize ])).	stringStream := nil.	totalRead := read := 0.	self initializeEncoder.	[ readStream atEnd ] whileFalse: [		[ read := encoder readInto: buffer startingAt: 1 count: buffer size fromStream: readStream ]			on: ZnByteStringBecameWideString			do: [ :notification |					buffer := notification wideString.					stringStream ifNotNil: [ | wideString position |						position := stringStream position.						wideString := WideString from: stringStream originalContents.						stringStream on: wideString; setFrom: position + 1 to: position ].					notification resume ].		totalRead := totalRead + read.		totalRead > (ZnCurrentOptions at: #maximumEntitySize)			ifTrue: [ ZnEntityTooLarge signal ].		stringStream ifNil: [			readStream atEnd				ifTrue: [ ^ self string: (buffer copyFrom: 1 to: read); computeContentLength ]				ifFalse: [ stringStream := (total ifNil: [ buffer species new ] ifNotNil: [ buffer species new: total ]) writeStream ] ].		stringStream next: read putAll: buffer startingAt: 1.		ZnUtils signalProgress: totalRead total: total ].	self string: (stringStream ifNil: [ String new ] ifNotNil: [ stringStream contents ])! !!ZnResponse methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89944072!readEntityFrom: stream	(self isInformational or: [ self isNoContent or: [ self isNotModified ] ])		ifFalse: [ super readEntityFrom: stream ]! !!ZnResponse methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89937558!readHeaderFrom: stream	self statusLine: (ZnStatusLine readFrom: stream).	super readHeaderFrom: stream! !!ZnConnectionAcceptedEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 89174112!printContentsOn: stream	super printContentsOn: stream.	stream << 'Connection Accepted '.	self class printAddress: address on: stream ! !!ZnServerSocketReleasedEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 90029418!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Socket Released '.	self class printAddress: address on: stream. 	stream nextPut: $:; print: port! !!ZnChunkedWriteStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88980130!binary	stream binary! !!ZnChunkedWriteStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88977942!close	self finish.	stream close! !!ZnChunkedWriteStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88978206!finish	self writeChunkSize: 0.	self crlf.	extraHeaders ifNotNil: [ extraHeaders writeOn: stream ]! !!ZnChunkedWriteStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88982304!flush	stream flush! !!ZnChunkedWriteStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88978820!on: writeStream	stream := writeStream! !!ZnConstants class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 89182308!frameworkVersion	^ '2.0'! !!ZnConnectionRejectedEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 89179522!printContentsOn: stream	super printContentsOn: stream.	stream << 'Connection Rejected '.	self class printAddress: address on: stream! !!ZnRequestReadEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 89908180!printContentsOn: stream	super printContentsOn: stream.	stream << 'Request Read '; print: request; space; print: duration; << 'ms'! !!ZnServerConnectionClosedEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 90010284!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Connection Closed '.	self class printAddress: address on: stream ! !!ZnMessage methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89598344!readBinaryFrom: stream	| entityReader |	self readHeaderFrom: stream.	(entityReader := self entityReaderOn: stream)		binary.	self entity: entityReader readEntity! !!ZnMessage methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89599240!readEntityFrom: stream	self entity: (self entityReaderOn: stream) readEntity! !!ZnMessage methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89597254!readFrom: stream	self readHeaderFrom: stream.	self readEntityFrom: stream! !!ZnMessage methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89589176!readHeaderFrom: stream	self headers: (ZnHeaders readFrom: stream)! !!ZnMessage methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89591714!readStreamingFrom: stream	| entityReader |	self readHeaderFrom: stream.	(entityReader := self entityReaderOn: stream)		streaming.	self entity: entityReader readEntity! !!ZnLoggingReadStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89567982!identifier: string	identifier := string! !!ZnLoggingReadStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89572492!logLevel: integer	"logLevel 1 logs reads with next and friends	logLevl 2 logs peek and atEnd too"	logLevel := integer! !!ZnLoggingReadStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89566704!logger: oneArgumentBlock	logger := oneArgumentBlock! !!ZnLoggingReadStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89565542!on: binaryReadStream	stream := binaryReadStream! !!ZnLoggingReadStream methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnServerHandlerErrorEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 90014472!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Handler Error ';  print: exception! !!ZnServerWriteErrorEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 90084366!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Write Error ';  print: exception! !!ZnSimplifiedServerTransactionEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 90112400!printContentsOn: stream	super printContentsOn: stream.	stream nextPutAll: method; space.	url printPathQueryFragmentOn: stream.	stream space; print: response.	size ifNotNil: [		stream space; print: size; nextPut: $B ].	stream space; print: duration; nextPutAll: 'ms'! !!ZnResponseReadEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 89955716!printContentsOn: stream	super printContentsOn: stream.	stream << 'Response Read '; print: response; space; print: duration; << 'ms'! !!ZnMimePart methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89626220!hasHeaders	^ headers isNotNil and: [ self headers isEmpty not ]! !!ZnMimePart methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89631944!readBinaryFrom: stream	| entityReader |	self headers: (ZnHeaders readFrom: stream).	(entityReader := self entityReaderOn: stream)		binary.	self entity: entityReader readEntity! !!ZnMimePart methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89631174!readFrom: stream	self headers: (ZnHeaders readFrom: stream).	self entity: (self entityReaderOn: stream) readEntity! !!ZnConnectionEstablishedEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 89176144!printContentsOn: stream	super printContentsOn: stream.	stream << 'Connection Established '; nextPutAll: hostname asString; nextPut: $:; print: port.	proxy ifNotNil: [ stream << ' via proxy '; print: proxy ].	stream space.	self class printAddress: address on: stream.	stream nextPut: $:; print: port.	stream space; print: duration; << 'ms'! !!ZnCookieJar methodsFor: 'operations' stamp: '9/23/2025 02:00:26'!readNetscapeFormatFrom: fileReference	| cookie |	fileReference readStreamDo: [ :fileStream | 		(ZnFastLineReader on: fileStream) linesDo: [ :each | 			(each beginsWith: '#')				ifFalse: [ cookie := ZnCookie new.					cookie fromNetscapeString: each.					self add: cookie ] ] ]! !!ZnCookieJar methodsFor: 'operations' stamp: '9/23/2025 02:00:26'!writeNetscapeFormatTo: fileReference	fileReference writeStreamDo: [ :fileStream |		(ZnNewLineWriterStream on: fileStream) in: [ :out |			out nextPutAll: '# Netscape HTTP Cookie File'; cr.			self cookies do: [ :each |				out nextPutAll: each netscapeString; cr ] ] ]! !!ZnServerSocketBoundEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 90027542!printContentsOn: stream	super printContentsOn: stream.	stream << 'Server Socket Bound '.	self class printAddress: address on: stream.	stream nextPut: $:; print: port! !!ZnLogEvent class methodsFor: 'convenience' stamp: '9/23/2025 02:00:26' prior: 89561460!logToTranscript	self stopLoggingToTranscript.	^ self announcer 		when: ZnLogEvent 		do: [ :event | self crTrace: event ]		for: self! !!ZnLogEvent class methodsFor: 'utilities' stamp: '9/23/2025 02:00:26'!printAddress: address on: stream	"Try printing address as a IPv4 dotted address to stream.	If that fails, just print address as an object to stream."		[ address asSocketAddress printOn: stream ] on: Error do: [ stream print: address ]! !!ZnValueDelegate methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 90456440!object: anObject	object := anObject! !!ZnStatusLine methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 90194068!readFrom: stream	| line lineStream httpCode |	line := (ZnLineReader on: stream) nextLine.	lineStream := line readStream.	self version: (lineStream upTo: Character space).	httpCode := lineStream upTo: Character space.	httpCode := Integer readFrom: httpCode ifFail: [ (ZnUnknownHttpStatusCode code: httpCode) signal ].	self code: httpCode.	self reason: (lineStream upToEnd)! !!ZnStreamingEntity methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 90208824!close	stream ifNotNil: [		stream close.		stream := nil ]! !!ZnStreamingEntity methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 90210298!readFrom: readStream	self contentLength		ifNil: [ self stream: readStream ]		ifNotNil: [ | limitedStream |			limitedStream := ZnLimitedReadStream on: readStream limit: self contentLength.			self stream: limitedStream ]! !!ZnCertificateVerificationFailed methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!isResumable	"Determine whether an exception is resumable."	^ true! !!ZnCertificateVerificationFailed methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!verificationState	^ verificationState! !!ZnCertificateVerificationFailed methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!verificationState: anInteger	verificationState := anInteger! !!ZnTooManyRedirects methodsFor: 'private' stamp: '9/23/2025 02:00:26'!defaultResumeValue	^ #retry! !!ZnTooManyRedirects methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!trail	^ trail! !!ZnTooManyRedirects methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!trail: aCollectionOfUrls	trail := aCollectionOfUrls! !!ZnApplicationFormUrlEncodedEntity methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88585798!readFrom: stream	"We parse from stream, limited to content length if available."	| rawStream readStream |	representation := nil.	rawStream := contentLength		ifNil: [ stream ]		ifNotNil: [ ZnLimitedReadStream on: stream limit: contentLength ].	readStream := ZnCharacterReadStream on: rawStream encoding: 'ascii'.	fields := ZnResourceMetaUtils parseQueryFrom: readStream! !!ZnSimplifiedClientTransactionEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 90107344!printContentsOn: stream	super printContentsOn: stream.	stream nextPutAll: method; space.	url printPathQueryFragmentOn: stream.	stream space; print: response.	size ifNotNil: [		stream space; print: size; nextPut: $B ].	stream space; print: duration; nextPutAll: 'ms'! !!ZnClientRetryingEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 89096874!printContentsOn: stream	super printContentsOn: stream.	stream << 'Retrying '; print: exception! !!ZnEntity methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89321524!close! !!ZnEntity methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89326716!readBinaryFrom: stream	self readFrom: stream! !!ZnEntity methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89325662!readFrom: stream	self subclassResponsibility! !!ZnResponseWrittenEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 89970210!printContentsOn: stream	super printContentsOn: stream.	stream << 'Response Written '; print: response; space; print: duration; << 'ms'! !!ZnServerTransactionEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 90078150!printContentsOn: stream	super printContentsOn: stream.	request requestLine printMethodAndUriOn: stream.	stream space; print: response code.	response hasEntity		ifTrue: [			stream space; print: response entity contentLength; nextPut: $B ].	stream space; print: self duration; nextPutAll: 'ms'! !!ZnHtmlOutputStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89463696!close	stream close! !!ZnHtmlOutputStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89465058!on: writeStream	stream := writeStream! !!ZnHtmlOutputStream methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!rawStream	"Answer the innermost stream wrapped by the receiver, e.g. a raw binary file stream,	socket stream, or regular Read/WriteStream.	Defer to the wrappedStream."	^ self wrappedStream rawStream! !!ZnLineReader methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89550880!on: readStream	stream := readStream.	buffer := String new: 64.	self		limit: (ZnCurrentOptions at: #maximumLineLength);		reset! !!ZnRequestLine methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 89900120!method	<return: #Symbol>	^ method! !!ZnRequestLine methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 89897456!method: aSymbol	method := ZnConstants knownHTTPMethods		detect: [ :each | each = aSymbol ]		ifNone: [ (ZnUnknownHttpMethod method: aSymbol) signal ]! !!ZnRequestLine methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89900336!readFrom: stream	| line lineStream |	line := (ZnLineReader on: stream) nextLine.	lineStream := line readStream.	self method: (lineStream upTo: Character space) asSymbol.	self uri: (lineStream upTo: Character space).	self version: (lineStream upToEnd)! !!ZnServerGenericLogEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 90013018!printContentsOn: stream	super printContentsOn: stream.	stream nextPutAll: subject asString! !!ZnManagingMultiThreadedServer methodsFor: 'private' stamp: '9/23/2025 02:00:26'!acceptOn: listeningSocket	| clientSocket |	self isUsingLimitedAcceptStrategy		ifTrue: [			"Wait until there is room to accept a connection.			If we time out, return nil to loop"			(availableConnections waitTimeoutSeconds: self acceptWaitTimeout)				ifTrue: [ ^ nil ] ].	clientSocket := listeningSocket waitForAcceptFor: self acceptWaitTimeout.	^ clientSocket		ifNil: [			self isUsingLimitedAcceptStrategy				ifTrue: [ 					"The timeout expired and no connection was accepted, give back the available connection slot"					availableConnections signal ].			nil ]		ifNotNil: [ 			clientSocket ]! !!ZnManagingMultiThreadedServer methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89584410!closeConnections	self hasOpenConnections ifFalse: [ ^ self ].	self lock critical: [		self connections do: [ :each |			self logConnectionClosed: each.			[ each close ]				on: Exception				do: [ #ignore ] ].		self connections removeAll ]! !!ZnManagingMultiThreadedServer methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89585082!closeSocketStream: socketStream	super closeSocketStream: socketStream.	self lock critical: [		self connections remove: socketStream ifAbsent: [ ].		"we cannot use #isUsingLimitedAcceptStrategy as we are sometimes called outside bound process variables"		availableConnections			ifNotNil: [				"Give back the available connection slot"				availableConnections signal ] ]! !!ZnManagingMultiThreadedServer methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!hasOpenConnections	^ connections notNil and: [ connections isNotEmpty ]! !!ZnManagingMultiThreadedServer methodsFor: 'private' stamp: '9/23/2025 02:00:26'!initializeServerSocket	super initializeServerSocket.	self isUsingLimitedAcceptStrategy 		ifTrue: [			"Create a Semaphore that counts the available connections that can accept"			availableConnections := Semaphore new.			(ZnCurrentOptions at: #maximumNumberOfConcurrentConnections)				timesRepeat: [ availableConnections signal ] ]! !!ZnManagingMultiThreadedServer methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!isUsingLimitedAcceptStrategy	^ (ZnCurrentOptions at: #acceptStrategy) = #limited! !!ZnManagingMultiThreadedServer methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!numberOfOpenConnections	^ self hasOpenConnections		ifTrue: [ connections size ]		ifFalse: [ 0 ]! !!ZnManagingMultiThreadedServer methodsFor: 'private' stamp: '9/23/2025 02:00:26'!releaseServerSocket	super releaseServerSocket.	self isUsingLimitedAcceptStrategy		ifTrue: [ availableConnections := nil ]! !!ZnManagingMultiThreadedServer methodsFor: 'request handling' stamp: '9/23/2025 02:00:26'!serveConnectionsOn: listeningSocket	"We wait up to acceptWaitTimeout seconds for an incoming connection.	If we get one we wrap it in a SocketStream and #executeRequestResponseLoopOn: on it.	Overwritten to handle logic related to concurrent connections."	| stream socket |	socket := self acceptOn: listeningSocket.	socket ifNil: [ ^ self noteAcceptWaitTimedOut ].	stream := [ self socketStreamOn: socket ]					on: ZnTooManyConcurrentConnections do: [ ^ self ].	[ [ [ self executeRequestResponseLoopOn: stream ]		ensure: [ self logConnectionClosed: stream. self closeSocketStream: stream ] ]			ifCurtailed: [ socket destroy ] ]				forkAt: Processor lowIOPriority				named: self workerProcessName! !!ZnManagingMultiThreadedServer methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89581810!socketStreamOn: socket	| socketStream |	socketStream := super socketStreamOn: socket.	self numberOfOpenConnections >= (ZnCurrentOptions at: #maximumNumberOfConcurrentConnections)		ifTrue: [ ^ self rejectConnection: socketStream ].	self lock critical: [		self connections add: socketStream ].	^ socketStream! !!ZnManagingMultiThreadedServer methodsFor: 'public' stamp: '9/23/2025 02:00:26' prior: 89582622!stop: unregister	self stopServer: unregister.	self closeConnections! !!ZnMultiThreadedServer methodsFor: 'request handling' stamp: '9/23/2025 02:00:26' prior: 89734434!listenLoop	"We create a listening Socket, then wait for a connection.	After each connection we also check that the listening Socket is still valid	- if not we just make a recursive call to this method to start over."	self withDynamicVariablesDo: [		self initializeServerSocket.		[			[				serverSocket isValid					ifFalse: [						"will trigger #ifCurtailed: block and destroy socket"						^ self listenLoop ].				self serveConnectionsOn: serverSocket ] repeat ]		ifCurtailed: [ self releaseServerSocket ] ]! !!ZnMultiThreadedServer methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89722968!readRequestBadExceptionSet	"Return the set of exceptions which, when they occur while reading a request,	are interpreted as equivalent to a request parse error or bad request."	^ ZnUtils		exceptionSet:			#(#ZnParseError #ZnCharacterEncodingError #ZnUnknownScheme #ZnPortNotANumber #ZnTooManyDictionaryEntries #ZnEntityTooLarge)! !!ZnMultiThreadedServer methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89728366!readRequestTerminationExceptionSet	"Return the set of exceptions which, when they occur while reading a request,	are interpreted as equivalent to a timeout or connection close."	^ ZnUtils		exceptionSet:			#(#ConnectionClosed #ConnectionTimedOut #SocketError #PrimitiveFailed)! !!ZnMultiThreadedServer methodsFor: 'request handling' stamp: '9/23/2025 02:00:26' prior: 89724656!serveConnectionsOn: listeningSocket	"We wait up to acceptWaitTimeout seconds for an incoming connection.	If we get one we wrap it in a SocketStream and #executeRequestResponseLoopOn: on it"	| stream socket |	socket := listeningSocket waitForAcceptFor: self acceptWaitTimeout.	socket ifNil: [ ^ self noteAcceptWaitTimedOut ].	stream := self socketStreamOn: socket.	[ [ [ self executeRequestResponseLoopOn: stream ]		ensure: [ self logConnectionClosed: stream. self closeSocketStream: stream ] ]			ifCurtailed: [ socket destroy ] ]				forkAt: Processor lowIOPriority				named: self workerProcessName! !!ZnMultiThreadedServer methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89732038!writeResponseTerminationExceptionSet	"Return the set of exceptions which, when they occur while writing a response,	are interpreted as equivalent to a timeout or connection close."	^ ZnUtils 		exceptionSet:			#(#ConnectionClosed #ConnectionTimedOut #SocketError #PrimitiveFailed)! !!ZnMultiPartFormDataEntity methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89717358!readBinaryFrom: stream	"Switch to streaming implementation later on"	| bytes |	"We have to use the contentLength instance variable instead of the accessor else a representation will be computed"	contentLength		ifNil: [ bytes := ZnUtils readUpToEnd: stream limit: ( ZnCurrentOptions at: #maximumEntitySize ) ]		ifNotNil: [			self contentLength > ( ZnCurrentOptions at: #maximumEntitySize ) ifTrue: [ ZnEntityTooLarge signal ].			bytes := ByteArray ofSize: contentLength.			stream next: contentLength into: bytes ].	self parse: bytes boundary: self getBoundary asByteArray binary: true! !!ZnMultiPartFormDataEntity methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89715462!readFrom: stream	"Switch to streaming implementation later on"	| bytes |	"We have to use the contentLength instance variable instead of the accessor else a representation will be computed"	contentLength		ifNil: [ bytes := ZnUtils readUpToEnd: stream limit: ( ZnCurrentOptions at: #maximumEntitySize ) ]		ifNotNil: [			self contentLength > ( ZnCurrentOptions at: #maximumEntitySize ) ifTrue: [ ZnEntityTooLarge signal ].			bytes := ByteArray ofSize: contentLength.			stream next: contentLength into: bytes ].	self parse: bytes boundary: self getBoundary asByteArray binary: false! !!ZnClientConnectionClosedEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 89090480!printContentsOn: stream	super printContentsOn: stream.	stream << 'Connection Closed '.	self class printAddress: address on: stream.	stream nextPut: $:; print: port! !!ZnServerStoppedEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 90032366!printContentsOn: stream	super printContentsOn: stream.	description ifNotNil: [ stream << 'Stopped '; << description ]! !!ZnLimitedReadStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89530060!close	stream ifNotNil: [ stream close. stream := nil ]! !!ZnLimitedReadStream methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89530578!on: readStream limit: integer	stream := readStream.	limit := integer.	position := 0! !!ZnByteArrayEntity methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 88739930!readFrom: stream	self contentLength		ifNil: [			self bytes: (ZnUtils readUpToEnd: stream limit: (ZnCurrentOptions at: #maximumEntitySize)).			self contentLength: self bytes size ]		ifNotNil: [ | byteArray readCount |			self contentLength > (ZnCurrentOptions at: #maximumEntitySize)				ifTrue: [ ZnEntityTooLarge signal ].			byteArray := ByteArray ofSize: self contentLength.			readCount := self contentLength > ZnUtils streamingBufferSize				ifTrue: [ ZnUtils streamFrom: stream to: byteArray writeStream size: self contentLength ]				ifFalse: [ stream readInto: byteArray startingAt: 1 count: self contentLength ].			readCount = self contentLength 				ifTrue: [ self bytes: byteArray ]				ifFalse: [ self bytes: (byteArray copyFrom: 1 to: readCount); contentLength: readCount ] ]! !!ZnClientLogEvent methodsFor: 'printing' stamp: '9/23/2025 02:00:26' prior: 89095688!printHeaderOn: stream	super printHeaderOn: stream.	clientId ifNotNil: [ stream space; << clientId asString ]! !!ZnSingleThreadedServer methodsFor: 'request handling' stamp: '9/23/2025 02:00:26' prior: 90116762!listenLoop	"We create a listening Socket, then wait for a connection.	After each connection we also check that the listening Socket is still valid	- if not we just make a recursive call to this method to start over."	self withDynamicVariablesDo: [		self initializeServerSocket.		[			[				serverSocket isValid 					ifFalse: [ 						"will trigger #ifCurtailed: block and destroy socket"						^ self listenLoop ].				self serveConnectionOn: serverSocket ] repeat ]		ifCurtailed: [ self releaseServerSocket ] ]! !!ZnSingleThreadedServer methodsFor: 'request handling' stamp: '9/23/2025 02:00:26' prior: 90135278!readRequest: stream timing: timing	"Read a request from stream.	We add a virtual header containing the remote IP address of the client"	| request initialMilliseconds |	initialMilliseconds := Time millisecondClockValue.	request := self withDefaultCharacterEncoderDo: [ self reader value: stream ].	request headers		at: ZnConstants remoteAddressHeader		put: (ZnNetworkingUtils ipAddressToString: stream socket remoteAddress).	timing requestDuration: (self logRequestRead: request started: initialMilliseconds).	^ request! !!ZnSingleThreadedServer methodsFor: 'request handling' stamp: '9/23/2025 02:00:26' prior: 90150090!serveConnectionOn: listeningSocket	"We wait up to acceptWaitTimeout seconds for an incoming connection.	If we get one we wrap it in a SocketStream and #executeOneRequestResponseOn: on it.	We do not fork a worker thread/process but stay in the current one for just one request/response cycle."	| stream socket |	socket := listeningSocket waitForAcceptFor: self acceptWaitTimeout.	socket ifNil: [ ^ self noteAcceptWaitTimedOut ].	stream := self socketStreamOn: socket.	[	[ self executeOneRequestResponseOn: stream ]		ensure: [			self logConnectionClosed: stream.			stream close ] ]		ifCurtailed: [			socket destroy ]! !!ZnSingleThreadedServer methodsFor: 'public' stamp: '9/23/2025 02:00:26' prior: 90132456!start	"Start me. I will start listening on my port for incoming HTTP connections.	If I am running, I will first stop and thus effectively restart"	self stop: false.	self class default = self ifTrue: [ self register ].	self startDelegate.	process := [ [ self listenLoop ] repeat ]		forkAt: Processor highIOPriority		named: self serverProcessName.	self logStarted! !!ZnSingleThreadedServer methodsFor: 'private' stamp: '9/23/2025 02:00:26'!startDelegate	self delegate		ifNotNil: [ :delegate |			(delegate respondsTo: #start)				ifTrue: [ delegate start ] ]! !!ZnSingleThreadedServer methodsFor: 'public' stamp: '9/23/2025 02:00:26' prior: 90147710!stop: unregister	"Stop me. I will stop listening on my port for incoming HTTP connections.	If unregister is true, unregister me from the list of managed instances.	Does nothing when I am not running"	self stopServer: unregister! !!ZnSingleThreadedServer methodsFor: 'public' stamp: '9/23/2025 02:00:26'!stopServer: unregister	"Stop me. I will stop listening on my port for incoming HTTP connections.	If unregister is true, unregister me from the list of managed instances.	Does nothing when I am not running"	self isRunning ifFalse: [ ^ self ].	process terminate.	process := nil.	unregister ifTrue: [ self unregister ].	self closeDelegate.	self logStopped! !!ZnCookie methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89202726!defaultDomain: aDomain	self domain ifNil: [ self domain: aDomain ]! !!ZnCookie methodsFor: 'converting' stamp: '9/23/2025 02:00:26'!fromNetscapeString: string	| tokens |	tokens := string findTokens: { Character tab }.	self domain: tokens first.	"subdomains is always true"	self path: tokens third.	self secure: tokens fourth asUppercase = 'TRUE'.	tokens fifth = '0'		ifFalse: [ self expiresTimeStamp: (DateAndTime fromUnixTime: tokens fifth asInteger) ].	self name: tokens sixth.	self value: tokens seventh! !!ZnCookie methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89205474!fromString: aString	| tokens val data i |	tokens := aString substrings: ';'.	i := tokens first indexOf: $=.	val := tokens first copyFrom: 1 to: i - 1.	data := tokens first copyFrom: i + 1 to: tokens first size.	self name: val trimBoth; value: data trimBoth.	2 to: tokens size do: [ :index |		self readAttribute: (tokens at: index) ]! !!ZnCookie methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89196838!isInDomain: urlObject	| domain |	domain := (self domain beginsWith: '.')		ifTrue: [ self domain allButFirst ]		ifFalse: [ self domain ].	^ urlObject host includesSubstring: domain! !!ZnCookie methodsFor: 'converting' stamp: '9/23/2025 02:00:26'!netscapeString	^ String streamContents: [ :stream |		stream nextPutAll: self domain; tab.		stream nextPutAll: 'TRUE'; tab.		stream nextPutAll:  self path; tab.		stream nextPutAll: self secure printString asUppercase; tab.		stream print: ([ self expiresTimeStamp asUnixTime ] on: Error do: [ 0 ]); tab.		stream nextPutAll: self name; tab.		stream nextPutAll: self value ]! !!ZnCookie methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89197676!readAttribute: aToken	| i key data |	i := aToken indexOf: $=.	i > 0		ifTrue: [			key := (aToken copyFrom: 1 to: i - 1) trimBoth asLowercase.			data := (aToken copyFrom: i + 1 to: aToken size) trimBoth ]		ifFalse: [			key := (aToken copyFrom: 1 to: aToken size) trimBoth asLowercase.			data := true ].	attributes at: key put: data! !ZnNetworkingUtils class removeSelector: #defaultSocketStreamTimeout:!ZnNetworkingUtils class removeSelector: #defaultSocketStreamTimeout!ZnSingleThreadedServer removeSelector: #withMaximumNumberOfDictionaryEntriesDo:!ZnConstants class removeSelector: #maximumLineLength!ZnClient removeSelector: #withTimeoutDo:!ZnClient removeSelector: #withMaximumNumberOfDictionaryEntriesDo:!ZnClient removeSelector: #timeout!ZnClient removeSelector: #maximumNumberOfDictionaryEntries!ZnClient removeSelector: #interactivePolicy!ZnClient removeSelector: #executeWithTimeout!ZnClient removeSelector: #executeWithRedirectsRemaining:!ZnClient removeSelector: #debugPolicy!ZnMultiThreadedServer removeSelector: #exceptionSet:!ZnDefaultServerDelegate removeSelector: #welcomePageCss!ZnDefaultServerDelegate removeSelector: #vmStats!ZnDefaultServerDelegate removeSelector: #systemVersionInfo!ManifestZincHTTP class removeSelector: #ruleNotEliminationRuleV1FalsePositive!Smalltalk globals removeClassNamed: #AnObsoleteManifestZincHTTP!ZnServer removeSelector: #maximumNumberOfDictionaryEntries!Smalltalk globals removeClassNamed: #AnObsoleteZnConnectionTimeout!"Zinc-HTTP"!!ZnProxyServerDelegate commentStamp: '<historical>' prior: 0!I am a ZnDelegate that acts as a proxy.I handle requests by passing them to a proxyBlock which can change the request before I execute it.The idea is that the changed request is to a different server, the one that we proxy.Usage example	| proxiedServer proxyServer proxyDelegate client  |	proxiedServer := ZnServer startOn: 8080.	proxyServer := ZnServer on: 9090.	proxyDelegate := ZnProxyServerDelegate new		server: proxyServer;		proxyBlock: [ :request | 			request url: (request url port: 8080) ].	proxyServer		delegate: proxyDelegate;		start.	client := ZnClient new.	client get: proxyServer url / #echo.!!ZnStaticFileServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 90166724!actualFilenameFor: uri	| subElements subDir entry |	(uri isEmpty and: [ self prefix isEmpty ]) ifTrue: [ ^ self indexFileIn: self directory ].	(self prefix isEmpty or: [ uri isEmpty not and: [ uri pathSegments beginsWith: self prefix ] ]) ifFalse: [ ^ nil ].	subElements := (uri pathSegments allButFirst: self prefix size) reject: [ :each | each = $/ ].	subDir := (subElements ifNotEmpty: #allButLast ifEmpty: [ #() ]) 		inject: self directory 		into: [ :parent :sub | | file |			(file := parent / sub) exists				ifTrue: [ file ]				ifFalse: [ ^ nil ] ]. 	subElements isEmpty		ifTrue: [ entry := subDir entry ]		ifFalse: [ | file |			 (file := subDir / subElements last) exists				ifTrue: [ entry := file entry ]				ifFalse: [ ^ nil ] ].	^ entry isDirectory		ifTrue: [ self indexFileIn: entry reference ]		ifFalse: [ entry reference fullName ]! !!ZnKeyValueStoreClient methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89512898!close	httpClient ifNotNil: [		httpClient close.		httpClient := nil ]! !!ZnStaticFileDecoratorDelegate methodsFor: 'public' stamp: '9/23/2025 02:00:26' prior: 90159792!handleRequest: znRequest	"try to resolve the uri path into a file for response. If not found dispatch the	request to the given delegate"	| response |	(znRequest method = #GET)		ifTrue: [			response := (staticDelegate handleRequest: znRequest).			response isSuccess ifTrue: [				^ response  ] ].	^ delegate handleRequest: znRequest! !!ZnStaticFileServerDelegateTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26' prior: 90181782!testBasicGetWide	self withServerDo: [ :server | | client |		(client := ZnClient new)			beOneShot;			url: server localUrl;			addPath: #('local-files' 'wide.html');			get.		self assert: client isSuccess.		self assert: client response contentType = ZnMimeType textHtml.		self assert: client contents equals: self wideHtml.		self			assert: (ZnUtils parseHttpDate: (client response headers at: 'Modification-Date'))			equals: (ZnFileSystemUtils modificationTimeFor: 'wide.html') asUTC.		self			assert: (ZnUtils parseHttpDate: (client response headers at: 'Expires')) > (DateAndTime now + 10 days).		self			assert: (client response headers at: 'Cache-Control')			equals: (server delegate maxAgeFor: ZnMimeType textHtml) ]! !!ZnProxyServerDelegateTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!testEcho	| proxiedServer proxyServer proxyDelegate client  |	proxiedServer := ZnServer startOn: 8080.	proxyServer := ZnServer on: 9090.	proxyDelegate := ZnProxyServerDelegate new		server: proxyServer;		proxyBlock: [ :request | 			request url: (request url port: 8080) ].	proxyServer		delegate: proxyDelegate;		start.	client := ZnClient new.	client get: proxyServer url / #echo.	self assert: client isSuccess.	self assert: (client contents includesSubstring: 'echoing').	self assert: (client contents includesSubstring: 'running 8080').	proxiedServer stop.	proxyServer stop! !!ZnReadEvalPrintDelegate methodsFor: 'public' stamp: '9/23/2025 02:00:26' prior: 89875754!handleRequest: request	request uri firstPathSegment = 'repl'		ifTrue: [			request method = #GET				ifTrue: [					^ self handleGetRequest: request ].			(request method = #POST and: [ request hasEntity and: [ request contentType isBinary not ] ])				ifTrue: [					^ self handlePostRequest: request ] ].	^ ZnResponse notFound: request uri! !!ZnReadEvalPrintDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26' prior: 89873756!helpText	^ '# Pharo Smalltalk REPL. POST expressions to evaluate\# Example\curl -X POST -H''Content-Type:text/plain'' -d ''42 factorial'' http://localhost:1701/repl\# Here is another way (type ctrl-d to end input)\curl -X POST -H''Content-Type:text/plain'' --data-binary @- http://localhost:{1}/repl\'			withCRs				replaceAll: Character cr with: Character lf;				yourself! !!ZnImageExampleDelegate methodsFor: 'request handling' stamp: '9/23/2025 02:00:26' prior: 89498004!handlePostRequest: request	"POST /image <multipart form data with file part> - change the image and show the result.	Do full error checking before accepting the newly uploaded image"	| part newImage badRequest |	badRequest := [ ^ ZnResponse badRequest: request ].	(request hasEntity and: [ request contentType matches: ZnMimeType multiPartFormData ])		ifFalse: badRequest.	part := request entity		partNamed: 'file'		ifNone: badRequest.	newImage := part entity.	(newImage isNotNil and: [ newImage contentType matches: 'image/*' asZnMimeType ])		ifFalse: badRequest.	[ self formForImageEntity: newImage ] on: Error do: badRequest.	image := newImage.	^ ZnResponse redirect: 'image'! !!ZnImageExampleDelegate methodsFor: 'public' stamp: '9/23/2025 02:00:26' prior: 89503546!handleRequest: request	"Dispatch between GET and POST on /image"	request uri path = 'image'		ifTrue: [			request method = #GET				ifTrue: [					^ self handleGetRequest: request ].			request method = #POST				ifTrue: [					^ self handlePostRequest: request ] ].	^ ZnResponse notFound: request uri! !!ZnProxyServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26'!augmentUrl: aUrl	"The URL in a server request has no scheme, host or port set.	Augment aUrl by taking those elements from #serverUrl"	self server ifNil: [ ^ aUrl ].	^ aUrl inContextOf: self server url! !!ZnProxyServerDelegate methodsFor: 'private' stamp: '9/23/2025 02:00:26'!copyAndPrepareRequest: aRequest	"We make a copy of the request and augment its URL"	| copiedRequest |	copiedRequest := aRequest copy.	copiedRequest url: (self augmentUrl: copiedRequest url).	^ copiedRequest! !!ZnProxyServerDelegate methodsFor: 'public' stamp: '9/23/2025 02:00:26'!handleRequest: incomingRequest	"Ask our proxy block to transform a incoming ZnRequest copy into an outgoing ZnRequest"	| outgoingRequest |	outgoingRequest := self proxyBlock 		cull: (self copyAndPrepareRequest: incomingRequest) 		cull: self server.	^ ZnClient new		request: outgoingRequest;		beOneShot;		execute;		response! !!ZnProxyServerDelegate methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!proxyBlock	^ proxyBlock! !!ZnProxyServerDelegate methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!proxyBlock: aBlock	"Set the block that transforms a copy of the incoming ZnRequest to the outgoing ZnRequest.	Two parameters are passed to block: the request and an optional server reference.	See #copyAndPrepareRequest: for how the request got changed."	proxyBlock := aBlock! !!ZnProxyServerDelegate methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!server	^ server! !!ZnProxyServerDelegate methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!server: aZnServer	"Set areference to the server we're in (optional)"	server := aZnServer! !!ZnImageExampleDelegateTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89506756!testUpload	self withServerDo: [ :server |		| image client |		image := self image.		client := ZnClient new.		client url: server localUrl; addPath: 'image'.		client addPart: (ZnMimePart fieldName: 'file' entity: image).		client post.		self assert: client isSuccess.		client resetEntity; queryAt: #raw put: #true.		client get.		self assert: client isSuccess.		self assert: client entity equals: image.		client close ]! !"Zinc-HTTP-Examples"!!ZnUrlTest methodsFor: '*Zinc-Tests' stamp: '9/23/2025 02:00:26'!testFragmentWithQuestionMark	| urlString url |	urlString := 'http://www.example.com/#fragment?with?question?mark'.	url := urlString asUrl.	self assert: url segments isNil.	self deny: url hasQuery.	self assert: url asString equals: urlString! !!ZnChunkedStreamTest class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!defaultTimeLimit	^15 seconds! !!ZnChunkedStreamTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 88974302!testGzipWriteRead	| data written read |	data := (String loremIpsum: 16*1024) utf8Encoded.	written := ByteArray streamContents: [ :out |		| stream chunkedStream |		stream := GZipWriteStream on: (chunkedStream := ZnChunkedWriteStream on: out).		stream nextPutAll: data.		stream finish.		chunkedStream finish ].	read := (GZipReadStream on: (ZnChunkedReadStream on: written readStream)) upToEnd.	self assert: read equals: data! !!ZnServerTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 90065862!assertHeaderLineTooLong: serverUrl	| response client |	client := ZnClient new		url: serverUrl;		addPathSegment: #echo;		headerAt: 'X-Test' put: (String new: (ZnCurrentOptions at: #maximumLineLength) withAll: $X);		yourself.	response := client		get;		response.	client close.	self deny: response isSuccess.	self assert: response code equals: 400.	self assert: response contentType equals: ZnMimeType textPlain.	self assert: (response entity contents includesSubstring: 'ZnLineTooLong')! !!ZnServerTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 90051982!assertRequestLineTooLong: serverUrl	| url response |	url := serverUrl		addPathSegment: #echo;		addPathSegment: (String new: (ZnCurrentOptions at: #maximumLineLength) withAll: $X);		yourself.	response := ZnEasy get: url.	self deny: response isSuccess.	self assert: response code equals: 400.	self assert: response contentType equals: ZnMimeType textPlain.	self assert: (response entity contents includesSubstring: 'ZnLineTooLong')! !!ZnServerTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!testBytes	self withServerDo: [ :server | | bytes newBytes |		bytes := ZnClient new beOneShot; get: server localUrl / 'bytes/128'.		self assert: bytes size equals: 128.		self assert: bytes last equals: Character lf asciiValue.		newBytes := ZnClient new beOneShot; get: server localUrl / 'bytes/128'.		self assert: newBytes equals: bytes ]! !!ZnServerTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 90053004!testFormTest2	| inputs client |	inputs := #( '1+2=3 & 2+1=3' 'single ''' 'double " - cool ?' 'lves franais' '' ).	self withServerDo: [ :server |		(client := ZnClient new)			url: server localUrl;			addPathSegment: 'form-test-2'.		inputs do: [ :each  |			client				formAt: 'input' put: each;				post.			self assert: client isSuccess.			self assert: (client contents includesSubstring: each) ] ]! !!ZnServerTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!testLimitedAcceptStrategy	self withServerDo: [ :server | | client clients |		server maximumNumberOfConcurrentConnections: 4.		server acceptStrategy: #limited.		server stop; start.		clients := (1 to: 4) collect: [ :each |			ZnClient new				url: server localUrl;				addPathSegment: #random;				clientId: ('client-{1}' format: { each });				timeout: 1;				enforceHttpSuccess;				get;				yourself ].		client := ZnClient new			url: server localUrl;			addPathSegment: #random;			clientId: 'client-5';			timeout: 1;			yourself.		"since there are now 4 open connections, no accept will happen and we time out"		self should: [ client get ] raise: ConnectionTimedOut.		clients do: [ :each | each close ].		client get.		"now the request passes"		self assert: client isSuccess.		client close.				"now try closing one of the four open clients while we are waiting"		clients do: [ :each | each get ].		[ 0.5 second wait. clients first close ] fork.		client get.		"this passes while we are waiting since a connection becomes available"		self assert: client isSuccess.		client close.		clients do: [ :each | each close ].		]! !!ZnServerTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!testRandom	self withServerDo: [ :server | | string newString |		string := ZnClient new beOneShot; get: server localUrl / 'random/128'.		self assert: string size equals: 128.		self assert: string last equals: Character lf.		newString := ZnClient new beOneShot; get: server localUrl / 'random/128'.		self deny: newString equals: string ]! !!ZnServerTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 90060404!testTooManyConcurrentConnections	self usingClassicSocketStreamsOnWindowsDo: [		self withServerDo: [ :server | | client clients |			self deny: server debugMode.			server maximumNumberOfConcurrentConnections: 4.			clients := (1 to: 4) collect: [ :each |				ZnClient new					url: server localUrl;					addPathSegment: #random;					clientId: ('client-{1}' format: { each });					enforceHttpSuccess;					get;					yourself ].			client := ZnClient new					url: server localUrl;					addPathSegment: #random;					clientId: 'client-5';					get;					yourself.			self assert: client response code equals: 503.			clients do: [ :each |				each get; close ].			client get.			self assert: client isSuccess.			client close ] ]! !!ZnEasyTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89290786!testTimeout	self withServerDo: [ : server |		self			should: [				ZnOptions globalDefault clone					at: #socketStreamTimeout put: 1; 					during: [ ZnEasy get: (server localUrl addPathSegment: 'echo'; queryAt: 'delay' put: '2'; yourself) ] ]			raise: ConnectionTimedOut ]! !!ZnClientTest class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!defaultTimeLimit	^ ((self timeout + self retryDelay) * self numberOfRetries) seconds! !!ZnClientTest class methodsFor: 'acccessing' stamp: '9/23/2025 02:00:26'!numberOfRetries	^ 3! !!ZnClientTest class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!retryDelay	^ 5 "seconds"! !!ZnClientTest class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!timeout	^ 20 "seconds"! !!ZnClientTest methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!httpClient	^ ZnClient new		timeout:  self class timeout;		numberOfRetries: self class numberOfRetries;		retryDelay: self class retryDelay;		yourself! !!ZnClientTest methodsFor: 'testing - external' stamp: '9/23/2025 02:00:26' prior: 89125940!testDownloadSmallHTML	| client |	ZnFileSystemUtils deleteIfExists: self smallHtmlUrl pathSegments last.	"First download to a directory"	(client := self httpClient)		url: self smallHtmlUrl;		downloadTo: ZnFileSystemUtils defaultDirectoryPath.	self assert: client isSuccess.	self assert: client response contentType equals: ZnMimeType textHtml.	ZnFileSystemUtils		readStreamFor: self smallHtmlUrl pathSegments last		do: [ :stream | self assert: (stream upToEnd includesSubstring: 'Small') ].	ZnFileSystemUtils deleteIfExists: self smallHtmlUrl pathSegments last.	"Second download to an explicitly named file"	client		url: self smallHtmlUrl;		downloadTo: self smallHtmlUrl pathSegments last.	self assert: client isSuccess.	self assert: client response contentType equals: ZnMimeType textHtml.	ZnFileSystemUtils		readStreamFor: self smallHtmlUrl pathSegments last		do: [ :stream | self assert: (stream upToEnd includesSubstring: 'Small') ].	client close.	ZnFileSystemUtils deleteIfExists: self smallHtmlUrl pathSegments last! !!ZnClientTest methodsFor: 'testing - external' stamp: '9/23/2025 02:00:26' prior: 89154224!testGetGeoIP	| result client |	result := (client := self httpClient)		systemPolicy;		url: self t3EasyGeoIPUrl;		queryAt: 'address' put: '81.83.7.35';		accept: ZnMimeType applicationJson;		contentReader: [ :entity |					self class environment						at: #NeoJSONReader						ifPresent: [ :parserClass | parserClass fromString: entity contents ]						ifAbsent: [ ^ self ] ];		ifFail: [ ^ self fail ];		get.	self assert: result isDictionary.	self assert: (result at: 'country') equals: 'BE'.	client close! !!ZnClientTest methodsFor: 'testing - external' stamp: '9/23/2025 02:00:26' prior: 89104660!testGetSmallHTML	| client |	(client := self httpClient)		url: self smallHtmlUrl;		get.	self assert: client isSuccess.	self assert: client isContentTypeAcceptable.	self assert: client response contentType equals: ZnMimeType textHtml.	self assert: (client contents includesSubstring: 'Small').	self assert: client isConnected.	client close.	self deny: client isConnected! !!ZnClientTest methodsFor: 'testing - external' stamp: '9/23/2025 02:00:26' prior: 89117100!testGetSmallHTMLBinary	| client html bytes |	(client := self httpClient)		url: self smallHtmlUrl;		get.	self assert: client isSuccess.	self assert: client response contentType equals: ZnMimeType textHtml.	self assert: (client contents includesSubstring: 'Small').	html := client contents.	self assert: html isString.	client		beBinary;		get.	self assert: client isSuccess.	self assert: client response contentType equals: ZnMimeType textHtml.	bytes := client contents.	self deny: bytes isString.	self assert: bytes utf8Decoded equals: html.	client close! !!ZnClientTest methodsFor: 'testing - external' stamp: '9/23/2025 02:00:26' prior: 89140184!testGetSmallHTMLOneShot	| client |	(client := self httpClient)		beOneShot;		url: self smallHtmlUrl;		get.	self assert: client isSuccess.	self assert: client response contentType equals: ZnMimeType textHtml.	self assert: (client contents includesSubstring: 'Small').	self deny: client isConnected! !!ZnClientTest methodsFor: 'testing - external' stamp: '9/23/2025 02:00:26' prior: 89103590!testGetSmallHTMLStreaming	| client result contents |	result := (client := self httpClient)		url: self smallHtmlUrl;		streaming: true;		get.	self assert: client isSuccess.	self assert: client response contentType equals: ZnMimeType textHtml.	self assert: result isStream.	self assert: client entity stream equals: result.	contents := ZnUTF8Encoder new decodeBytes: result upToEnd.	self assert: (contents includesSubstring: 'Small').	client close! !!ZnClientTest methodsFor: 'testing - external' stamp: '9/23/2025 02:00:26' prior: 89145586!testGetSmallHTMLTwice	| client |	(client := self httpClient)		url: self smallHtmlUrl;		get.	self assert: client isSuccess.	self assert: client response contentType equals: ZnMimeType textHtml.	self assert: (client contents includesSubstring: 'Small').	client		url: self smallHtmlUrl pathPrintString;		get.	self assert: client isSuccess.	self assert: client response contentType equals: ZnMimeType textHtml.	self assert: (client contents includesSubstring: 'Small').	client close! !!ZnClientTest methodsFor: 'testing - external' stamp: '9/23/2025 02:00:26' prior: 89108964!testGetSmallHTMLUrlConstruction	| client |	(client := self httpClient)		http;		host: self smallHtmlUrl host;		path: self smallHtmlUrl pathPrintString;		get.	self assert: client isSuccess.	self assert: client response contentType equals: ZnMimeType textHtml.	self assert: (client contents includesSubstring: 'Small').	client close! !!ZnClientTest methodsFor: 'testing - external' stamp: '9/23/2025 02:00:26' prior: 89128188!testIfFailWrongType	| client |	(client := self httpClient)		beOneShot;		accept: ZnMimeType imagePng;		enforceAcceptContentType: true;		url: self smallHtmlUrl;		ifFail: [ :exception |			^ self assert: (exception isKindOf: ZnUnexpectedContentType) ];		get.	self fail! !!ZnClientTest methodsFor: 'testing - external' stamp: '9/23/2025 02:00:26' prior: 89148420!testIfModifiedSinceNotModified	| client  response |	(client := self httpClient) host: 'stfx.eu'.	[		response := client			url: '/small.html';			setIfModifiedSince: (Date year: 2012 month: 9 day: 1);			get;			response.		self assert: response isNotModified.		self assert: response hasEntity not ] ensure: [ client close ]! !!ZnClientTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89105578!testOptions	| client |	self withServerDo: [ :server |		server onRequestRespond: [ :request |			request method = #OPTIONS				ifTrue: [ | response |					response := ZnResponse noContent.					response headers at: 'Allow' put: 'GET, HEAD'.					response ]				ifFalse: [ ZnResponse badRequest: request ] ].		(client := ZnClient new)			options: server localUrl.		self assert: client isSuccess.		self deny: client response hasEntity.		self assert: (client response headers at: 'Allow') equals: 'GET, HEAD'.		client close ]! !!ZnClientTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89149238!testPatch	| client |	self withServerDo: [ :server |		server onRequestRespond: [ :request |			request method = #PATCH				ifTrue: [| response |					response := ZnResponse noContent.					response headers at: 'Etag' put: '"e0023aa4f"'.					response]				ifFalse: [ ZnResponse badRequest: request ] ].		(client := ZnClient new)			patch: server localUrl contents: 'Some data as text'.		self assert: client isSuccess.		self deny: client response hasEntity.		self assert: (client response headers at: 'Etag') equals: '"e0023aa4f"'.		client close ]! !!ZnClientTest methodsFor: 'testing - external' stamp: '9/23/2025 02:00:26' prior: 89135168!testProgress	"[ :bar |		bar title: 'Downloading Sources...'.		[			ZnClient new				url: 'http://files.pharo.org/sources/PharoV30.sources';				signalProgress: true;				downloadTo: FileLocator temp ]			on: HTTPProgress			do: [ :progress |				progress isEmpty ifFalse: [ bar current: progress percentage ].				progress resume ] ] asJob run."	self		should: [			self httpClient				beOneShot;				signalProgress: true;				get: self smallHtmlUrl ]		raise: HTTPProgress! !!ZnClientTest methodsFor: 'testing - external' stamp: '9/23/2025 02:00:26' prior: 89153428!testProgressNoIfFail	self		should: [			self httpClient				beOneShot;				signalProgress: true;				ifFail: [ self fail ];				get: self smallHtmlUrl ]		raise: HTTPProgress! !!ZnClientTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89100258!testQueryGoogle	| client |		"Finally give up as all search engines sadly refuse API style calls like this one after a while, especially on CI servers"	self skip. 		(client := ZnClient new)		http;		host: 'www.google.com';		addPath: 'search';		queryAt: 'q' put: 'Pharo Smalltalk';		retryDelay: 20;		numberOfRetries: 3;		get.		[			self 			assert: (client isSuccess or: [client response code = 429])			description: ('Response should be success or 429 code. [{1}] received' format: {				client response  statusLine}).		self 			assert: (client response contentType matches: ZnMimeType textHtml)			description: 'Response has content type html'.		client isSuccess  ifTrue: [			self 				assert: (client contents includesSubstring: 'pharo.org')				description: 'Response includes string pharo.org' ]	] ensure: [ client close ]! !!ZnClientTest methodsFor: 'testing - external' stamp: '9/23/2025 02:00:26' prior: 89158594!testRedirect	| client response target |	target := 'http://zn.stfx.eu'.	client := self httpClient url: target.	client get.	self assert: client isSuccess.	client		close;		maxNumberOfRedirects: 0;		url: target.	self should: [ client get ] raise: ZnTooManyRedirects.	client close.	response := [		self httpClient			beOneShot;			maxNumberOfRedirects: 0;			get: target;			response ] on: ZnTooManyRedirects do: [ :exception | exception resume: #doNotRetry ].	self assert: response isRedirect! !!ZnClientTest methodsFor: 'testing - external' stamp: '9/23/2025 02:00:26' prior: 89125200!testRedirectDontFollow	| client target |	target := 'http://zn.stfx.eu'.	(client := self httpClient)		dontFollowRedirects;		get: target.	self assert: client response isRedirect.	client		enforceHttpSuccess: true;		get: target.	self assert: client response isRedirect.	client close! !!ZnClientTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!testRedirectLoopAndTrail	self withServerDo: [ :server | | client count |		server onRequestRespond: [ :request |			request uri firstPathSegment = 'follow'				ifTrue: [ ZnResponse redirect: 'follow' ] ].		(client := ZnClient new)			url: server localUrl; addPath: 'follow';			maxNumberOfRedirects: 10.		self should: [ client get ] raise: ZnTooManyRedirects.		client close.		(client := ZnClient new)			url: server localUrl; addPath: 'follow';			maxNumberOfRedirects: 10.		[ client get ] on: ZnTooManyRedirects do: [ :exception |			self assert: exception isResumable.			self assert: exception trail size equals: 10.			self assert: (exception trail allSatisfy: [ :each | each = (server localUrl / 'follow') ]) ].		client close.				(client := ZnClient new)			url: server localUrl; addPath: 'follow';			maxNumberOfRedirects: 10.		count := 0.		[ client get ] on: ZnTooManyRedirects do: [ :exception |			count := count + 1.			exception trail size <= 30				ifTrue: [ exception resume ]				ifFalse: [ exception resume: #doNotRetry ] ].		self assert: count equals: 4.		client close ]! !!ZnClientTest methodsFor: 'testing - external' stamp: '9/23/2025 02:00:26'!testVerifyCertificate	| url |	url := 'https://expired-rsa-ev.ssl.com/' asZnUrl.	self assert: (ZnClient new get: url; isSuccess).	self 		should: [ 			ZnOptions globalDefault clone				at: #verifyCertificates put: true;				during: [ ZnClient new get: url ] ]		raise: ZnCertificateVerificationFailed! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89613524!asciiResponse256k	message := ZnResponse ok:		(ZnEntity			with: (self randomAsciiString: 256 * 1024)			type: 'text/plain;charset=ascii')! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89610038!asciiResponse64k	message := ZnResponse ok:		(ZnEntity			with: (self randomAsciiString: 64 * 1024)			type: 'text/plain;charset=ascii')! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89603460!asciiResponse8k	message := ZnResponse ok:		(ZnEntity			with: (self randomAsciiString: 8 * 1024)			type: 'text/plain;charset=ascii')! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89610506!binaryResponse256k	message := ZnResponse ok: (ZnEntity with: (self randomBytes: 256 * 1024))! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89607210!binaryResponse64k	message := ZnResponse ok: (ZnEntity with: (self randomBytes: 64 * 1024))! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89611812!binaryResponse8k	message := ZnResponse ok: (ZnEntity with: (self randomBytes: 8 * 1024))! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89614900!postRequest	message := (ZnRequest post: 'http://zn.stfx.eu/echo/one/two/three?param1=123&param2=foobar')		setAcceptEncodingGzip;		setBasicAuthenticationUsername: 'john' password: 'secret';		entity: (ZnEntity with: (self randomBytes: 512));		yourself! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89612530!simpleRequest	message := ZnRequest get: 'http://zn.stfx.eu/dw-bench'! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89604324!simpleResponse	message := ZnResponse ok: (ZnEntity html: ZnDefaultServerDelegate new generateDWBench)! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89616092!standardRequest	message := (ZnRequest get: 'http://zn.stfx.eu/echo/one/two/three?param1=123&param2=foobar')		setAcceptEncodingGzip;		setBasicAuthenticationUsername: 'john' password: 'secret';		yourself! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89613132!textResponse256k	message := ZnResponse ok: (ZnEntity with: (self randomUnicodeString: 256 * 1024))! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89606822!textResponse64k	message := ZnResponse ok: (ZnEntity with: (self randomUnicodeString: 64 * 1024))! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89605712!textResponse8k	message := ZnResponse ok: (ZnEntity with: (self randomUnicodeString: 8 * 1024))! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89608842!textResponseWide256k	message := ZnResponse ok: (ZnEntity with: (self randomUnicodeWideString: 256 * 1024))! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89609250!textResponseWide64k	message := ZnResponse ok: (ZnEntity with: (self randomUnicodeWideString: 64 * 1024))! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89610886!textResponseWide8k	message := ZnResponse ok: (ZnEntity with: (self randomUnicodeWideString: 8 * 1024))! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89604722!writeRepresentation	representation := self write contents.	self sizeBuffer: representation size + 1024! !!ZnMessageBenchmark methodsFor: 'initialize-release' stamp: '9/23/2025 02:00:26' prior: 89605124!writeUsingGzipEncodingAndChunkingRepresentation	message		setContentEncodingGzip;		setTransferEncodingChunked.	representation := self write contents.	self sizeBuffer: representation size + 1024! !!ZnRequestTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89920814!testMergedFields	| request form mergedFields |	request := ZnRequest post: 'http://host.com/foo?x=1&y=2&x=3'.	form := ZnApplicationFormUrlEncodedEntity new.	form		at: 'z' put: '100';		at: 'z' add: '200';		at: 'y' put: '0'.	request entity: form.	mergedFields := request mergedFields.	self assert: mergedFields keys sorted equals: #('x' 'y' 'z').	self assert: (mergedFields at: 'x') sorted equals: #('1' '3').	self assert: (mergedFields at: 'y') sorted equals: #('0' '2').	self assert: (mergedFields at: 'z') sorted equals: #('100' '200')! !!ZnMagicCookieJarTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!testNetscapeFormat	| jar1 c1 c2 fileReference jar2 |	jar1 := ZnCookieJar new.	c1 := ZnCookie fromString: self cookieString for: 'https://www.google.com' asZnUrl.	c2 := ZnCookie fromString: self cookieStringAlt for: 'https://www.pharo-project.org' asZnUrl.	c2 secure: true.	jar1		add: c1;		add: c2.	fileReference := FileSystem memory / 'cookies.txt'.	jar1 writeNetscapeFormatTo: fileReference.	jar2 := ZnCookieJar new.	jar2 readNetscapeFormatFrom: fileReference.	self assert: (jar2 cookies includes: c1).	self assert: (jar2 cookies includes: c2).	self assert: (jar2 cookiesForUrl: 'https://www.pharo-project.org' asZnUrl) anyOne secure! !!ZnLogEventTest methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!clientId	^ 'client-1'! !!ZnLogEventTest methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!request	^ ZnRequest get: 'http://foo.com/test'! !!ZnLogEventTest methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!response	^ ZnResponse ok: (ZnEntity text: 'OK')! !!ZnLogEventTest methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!serverId	^ 'server-1'! !!ZnLogEventTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!testClientTransactionEvent	| event |	(event := ZnClientTransactionEvent new)		clientId: self clientId;		request: self request;		response: self response;		requestDuration: self timing requestDuration;		responseDuration: self timing responseDuration.	self assert: event id isInteger.	self assert: event processId isInteger.	self assert: event timestamp <= DateAndTime now.	self assert: event clientId equals: self clientId.	self assert: event request uri equals: self request uri.	self assert: event request method equals: self request method.	self assert: event response code equals: self response code.	self assert: event duration equals: self timing requestDuration + self timing responseDuration.	self assert: event printString isString.	^ event! !!ZnLogEventTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!testServerTransactionEvent	| event |	(event := ZnServerTransactionEvent new)		serverId: self serverId;		request: self request;		response: self response;		timing: self timing.	self assert: event id isInteger.	self assert: event processId isInteger.	self assert: event timestamp <= DateAndTime now.	self assert: event serverId equals: self serverId.	self assert: event request uri equals: self request uri.	self assert: event request method equals: self request method.	self assert: event response code equals: self response code.	self assert: event duration equals: self timing totalDuration.	self assert: event printString isString.	^ event! !!ZnLogEventTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!testSimplifiedClientTransactionEvent	| event |	(event := ZnSimplifiedClientTransactionEvent new)		clientId: self clientId;		request: self request;		response: self response;		requestDuration: self timing requestDuration;		responseDuration: self timing responseDuration.	self assert: event id isInteger.	self assert: event processId isInteger.	self assert: event timestamp <= DateAndTime now.	self assert: event clientId equals: self clientId.	self assert: event url equals: self request uri.	self assert: event method equals: self request method.	self assert: event responseCode equals: self response code.	self assert: event size equals: self response contentLength.	self assert: event duration equals: self timing requestDuration + self timing responseDuration.	self assert: event printString isString.	^ event! !!ZnLogEventTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26'!testSimplifiedServerTransactionEvent	| event |	(event := ZnSimplifiedServerTransactionEvent new)		serverId: self serverId;		request: self request;		response: self response;		timing: self timing.	self assert: event id isInteger.	self assert: event processId isInteger.	self assert: event timestamp <= DateAndTime now.	self assert: event serverId equals: self serverId.	self assert: event url equals: self request uri.	self assert: event method equals: self request method.	self assert: event responseCode equals: self response code.	self assert: event size equals: self response contentLength.	self assert: event duration equals: self timing totalDuration.	self assert: event printString isString.	^ event! !!ZnLogEventTest methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!timing	^ ZnServerTransactionTiming new			requestDuration: 1;			responseDuration: 2;			yourself! !!ZnLoggingTest methodsFor: 'running' stamp: '9/23/2025 02:00:26'!setUp	super setUp.	logEventCollection := OrderedCollection new.		ZnLogEvent announcer		when: ZnLogEvent		do: [ :event | logEventCollection add: event ]		for: self! !!ZnLoggingTest methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!smallHtmlUrl	^ 'http://zn.stfx.eu/zn/small.html' asZnUrl! !!ZnLoggingTest methodsFor: 'running' stamp: '9/23/2025 02:00:26'!tearDown	"thisContext crTrace."		ZnLogEvent announcer unsubscribe: self.	logEventCollection removeAll.	logEventCollection := nil.		super tearDown! !!ZnLoggingTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26'!testClientLogging	| client count |	(client := ZnClient new)		clientId: #C1;		beOneShot.	client get: self smallHtmlUrl.	client close.	count := ZnLogEvent announcer numberOfSubscriptions.	ZnLogEvent announcer unsubscribe: self.	self		assert: ZnLogEvent announcer numberOfSubscriptions		equals: count - 1.	self deny: logEventCollection isEmpty.	self assert: logEventCollection anyOne clientId equals: #C1! !!ZnLoggingTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26'!testGet	ZnServer withOSAssignedPortDo: [ :server |		ZnClient new			systemPolicy;			url: server localUrl / #small;			get ].	self assert: logEventCollection notEmpty! !!ZnLoggingTest methodsFor: 'tests' stamp: '9/23/2025 02:00:26'!testServerLogging	| client count renderedLogEvents |	ZnServer withOSAssignedPortDo: [ :server |			1 to: 3 do: [ :logLevel |					server						serverId: ('S-{1}' format: { logLevel });						logLevel: logLevel.					client := ZnClient new.					client						clientId: ('C-{1}' format: { logLevel });						logLevel: logLevel.					client get: (server localUrl addPathSegment: #small).					self assert: client isSuccess.					client get: (server localUrl addPathSegment: #error).					self deny: client isSuccess.					server delegate						map: 'redirect'						to: [ :request | ZnResponse redirect: #welcome ].					client get: (server localUrl addPathSegment: #redirect).					self assert: client isSuccess.					client close ] ].	count := ZnLogEvent announcer numberOfSubscriptions.	ZnLogEvent announcer unsubscribe: self.	self		assert: ZnLogEvent announcer numberOfSubscriptions		equals: count - 1.	self deny: logEventCollection isEmpty.	renderedLogEvents := String streamContents: [ :out |			                     logEventCollection do: [ :event |					                     out						                     print: event;						                     cr ] ].	self deny: renderedLogEvents isEmpty! !!ZnLineReaderTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89554316!testLineTooLongDefault	| input reader |	input := (String new: (ZnCurrentOptions at: #maximumLineLength) + 1) atAllPut: $X.	reader := ZnLineReader on: input readStream.	self should: [ reader nextLine ] raise: ZnLineTooLong! !!ZnHeadersTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89458576!testReadingMultiline	| string headers |	string := 'Content-Type: text/plain', String crlf,		'Long: foo', String crlf,		' bar', String crlf,		String tab, 'baz', String crlf,		'Content-Length: 128', String crlf.	headers := ZnHeaders readFrom: string asByteArray readStream.	self assert: (headers includesKey: 'Content-Type').	self assert: (headers includesKey: 'Content-Length').	self assert: (headers at: 'Content-Type') equals: 'text/plain'.	self assert: (headers at: 'Content-Length') equals: '128'.	self assert: (headers includesKey: 'Long').	self assert: (headers at: 'long') equals: 'foo bar	baz'! !!ZnRequestLineTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89905624!testWriting	| requestLine string |	requestLine := ZnRequestLine method: #GET uri: '/foo/bar/xyz.txt'.	string := String streamContents: [ :stream | requestLine writeOn: stream ].	self assert: string equals: 'GET /foo/bar/xyz.txt HTTP/1.1' , String crlf! !ZnClientTest removeSelector: #testLogging!"Zinc-Tests"!!ZnSecureServer commentStamp: '' prior: 0!I am ZnSecureServer, an implementation of an HTTPS server.I am a ZnMultiThreadedServer(ZnSecureServer on: 1443)	certificate: '/home/sven/ssl/key-cert.pem';	logToTranscript;	start;	yourself.	Disclaimer: this is an experimental proof of concept.!!ZnSecureServer methodsFor: 'accessing'!certificate	^ certificate! !!ZnSecureServer methodsFor: 'accessing'!certificate: anObject	certificate := anObject! !!ZnSecureServer methodsFor: 'accessing'!scheme	^ #https! !!ZnSecureServer methodsFor: 'private'!socketStreamOn: socket	| stream |	stream := ZdcSecureSocketStream on: socket.	stream sslSession certificateName: self certificate.	stream accept.	^ stream! !"Zinc-Zodiac-Core"!!ZnHTTPSTest class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 89426374!defaultTimeLimit	^ ((self timeout + self retryDelay) * self numberOfRetries) seconds! !!ZnHTTPSTest class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!numberOfRetries	^ 3! !!ZnHTTPSTest class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!retryDelay	^ 5 "seconds"! !!ZnHTTPSTest class methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!timeout	^ 20 "seconds"! !!ZnHTTPSTest methodsFor: 'accessing' stamp: '9/23/2025 02:00:26'!httpClient	^ ZnClient new		timeout:  self class timeout;		numberOfRetries: self class numberOfRetries;		retryDelay: self class retryDelay;		yourself! !!ZnHTTPSTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89425440!testAmazonAWS	| client |	self ensureSocketStreamFactory.	self isNativeSSLPluginPresent ifFalse: [ ^ self ].	(client := self httpClient) 		get: 'https://aws.amazon.com/'.	self assert: client isSuccess.	self assert: (client contents includesSubstring: 'Amazon').	client close! !!ZnHTTPSTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89418836!testGmailEncrypted	| client |	self ensureSocketStreamFactory.	self isNativeSSLPluginPresent ifFalse: [ ^ self ].	(client := self httpClient)		maxNumberOfRedirects: 10;		get: 'https://www.gmail.com'.	self assert: client isSuccess.	self assert: (client contents includesSubstring: 'Google').	self assert: (client contents includesSubstring: 'mail').	client close! !!ZnHTTPSTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89424522!testGoogleEncrypted	| client |	self ensureSocketStreamFactory.	self isNativeSSLPluginPresent ifFalse: [ ^ self ].		client := self httpClient.	client		retryDelay: 1;		numberOfRetries: 3;		get: 'https://encrypted.google.com/search?q=Smalltalk'.		[ 		self 			assert: (client isSuccess or: [client response code = 429])			description: ('Response should be success or 429 code. [{1}] received' format: {				client response  statusLine}).		self 			assert: (client contents includesSubstring: 'Google')			description: 'Response includes string google'.    		client isSuccess  ifTrue: [			self 				assert: (client contents includesSubstring: 'Smalltalk')				description: 'Response includes string Smalltalk ' ]	] ensure: [		client close ]! !!ZnHTTPSTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89415774!testRequestResponse	| query stream request response numberOfRetriesRemaining completed |	self ensureSocketStreamFactory.	self isNativeSSLPluginPresent ifFalse: [ ^ self ].	query := 'Smalltalk'.	numberOfRetriesRemaining := self class numberOfRetries.	completed := false.	[ numberOfRetriesRemaining > 0 ] whileTrue: [		[			stream := ZdcSecureSocketStream openConnectionToHostNamed: 'duckduckgo.com' port: 443.			stream timeout: self class timeout.			request := nil.			response := [				request := ZnRequest get: 'https://duckduckgo.com?q=', query.				stream connect.				request writeOn: stream.				stream flush.				ZnResponse readFrom: stream ] ensure: [ stream close ].			completed := true.			numberOfRetriesRemaining := 0 ]				on: NetworkError 				do: [ :exception | 					completed := exception.					self class retryDelay seconds wait.					numberOfRetriesRemaining := numberOfRetriesRemaining - 1 ] ].	self assert: completed equals: true.	self assert: response isSuccess.	self assert: (response contents includesSubstring: 'Duck').   	self assert: (response contents includesSubstring: query).! !!ZnHTTPSTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89421980!testTransfers	self timeLimit: 300 seconds.	self ensureSocketStreamFactory.	self isNativeSSLPluginPresent ifFalse: [ ^ self ].		(Integer primesUpTo: 100) do: [ :each | | size client |		size := 1024 * each + each.		(client := self httpClient)			https;			host: 's3-eu-west-1.amazonaws.com';			addPath: 'public-stfx-eu';			addPath: ('test-', size asString, '.txt');			get;			close.		self assert: client isSuccess.		self assert: (client response contentType matches: ZnMimeType textPlain).		self assert: client response contentLength equals: size.		self 			assert: client contents 			equals: (self class generateTestData: size)	]! !!ZnHTTPSTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89419738!testTransfersSingleClient	| client |	self ensureSocketStreamFactory.	self isNativeSSLPluginPresent ifFalse: [ ^ self ].	(client := self httpClient)		https;		host: 's3-eu-west-1.amazonaws.com'.	(Integer primesUpTo: 100) do: [ :each | | size |		size := 1024 * each + each.		client			url: ('/public-stfx-eu/test-', size asString, '.txt');			get.		self assert: client isSuccess.		self assert: (client response contentType matches: ZnMimeType textPlain).		self assert: client response contentLength equals: size.		self 			assert: client contents 			equals: (self class generateTestData: size)	].	client close! !!ZnHTTPSTest methodsFor: 'testing' stamp: '9/23/2025 02:00:26' prior: 89423426!testWikimedia	| client |	self ensureSocketStreamFactory.	self isNativeSSLPluginPresent ifFalse: [ ^ self ]. 	(client := self httpClient) 		get: 'https://secure.wikimedia.org/'.	self assert: client isSuccess.	self assert: (client contents includesSubstring: 'Wikimedia').	client close! !!ZnHTTPSTest methodsFor: 'accessing' stamp: '9/23/2025 02:00:26' prior: 89424164!timeLimit: seconds	(TestCase canUnderstand: #timeLimit:)		ifTrue: [ super timeLimit: seconds ]! !"Zinc-Zodiac-Tests"!----SNAPSHOT----2025-09-26T15:47:30.949627-05:00 GraphDB-Client.image priorSource: 721!----SNAPSHOT----2025-09-26T15:47:30.952256-05:00 GraphDB-Client.image priorSource: 399132!----QUIT----2025-09-26T15:49:49.817471-05:00 GraphDB-Client.image priorSource: 399221!----QUIT----2025-09-26T15:49:49.820058-05:00 GraphDB-Client.image priorSource: 399313!----QUIT/NOSAVE----2025-09-26T16:31:00.524831-05:00 GraphDB-Client.image priorSource: 399401!----QUIT/NOSAVE----2025-09-26T16:31:00.527125-05:00 GraphDB-Client.image priorSource: 399401!